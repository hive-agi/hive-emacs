;;; hive-mcp-claude-code.el --- -*- lexical-binding: t; -*-
;; Generated by ClojureElisp

(require 'clojure-elisp-runtime)

;;; Code:



(condition-case nil
    (require 'claude-code)
  (error nil))

(declare-function hive-mcp-api-get-context "hive-mcp-api")

(declare-function hive-mcp-api-memory-add "hive-mcp-api")

(declare-function hive-mcp-api-memory-query "hive-mcp-api")

(declare-function hive-mcp-api-list-workflows "hive-mcp-api")

(declare-function hive-mcp-api-run-workflow "hive-mcp-api")

(declare-function hive-mcp-api-notify "hive-mcp-api")

(declare-function hive-mcp-api-conversation-log "hive-mcp-api")

(declare-function hive-mcp-api-capabilities "hive-mcp-api")

(defgroup hive-mcp-claude-code nil
  "Integration between claude-code.el and hive-mcp."
  :group 'claude-code
  :prefix "hive-mcp-claude-code-")

(defcustom hive-mcp-claude-code-auto-context nil
  "When non-nil, automatically include MCP context in commands.\nContext includes buffer info, project, git status, and relevant memory."
  :group 'hive-mcp-claude-code
  :type 'boolean)

(defcustom hive-mcp-claude-code-log-conversations nil
  "When non-nil, log conversations to hive-mcp memory.\nThis enables persistent conversation history per project."
  :group 'hive-mcp-claude-code
  :type 'boolean)

(defcustom hive-mcp-claude-code-context-format 'compact
  "Format for context injection.\n- `compact': Single line summary\n- `full': Complete context JSON\n- `smart': Include only relevant sections"
  :group 'hive-mcp-claude-code
  :type '(choice (const :tag "Compact summary" compact) (const :tag "Full JSON context" full) (const :tag "Smart selection" smart)))

(defcustom hive-mcp-claude-code-notify-on-complete t
  "When non-nil, use hive-mcp notifications when Claude completes."
  :group 'hive-mcp-claude-code
  :type 'boolean)

(defvar hive-mcp-claude-code--available nil
  "Cached check for whether hive-mcp-api is available.")

(defun hive-mcp-claude-code---available-p ()
  "Check if hive-mcp-api is available."
  (or hive-mcp-claude-code--available (setq hive-mcp-claude-code--available (featurep 'hive-mcp-api))))

(defun hive-mcp-claude-code---ensure-available ()
  "Ensure hive-mcp is available, error if not."
  (unless (hive-mcp-claude-code--available-p)
    (if (require 'hive-mcp-api nil t) (setq hive-mcp-claude-code--available t) (error "Emacs-mcp-api not available.  Load hive-mcp first"))))

(defun hive-mcp-claude-code---format-context-compact (ctx)
  "Format CTX as compact one-line summary."
  (let* ((buffer (plist-get ctx :buffer))
        (project (plist-get ctx :project))
        (git (plist-get ctx :git)))
    (format "[%s @ %s%s]" (or (plist-get buffer :name) "unknown") (or (plist-get project :name) "no-project") (if (plist-get git :dirty) " (modified)" ""))))

(defun hive-mcp-claude-code---format-context-smart (ctx)
  "Format CTX with only relevant sections."
  (let* ((parts '())
        (buffer (plist-get ctx :buffer))
        (region (plist-get ctx :region))
        (defun-ctx (plist-get ctx :defun))
        (project (plist-get ctx :project))
        (git (plist-get ctx :git))
        (memory (plist-get ctx :memory)))
    (when buffer
    (push (format "File: %s:%d" (or (plist-get buffer :file) (plist-get buffer :name)) (or (plist-get buffer :line) 1)) parts))
    (when region
    (push (format "Selected: %s" (plist-get region :text)) parts))
    (when defun-ctx
    (push (format "In: %s" (plist-get defun-ctx :name)) parts))
    (when (and git (plist-get git :dirty))
    (let* ((modified (plist-get git :modified)))
    (when modified
    (push (format "Modified files: %s" (mapconcat #'identity (seq-take modified 3) ", ")) parts))))
    (when memory
    (let* ((notes (plist-get memory :notes)))
    (when (and notes (> (length notes) 0))
    (push (format "Recent notes: %d" (length notes)) parts))))
    (string-join (nreverse parts) "\n")))

(defun hive-mcp-claude-code---get-context-string ()
  "Get context string based on `hive-mcp-claude-code-context-format'."
  (when (hive-mcp-claude-code--available-p)
    (let* ((ctx (hive-mcp-api-get-context)))
    (pcase hive-mcp-claude-code-context-format
  ((quote compact) (hive-mcp-claude-code--format-context-compact ctx))
  ((quote full) (json-encode ctx))
  ((quote smart) (hive-mcp-claude-code--format-context-smart ctx))))))

(defun hive-mcp-claude-code-send-with-context ()
  "Read command and send to Claude with hive-mcp context."
  (interactive)
  (hive-mcp-claude-code--ensure-available)
  (let* ((ctx-string (hive-mcp-claude-code--get-context-string))
        (cmd (clel-read-string "Claude command: " nil 'claude-code-command-history))
        (full-cmd (if ctx-string (format "%s\n\nContext:\n%s" cmd ctx-string) cmd)))
    (claude-code--do-send-command full-cmd)))

(defun hive-mcp-claude-code-save-to-memory ()
  "Save selected text or prompt to project memory."
  (interactive)
  (hive-mcp-claude-code--ensure-available)
  (let* ((text (if (use-region-p) (buffer-substring-no-properties (region-beginning) (region-end)) (clel-read-string "Note content: ")))
        (type (completing-read "Type: " '("note" "snippet" "convention" "decision") nil t))
        (tags (split-string (clel-read-string "Tags (comma-separated): ") "," t " ")))
    (hive-mcp-api-memory-add type text tags)
    (message "Saved to project memory as %s" type)))

(defun hive-mcp-claude-code-query-memory ()
  "Query project memory and display results."
  (interactive)
  (hive-mcp-claude-code--ensure-available)
  (let* ((type (completing-read "Query type: " '("note" "snippet" "convention" "decision" "conversation") nil t "note"))
        (results (hive-mcp-api-memory-query type nil 10))
        (buf (get-buffer-create "*MCP Memory*")))
    (with-current-buffer buf
    (erase-buffer)
    (insert (format "=== Project Memory: %s ===\n\n" type))
    (if (equal (length results) 0) (insert "No entries found.\n") (cl-dotimes (i (length results))
    (let* ((entry (aref results i))
        (content (alist-get 'content entry))
        (created (alist-get 'created entry))
        (tags (alist-get 'tags entry)))
    (insert (format "--- Entry %d ---\n" (1+ i)))
    (insert (format "Created: %s\n" created))
    (when (and tags (> (length tags) 0))
    (insert (format "Tags: %s\n" (mapconcat #'identity tags ", "))))
    (insert (format "\n%s\n\n" content)))))
    (goto-char (point-min)))
    (display-buffer buf)))

(defun hive-mcp-claude-code-run-workflow ()
  "Select and run an hive-mcp workflow."
  (interactive)
  (hive-mcp-claude-code--ensure-available)
  (let* ((workflows (hive-mcp-api-list-workflows))
        (names (mapcar (lambda (w)
    (alist-get 'name w)) workflows))
        (selected (completing-read "Run workflow: " names nil t)))
    (hive-mcp-api-run-workflow selected)
    (message "Workflow '%s' executed" selected)))

(defun hive-mcp-claude-code-show-capabilities ()
  "Show hive-mcp capabilities and status."
  (interactive)
  (if (hive-mcp-claude-code--available-p) (let* ((caps (hive-mcp-api-capabilities)))
    (message "Emacs-mcp v%s: %s" (plist-get caps :version) (mapconcat #'symbol-name (plist-get caps :capabilities) ", "))) (message "Emacs-mcp is not loaded")))

(defun hive-mcp-claude-code-get-context ()
  "Get and display current hive-mcp context."
  (interactive)
  (hive-mcp-claude-code--ensure-available)
  (let* ((ctx (hive-mcp-api-get-context))
        (formatted (hive-mcp-claude-code--format-context-smart ctx))
        (buf (get-buffer-create "*MCP Context*")))
    (with-current-buffer buf
    (erase-buffer)
    (insert "=== Current Context ===\n\n")
    (insert formatted)
    (insert "\n\n=== Full JSON ===\n\n")
    (insert (json-encode ctx))
    (goto-char (point-min))
    (when (fboundp 'json-mode)
    (json-mode)))
    (display-buffer buf)))

(transient-define-prefix hive-mcp-claude-code-transient ()
  "MCP integration menu for Claude Code."
  ["hive-mcp Integration" ["Context & Memory" ("c" "Show context" hive-mcp-claude-code-get-context) ("s" "Send with context" hive-mcp-claude-code-send-with-context) ("m" "Save to memory" hive-mcp-claude-code-save-to-memory) ("q" "Query memory" hive-mcp-claude-code-query-memory)] ["Workflows & Status" ("w" "Run workflow" hive-mcp-claude-code-run-workflow) ("?" "Show capabilities" hive-mcp-claude-code-show-capabilities)] ["Settings" ("C" "Toggle auto-context" hive-mcp-claude-code-toggle-auto-context) ("L" "Toggle conversation logging" hive-mcp-claude-code-toggle-logging)]])

(defun hive-mcp-claude-code-toggle-auto-context ()
  "Toggle automatic context injection."
  (interactive)
  (setq hive-mcp-claude-code-auto-context (not hive-mcp-claude-code-auto-context))
  (message "Auto-context %s" (if hive-mcp-claude-code-auto-context "enabled" "disabled")))

(defun hive-mcp-claude-code-toggle-logging ()
  "Toggle conversation logging."
  (interactive)
  (setq hive-mcp-claude-code-log-conversations (not hive-mcp-claude-code-log-conversations))
  (message "Conversation logging %s" (if hive-mcp-claude-code-log-conversations "enabled" "disabled")))

(defun hive-mcp-claude-code---maybe-add-context (cmd)
  "Maybe add context to CMD if auto-context is enabled."
  (if (and hive-mcp-claude-code-auto-context (hive-mcp-claude-code--available-p)) (let* ((ctx (hive-mcp-claude-code--get-context-string)))
    (if ctx (format "%s\n\n[Context: %s]" cmd ctx) cmd)) cmd))

(defun hive-mcp-claude-code---log-command (cmd)
  "Log CMD to conversation memory if logging is enabled."
  (when (and hive-mcp-claude-code-log-conversations (hive-mcp-claude-code--available-p))
    (ignore-errors (hive-mcp-api-conversation-log "user" cmd))))

(defun hive-mcp-claude-code---notification-function (title message)
  "Use hive-mcp for notifications if available.\nTITLE and MESSAGE are passed to the notification."
  (if (and hive-mcp-claude-code-notify-on-complete (hive-mcp-claude-code--available-p)) (hive-mcp-api-notify (format "%s: %s" title message) "info") (claude-code-default-notification title message)))

(defun hive-mcp-claude-code---advise-send-command (orig-fun cmd)
  "Advice for `claude-code--do-send-command' to add context and logging.\nORIG-FUN is the original function, CMD is the command."
  (let* ((enhanced-cmd (hive-mcp-claude-code--maybe-add-context cmd)))
    (hive-mcp-claude-code--log-command cmd)
    (funcall orig-fun enhanced-cmd)))

(defvar hive-mcp-claude-code-command-map (let* ((map (make-sparse-keymap)))
    (define-key map (kbd "c") #'hive-mcp-claude-code-get-context)
    (define-key map (kbd "s") #'hive-mcp-claude-code-send-with-context)
    (define-key map (kbd "m") #'hive-mcp-claude-code-save-to-memory)
    (define-key map (kbd "q") #'hive-mcp-claude-code-query-memory)
    (define-key map (kbd "w") #'hive-mcp-claude-code-run-workflow)
    (define-key map (kbd "M") #'hive-mcp-claude-code-transient)
    map)
  "Keymap for hive-mcp-claude-code commands.")

(define-minor-mode hive-mcp-claude-code-mode
  "Minor mode for hive-mcp integration with claude-code.el.\n\nWhen enabled, provides:\n- Context injection for Claude commands\n- Memory persistence integration\n- Workflow access\n- Conversation logging\n\nKey bindings under `C-c c m' prefix (customizable).\n\nRequires `claude-code' package to be installed."
  :init-value nil
  :lighter " MCP"
  :global t
  :group 'hive-mcp-claude-code
  (if hive-mcp-claude-code-mode (if (not (featurep 'claude-code)) (progn
  (setq hive-mcp-claude-code-mode nil)
  (message "hive-mcp-claude-code: claude-code not available, addon disabled")) (advice-add 'claude-code--do-send-command :around #'hive-mcp-claude-code--advise-send-command)) (advice-remove 'claude-code--do-send-command #'hive-mcp-claude-code--advise-send-command)))

(with-eval-after-load 'hive-mcp-addons
  (hive-mcp-addon-register 'claude-code :version "0.1.0" :description "Integration with claude-code.el (Claude Code CLI)" :requires '(claude-code hive-mcp-api) :provides '(hive-mcp-claude-code-mode hive-mcp-claude-code-transient)))

(provide 'hive-mcp-claude-code)
;;; hive-mcp-claude-code.el ends here
