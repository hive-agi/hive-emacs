;;; hive-mcp-ai-bridge.el --- -*- lexical-binding: t; -*-
;; Generated by ClojureElisp

(require 'clojure-elisp-runtime)

;;; Code:



(require 'cl-lib)

(require 'subr-x)

(declare-function hive-mcp-memory-query "hive-mcp-memory")

(declare-function hive-mcp-memory-add "hive-mcp-memory")

(declare-function hive-mcp-memory-search-semantic "hive-mcp-memory")

(declare-function hive-mcp-swarm-dispatch "hive-mcp-swarm")

(declare-function hive-mcp-swarm-status "hive-mcp-swarm")

(defgroup hive-mcp-ai-bridge nil
  "Universal AI integration bridge."
  :group 'hive-mcp
  :prefix "hive-mcp-ai-")

(defcustom hive-mcp-ai-context-conventions-limit 5
  "Maximum number of conventions to inject into AI context."
  :group 'hive-mcp-ai-bridge
  :type 'integer)

(defcustom hive-mcp-ai-context-decisions-limit 3
  "Maximum number of decisions to inject into AI context."
  :group 'hive-mcp-ai-bridge
  :type 'integer)

(defcustom hive-mcp-ai-context-semantic-limit 3
  "Maximum number of semantic search results to inject."
  :group 'hive-mcp-ai-bridge
  :type 'integer)

(defcustom hive-mcp-ai-store-notable-responses t
  "If non-nil, automatically store notable AI responses to memory."
  :group 'hive-mcp-ai-bridge
  :type 'boolean)

(defcustom hive-mcp-ai-notable-min-length 200
  "Minimum length for a response to be considered notable."
  :group 'hive-mcp-ai-bridge
  :type 'integer)

(defcustom hive-mcp-ai-log-interactions t
  "If non-nil, log AI interactions for audit trail."
  :group 'hive-mcp-ai-bridge
  :type 'boolean)

(defvar hive-mcp-ai--rate-limit-table (make-hash-table :test 'equal)
  "Hash table tracking last call timestamps per source for rate limiting.\nKeys are source strings, values are float-time timestamps.")

(defcustom hive-mcp-ai-rate-limit-interval 1.0
  "Minimum seconds between external API calls per source."
  :group 'hive-mcp-ai-bridge
  :type 'float)

(defun hive-mcp-ai-bridge---rate-limit-check (source)
  "Check if SOURCE is within rate limit.\nReturns t if the call is allowed, nil if throttled."
  (let* ((last-call (gethash source hive-mcp-ai--rate-limit-table 0.0))
        (now (float-time))
        (elapsed (- now last-call)))
    (when (>= elapsed hive-mcp-ai-rate-limit-interval) (progn
  (puthash source now hive-mcp-ai--rate-limit-table)
  t))))

(defun hive-mcp-ai-bridge---memory-available-p ()
  "Check if memory system is available."
  (and (require 'hive-mcp-memory nil t) (fboundp 'hive-mcp-memory-query)))

(defun hive-mcp-ai-bridge-ai-get-conventions (&rest args)
  (let ((limit (nthcdr 0 args)))
    "Get conventions from memory, formatted for AI context.\nLIMIT overrides `hive-mcp-ai-context-conventions-limit'."
  (when (hive-mcp-ai-bridge--memory-available-p)
    (let* ((n (or limit hive-mcp-ai-context-conventions-limit))
        (entries (hive-mcp-memory-query 'convention nil nil n)))
    (when entries
    (mapconcat (lambda (e)
    (format "- %s" (plist-get e :content))) entries "\n"))))))

(defun hive-mcp-ai-bridge-ai-get-decisions (&rest args)
  (let ((limit (nthcdr 0 args)))
    "Get recent decisions from memory, formatted for AI context.\nLIMIT overrides `hive-mcp-ai-context-decisions-limit'."
  (when (hive-mcp-ai-bridge--memory-available-p)
    (let* ((n (or limit hive-mcp-ai-context-decisions-limit))
        (entries (hive-mcp-memory-query 'decision nil nil n)))
    (when entries
    (mapconcat (lambda (e)
    (let* ((created (plist-get e :created)))
    (format "- [%s] %s" (if created (substring created 0 10) "?") (plist-get e :content)))) entries "\n"))))))

(defun hive-mcp-ai-bridge-ai-semantic-search (&rest args)
  (let ((query (nth 0 args)) (limit (nthcdr 1 args)))
    "Search memory semantically for QUERY.\nLIMIT overrides `hive-mcp-ai-context-semantic-limit'.\nReturns formatted context string or nil."
  (when (and (hive-mcp-ai-bridge--memory-available-p) (fboundp 'hive-mcp-memory-search-semantic))
    (let* ((n (or limit hive-mcp-ai-context-semantic-limit))
        (results (hive-mcp-memory-search-semantic query n)))
    (when results
    (mapconcat (lambda (r)
    (format "- [%s] %s" (plist-get r :type) (plist-get r :content))) results "\n"))))))

(defun hive-mcp-ai-bridge-ai-build-context (&rest args)
  (let ((prompt (nthcdr 0 args)))
    "Build AI context from memory.\nIf PROMPT is provided, includes semantic search results.\nReturns formatted context string suitable for injection."
  (let* ((sections nil))
    (when-let ((convs (hive-mcp-ai-bridge-ai-get-conventions)))
    (push (format "## Team Conventions\n%s" convs) sections))
    (when-let ((decs (hive-mcp-ai-bridge-ai-get-decisions)))
    (push (format "## Recent Decisions\n%s" decs) sections))
    (when prompt
    (when-let ((semantic (hive-mcp-ai-bridge-ai-semantic-search prompt)))
    (push (format "## Related Context\n%s" semantic) sections)))
    (when sections
    (concat "# Project Knowledge\n\n" (mapconcat #'identity (nreverse sections) "\n\n"))))))

(defun hive-mcp-ai-bridge-ai-inject-context (&rest args)
  (let ((prompt (nth 0 args)) (include-semantic (nthcdr 1 args)))
    "Inject memory context into PROMPT.\nIf INCLUDE-SEMANTIC is non-nil, includes semantic search results.\nReturns the augmented prompt string."
  (let* ((context (hive-mcp-ai-bridge-ai-build-context (when include-semantic
    prompt))))
    (if context (concat context "\n\n---\n\n" prompt) prompt))))

(defun hive-mcp-ai-bridge-ai-response-notable-p (response)
  "Check if RESPONSE is notable enough to store.\nReturns non-nil if response should be stored."
  (and response (stringp response) (>= (length response) hive-mcp-ai-notable-min-length) (or (string-match-p "```" response) (string-match-p "^[-*] " response) (string-match-p "^[0-9]+\\. " response))))

(defun hive-mcp-ai-bridge-ai-store-response (&rest args)
  (let ((response (nth 0 args)) (source (nth 1 args)) (tags (nthcdr 2 args)))
    "Store RESPONSE to memory if notable.\nSOURCE is the AI package name (e.g., \"gptel\").\nTAGS is optional list of additional tags.\nRate-limited: only stores if not throttled for SOURCE."
  (when (and hive-mcp-ai-store-notable-responses (hive-mcp-ai-bridge--memory-available-p) (hive-mcp-ai-bridge-ai-response-notable-p response) (hive-mcp-ai-bridge--rate-limit-check (concat "store:" source)))
    (let* ((truncated (if (> (length response) 2000) (concat (substring response 0 1997) "...") response))
        (all-tags (append (list source "ai-response") tags)))
    (hive-mcp-memory-add 'snippet truncated all-tags)
    (message "[ai-bridge] Stored notable response from %s" source)))))

(defvar hive-mcp-ai--interaction-log nil
  "Log of recent AI interactions for audit.")

(defun hive-mcp-ai-bridge-ai-log-interaction (&rest args)
  (let ((source (nth 0 args)) (action (nth 1 args)) (details (nthcdr 2 args)))
    "Log an AI interaction.\nSOURCE is the AI package, ACTION is what happened.\nDETAILS is optional plist of additional info."
  (when hive-mcp-ai-log-interactions
    (push (list :timestamp (format-time-string "%FT%T%z") :source source :action action :details details) hive-mcp-ai--interaction-log)
    (when (> (length hive-mcp-ai--interaction-log) 100)
    (setq hive-mcp-ai--interaction-log (seq-take hive-mcp-ai--interaction-log 100))))))

(defun hive-mcp-ai-bridge-ai-get-interaction-log (&rest args)
  (let ((limit (nthcdr 0 args)))
    "Get recent interaction log entries.\nLIMIT defaults to 20."
  (seq-take hive-mcp-ai--interaction-log (or limit 20))))

(defun hive-mcp-ai-bridge---swarm-available-p ()
  "Check if swarm system is available."
  (and (require 'hive-mcp-swarm nil t) (fboundp 'hive-mcp-swarm-dispatch)))

(defun hive-mcp-ai-bridge-ai-dispatch-to-swarm (&rest args)
  (let ((task (nth 0 args)) (rest (nthcdr 1 args)))
    "Dispatch TASK to swarm agent.\nKeyword args:\n  :preset   - agent preset (e.g., \"code-review\")\n  :slave-id - optionally target a specific slave\n  :callback - reserved for future async result handling\n  :source   - identifies the calling AI package\n\nRate-limited per source. Returns task-id on success, nil on failure."
  (let* ((preset (plist-get kwargs :preset))
        (slave-id (plist-get kwargs :slave-id))
        (source (plist-get kwargs :source)))
    (when (and (hive-mcp-ai-bridge--swarm-available-p) (hive-mcp-ai-bridge--rate-limit-check (or source "ai-bridge")))
    (hive-mcp-ai-bridge-ai-log-interaction (or source "ai-bridge") "swarm-dispatch" (list :task task :preset preset))
    (let* ((target (or slave-id (hive-mcp-ai-bridge--get-or-spawn-slave preset))))
    (when target
    (hive-mcp-swarm-dispatch target task)))))))

(defun hive-mcp-ai-bridge---get-or-spawn-slave (preset)
  "Get an idle slave with PRESET or spawn one.\nReturns slave-id or nil."
  (when (hive-mcp-ai-bridge--swarm-available-p)
    (let* ((status (hive-mcp-swarm-status))
        (slaves (plist-get status :slaves-detail))
        (matching (cl-find-if (lambda (s)
    (and (eq (plist-get s :status) 'idle) (member preset (plist-get s :presets)))) slaves)))
    (if matching (plist-get matching :slave-id) (when (fboundp 'hive-mcp-swarm-spawn)
    (hive-mcp-swarm-spawn (or preset "ai-worker") :presets (list preset)))))))

(defun hive-mcp-ai-bridge-ai-format-context-for (package context)
  "Format CONTEXT for specific AI PACKAGE.\nReturns appropriately formatted string."
  (pcase package
  ((quote gptel) context)
  ((quote aider) (replace-regexp-in-string "^# " "## " context))
  ((quote ellama) context)
  ((quote org-ai) (replace-regexp-in-string "^## " "** " (replace-regexp-in-string "^# " "* " context)))
  ('_ context)))

(defvar hive-mcp-ai-pre-request-hook nil
  "Hook run before any AI request.\nFunctions receive (source prompt) arguments.")

(defvar hive-mcp-ai-post-response-hook nil
  "Hook run after AI response.\nFunctions receive (source response) arguments.")

(defun hive-mcp-ai-bridge-ai-run-pre-request-hooks (source prompt)
  "Run pre-request hooks for SOURCE with PROMPT.\nReturns possibly modified prompt."
  (let* ((result prompt))
    (dolist (fn hive-mcp-ai-pre-request-hook)
    (when-let ((modified (funcall fn source result)))
    (setq result modified)))
    result))

(defun hive-mcp-ai-bridge-ai-run-post-response-hooks (source response)
  "Run post-response hooks for SOURCE with RESPONSE."
  (dolist (fn hive-mcp-ai-post-response-hook)
    (funcall fn source response)))

(declare-function hive-mcp-channel-connected-p "hive-mcp-channel")

(declare-function hive-mcp-channel-send "hive-mcp-channel")

(defun hive-mcp-ai-bridge---channel-available-p ()
  "Check if channel is available for push events."
  (and (require 'hive-mcp-channel nil t) (fboundp 'hive-mcp-channel-connected-p) (hive-mcp-channel-connected-p)))

(defun hive-mcp-ai-bridge-ai-emit-event (event-type data)
  "Emit AI bridge EVENT-TYPE with DATA through channel.\nAll CIDER eval calls wrapped in condition-case for safety."
  (when (hive-mcp-ai-bridge--channel-available-p)
    (condition-case err
    (hive-mcp-channel-send (append (list (cons "type" (concat "ai-bridge:" event-type)) (cons "timestamp" (float-time))) data))
  (error (message "[ai-bridge] Channel emit error: %s" (error-message-string err))))))

(defun hive-mcp-ai-bridge-ai-bridge-status ()
  "Get AI bridge status."
  (list :memory-available (hive-mcp-ai-bridge--memory-available-p) :swarm-available (hive-mcp-ai-bridge--swarm-available-p) :channel-available (hive-mcp-ai-bridge--channel-available-p) :log-entries (length hive-mcp-ai--interaction-log) :settings (list :conventions-limit hive-mcp-ai-context-conventions-limit :decisions-limit hive-mcp-ai-context-decisions-limit :store-notable hive-mcp-ai-store-notable-responses)))

(provide 'hive-mcp-ai-bridge)

(provide 'hive-mcp-ai-bridge)
;;; hive-mcp-ai-bridge.el ends here
