;;; hive-mcp-transform.el --- -*- lexical-binding: t; -*-
;; Generated by ClojureElisp

(require 'clojure-elisp-runtime)

;;; Code:



(defun hive-mcp-transform--convert-value (val)
  "Convert VAL for JSON serialization.\nPlists become alists, lists become vectors, nil becomes []."
  (cond
  ((and (listp val) (keywordp (car-safe val))) (hive-mcp-transform-plist-to-alist val))
  ((and (listp val) val (listp (car-safe val)) (keywordp (car-safe (car-safe val)))) (apply #'vector (mapcar #'hive-mcp-transform-plist-to-alist val)))
  ((and (listp val) val) (apply #'vector (mapcar (lambda (v)
    (if (and (listp v) (keywordp (car-safe v))) (hive-mcp-transform-plist-to-alist v) v)) val)))
  ((null val) (list ))
  (t val)))

(defun hive-mcp-transform--extract-text (content)
  "Extract displayable text from CONTENT."
  (cond
  ((stringp content) content)
  ((and (listp content) (keywordp (car-safe content))) (or (plist-get content :description) (plist-get content :title) (plist-get content :name) (plist-get content :code) (format "%S" content)))
  (t (format "%S" content))))

(defun hive-mcp-transform-plist-to-alist (plist)
  "Convert PLIST to alist for JSON serialization.\nKeyword keys become symbols (colon stripped).\nLists become vectors (for JSON arrays).\nNested plists are recursively converted.\nNil values become empty vectors."
  (let* ((alist nil))
    (while plist
    (let* ((key (car plist))
        (val (cadr plist))
        (key-sym (if (keywordp key) (intern (substring (symbol-name key) 1)) key))
        (val-converted (hive-mcp-transform--convert-value val)))
    (push (cons key-sym val-converted) alist))
    (setq plist (cddr plist)))
    (nreverse alist)))

(defun hive-mcp-transform-entries-to-vector (entries)
  "Convert list of plist ENTRIES to vector of alists for JSON.\nEmpty list returns empty vector."
  (apply #'vector (mapcar #'hive-mcp-transform-plist-to-alist entries)))

(defun hive-mcp-transform-scope-arg (scope-filter)
  "Normalize SCOPE-FILTER string to domain format.\n- nil -> nil (auto-filter by project)\n- \"all\" -> t (no filter)\n- \"global\" -> 'global symbol\n- other -> pass through as-is"
  (cond
  ((null scope-filter) nil)
  ((string= scope-filter "all") t)
  ((string= scope-filter "global") 'global)
  (t scope-filter)))

(defun hive-mcp-transform-content-preview (content &optional max-len)
  "Return a preview of CONTENT truncated to MAX-LEN characters.\nMAX-LEN defaults to 100."
  (let* ((max-len (or max-len 100))
        (text (hive-mcp-transform--extract-text content)))
    (if (> (length text) max-len) (concat (substring text 0 (- max-len 3)) "...") text)))

(defun hive-mcp-transform-entry-to-metadata (entry)
  "Convert ENTRY plist to metadata-only alist.\nReturns: id, type, preview (truncated content), tags (as vector), created."
  (let* ((content (plist-get entry :content))
        (tags (plist-get entry :tags)))
    (list (cons 'id (plist-get entry :id)) (cons 'type (plist-get entry :type)) (cons 'preview (hive-mcp-transform-content-preview content)) (cons 'tags (if tags (apply #'vector tags) (list ))) (cons 'created (plist-get entry :created)))))

(defun hive-mcp-transform-bool-for-json (value)
  "Convert VALUE to JSON-compatible boolean.\nt stays t, nil becomes :false (for json-encode)."
  (if value t :false))

(defun hive-mcp-transform-error-result (error-key &rest extra-pairs)
  "Construct a JSON-serializable error alist.\nERROR-KEY is the error identifier string.\nEXTRA-PAIRS are additional key-value pairs."
  (let* ((result (list (cons 'error error-key))))
    (while extra-pairs
    (let* ((key (car extra-pairs))
        (val (cadr extra-pairs)))
    (push (cons key val) result))
    (setq extra-pairs (cddr extra-pairs)))
    (nreverse result)))

(defun hive-mcp-transform-stats-to-alist (stats-plist keys)
  "Convert STATS-PLIST to alist extracting KEYS.\nKEYS is a list of keyword symbols to extract."
  (mapcar (lambda (key)
    (cons (intern (substring (symbol-name key) 1)) (plist-get stats-plist key))) keys))

(defun hive-mcp-transform-position-to-alist (&optional point line column)
  "Construct position alist from POINT, LINE, COLUMN.\nReturns alist with available fields."
  (let* ((result nil))
    (when column
    (push (cons 'column column) result))
    (when line
    (push (cons 'line line) result))
    (when point
    (push (cons 'point point) result))
    result))

(defun hive-mcp-transform-duplicate-result (exists entry content-hash)
  "Construct duplicate check result alist."
  (list (cons 'exists (hive-mcp-transform-bool-for-json exists)) (cons 'entry (when entry
    (hive-mcp-transform-plist-to-alist entry))) (cons 'content_hash content-hash)))

(provide 'hive-mcp-transform)

(provide 'hive-mcp-transform)
;;; hive-mcp-transform.el ends here
