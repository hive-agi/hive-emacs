(ns hive-mcp.workflows
  "Workflow system for hive-mcp -- thin adapter over IWorkflowEngine.

   Provides user-defined multi-step automations with elisp, shell
   commands, prompts, and conditions. The core execution delegates
   to the Clojure-side IWorkflowEngine protocol; this layer handles
   the Emacs UI surface (interactive commands, persistence, hooks).

   Workflow spec:
     (:name \"string\"
      :description \"string\"
      :params ((:name \"param1\" :type string :default \"value\" :required t) ...)
      :steps (step1 step2 ...)
      :on-error :stop|:continue|:ask)

   Step types:
     (:type :elisp    :code \"(do-something)\")
     (:type :shell    :command \"npm test\" :var result)
     (:type :prompt   :message \"Continue?\" :var response)
     (:type :confirm  :message \"Are you sure?\")
     (:type :condition :test (lambda (env) ...) :then step :else step)
     (:type :memory-add :mem-type \"note\" :content \"...\")
     (:type :notify   :message \"Done!\" :level info|warning|error)

   Ported from hive-mcp/elisp/hive-mcp-workflows.el to cljel.")

(require 'hive-mcp-memory)

;; ============================================================================
;; Customization
;; ============================================================================

(defgroup hive-mcp-workflows nil
  "Workflow settings for hive-mcp."
  :group 'hive-mcp
  :prefix "hive-mcp-workflow-")

(defcustom hive-mcp-workflows-file
  (expand-file-name "workflows.el"
                    (expand-file-name "hive-mcp" user-emacs-directory))
  "File storing user workflow definitions."
  :type 'file
  :group 'hive-mcp-workflows)

;; ============================================================================
;; Registry
;; ============================================================================

(defvar hive-mcp-workflow-registry (make-hash-table :test 'equal)
  "Registry of user-defined workflows.
Each entry is NAME -> plist with :description :params :steps :on-error.")

(defvar hive-mcp-workflow-step-handlers (make-hash-table :test 'eq)
  "Handlers for custom workflow step types.
Each entry is TYPE -> function taking (step env) and returning env.")

(defvar hive-mcp-workflow-before-hook nil
  "Hook run before workflow execution.  Args: WORKFLOW-NAME ARGS.")

(defvar hive-mcp-workflow-after-hook nil
  "Hook run after workflow execution.  Args: WORKFLOW-NAME RESULT.")

;; ============================================================================
;; Core Operations
;; ============================================================================

(defn workflow-register [name spec]
  "Register workflow NAME with SPEC.
Thread-safe: overwrites existing entry atomically."
  (puthash name spec hive-mcp-workflow-registry)
  (hive-mcp-workflow--save)
  (message "Workflow '%s' registered" name))

(defn workflow-unregister [name]
  "Remove workflow NAME from registry."
  (remhash name hive-mcp-workflow-registry)
  (hive-mcp-workflow--save))

(defn workflow-get [name]
  "Get workflow spec by NAME."
  (gethash name hive-mcp-workflow-registry))

(defn workflow-list []
  "Return list of all workflows with metadata."
  (let [workflows nil]
    (maphash
      (lambda (name spec)
        (push (list :name name
                    :description (plist-get spec :description)
                    :params (plist-get spec :params))
              workflows))
      hive-mcp-workflow-registry)
    (nreverse workflows)))

;; ============================================================================
;; Execution
;; ============================================================================

(defn workflow-run [name & args]
  "Execute workflow NAME with optional ARGS plist.
Runs before/after hooks around execution."
  (if-let [spec (gethash name hive-mcp-workflow-registry)]
    (do
      (run-hook-with-args 'hive-mcp-workflow-before-hook name args)
      (let [result (hive-mcp-workflow--execute spec args)]
        (run-hook-with-args 'hive-mcp-workflow-after-hook name result)
        result))
    (error "Unknown workflow: %s" name)))

(defn- -execute [spec args]
  "Execute workflow SPEC with ARGS.
Supports two modes:
  1. :handler - direct function invocation with args plist
  2. :steps - step-by-step execution with env passing
State transitions are guarded: checks current step state before advancing."
  (let [handler (plist-get spec :handler)]
    ;; If workflow has a :handler, call it directly with args
    (if handler
      (condition-case err
        (funcall handler args)
        (error
          (list :success nil
                :error (error-message-string err))))
      ;; Otherwise execute step-by-step
      (let [steps (plist-get spec :steps)
            on-error (or (plist-get spec :on-error) :stop)
            env (hive-mcp-workflows--init-env spec args)
            step-num 0]
        (catch 'workflow-abort
          (dolist [step steps]
            (setq step-num (1+ step-num))
            (condition-case err
              (setq env (hive-mcp-workflows--run-step step env))
              (error
                (pcase on-error
                  (:stop
                    (throw 'workflow-abort
                           (list :success nil
                                 :error (error-message-string err)
                                 :failed-step step-num
                                 :env env)))
                  (:continue nil)
                  (:ask
                    (unless (yes-or-no-p
                              (format "Step %d failed: %s. Continue? "
                                      step-num (error-message-string err)))
                      (throw 'workflow-abort
                             (list :success nil
                                   :error "Aborted by user"
                                   :failed-step step-num
                                   :env env))))))))
          (list :success t :env env))))))

(defn- -init-env [spec args]
  "Initialize environment for workflow SPEC with ARGS.
Applies defaults and validates required params."
  (let [env (copy-sequence args)
        params (plist-get spec :params)]
    ;; Apply defaults for missing params
    (dolist [param params]
      (let [name (plist-get param :name)
            default (plist-get param :default)]
        (unless (plist-get env (intern (concat ":" name)))
          (when default
            (setq env (plist-put env (intern (concat ":" name)) default))))))
    ;; Check required params
    (dolist [param params]
      (when (plist-get param :required)
        (let [name (plist-get param :name)]
          (unless (plist-get env (intern (concat ":" name)))
            (error "Required parameter missing: %s" name)))))
    env))

(defn- -run-step [step env]
  "Run a single workflow STEP with ENV.  Return updated ENV.
Checks for custom handler first, then falls through to built-in types."
  (let [type (plist-get step :type)]
    ;; Check for custom handler first
    (if-let [handler (gethash type hive-mcp-workflow-step-handlers)]
      (funcall handler step env)
      ;; Built-in step types
      (pcase type
        (:elisp
          (hive-mcp-workflows--step-elisp step env))
        (:shell
          (hive-mcp-workflows--step-shell step env))
        (:prompt
          (hive-mcp-workflows--step-prompt step env))
        (:confirm
          (hive-mcp-workflows--step-confirm step env))
        (:condition
          (hive-mcp-workflows--step-condition step env))
        (:memory-add
          (hive-mcp-workflows--step-memory-add step env))
        (:notify
          (hive-mcp-workflows--step-notify step env))
        (_
          (error "Unknown step type: %s" type))))))

;; ============================================================================
;; Built-in Step Implementations
;; ============================================================================

(defn- -step-elisp [step env]
  "Execute elisp code from STEP with ENV bindings."
  (let [code (plist-get step :code)
        result (eval (read code) t)]
    (if-let [var (plist-get step :var)]
      (plist-put env var result)
      env)))

(defn- -step-shell [step env]
  "Execute shell command from STEP with ENV variable substitution."
  (let [cmd-template (plist-get step :command)
        cmd (hive-mcp-workflows--substitute-vars cmd-template env)
        result (string-trim (shell-command-to-string cmd))]
    (if-let [var (plist-get step :var)]
      (plist-put env var result)
      env)))

(defn- -step-prompt [step env]
  "Prompt user for input using message from STEP, store result in ENV."
  (let [msg (plist-get step :message)
        default (plist-get step :default)
        result (read-string (concat msg ": ") default)]
    (plist-put env (plist-get step :var) result)))

(defn- -step-confirm [step env]
  "Ask user for confirmation using message from STEP.
Returns ENV if confirmed, otherwise signals error."
  (unless (yes-or-no-p (plist-get step :message))
    (error "User cancelled"))
  env)

(defn- -step-condition [step env]
  "Execute conditional branch from STEP based on test result in ENV."
  (let [test-fn (plist-get step :test)]
    (if (funcall test-fn env)
      (when-let [then-step (plist-get step :then)]
        (hive-mcp-workflows--run-step then-step env))
      (when-let [else-step (plist-get step :else)]
        (hive-mcp-workflows--run-step else-step env)))))

(defn- -step-memory-add [step env]
  "Add memory entry from STEP, substituting variables from ENV."
  (let [type (plist-get step :mem-type)
        content (hive-mcp-workflows--substitute-vars
                  (plist-get step :content) env)
        tags (plist-get step :tags)]
    (hive-mcp-memory-add (intern type) content tags))
  env)

(defn- -step-notify [step env]
  "Show notification from STEP message, substituting variables from ENV."
  (let [msg (hive-mcp-workflows--substitute-vars
              (plist-get step :message) env)
        level (or (plist-get step :level) 'info)]
    (pcase level
      ('error (user-error "%s" msg))
      ('warning (display-warning 'hive-mcp msg :warning))
      (_ (message "[MCP] %s" msg))))
  env)

;; ============================================================================
;; Utility Functions
;; ============================================================================

(defn- -substitute-vars [template env]
  "Substitute ${var} in TEMPLATE with values from ENV."
  (if (stringp template)
    (replace-regexp-in-string
      "\\${\\([^}]+\\)}"
      (lambda (match)
        (let [var-name (match-string 1 match)
              var-key (intern (concat ":" var-name))
              value (plist-get env var-key)]
          (if value (format "%s" value) match)))
      template)
    template))

;; ============================================================================
;; Custom Step Type Registration
;; ============================================================================

(defn workflow-register-step-type [type handler]
  "Register workflow step TYPE with HANDLER function.
HANDLER receives (step env) and should return updated env."
  (puthash type handler hive-mcp-workflow-step-handlers))

;; ============================================================================
;; Persistence
;; ============================================================================

(defn- -save []
  "Save workflows to file."
  (make-directory (file-name-directory hive-mcp-workflows-file) t)
  (with-temp-file hive-mcp-workflows-file
    (let [workflows nil]
      (maphash (lambda (k v) (push (cons k v) workflows))
               hive-mcp-workflow-registry)
      (insert ";;; hive-mcp workflows - auto-generated\n")
      (insert ";;; Do not edit manually\n\n")
      (insert "(setq hive-mcp-workflow--saved-data\n  '")
      (prin1 workflows (current-buffer))
      (insert ")\n"))))

(defn- -load []
  "Load workflows from file."
  (when (file-exists-p hive-mcp-workflows-file)
    (load hive-mcp-workflows-file t t)
    (when (boundp 'hive-mcp-workflow--saved-data)
      (dolist [wf hive-mcp-workflow--saved-data]
        (puthash (car wf) (cdr wf) hive-mcp-workflow-registry)))))

;; ============================================================================
;; Interactive Commands
;; ============================================================================

(defn workflow-run-interactive []
  "Interactively run a workflow."
  (interactive)
  (let [workflows (hive-mcp-workflows-workflow-list)
        names (mapcar (lambda (wf) (plist-get wf :name)) workflows)
        name (completing-read "Workflow: " names nil t)]
    (let [result (hive-mcp-workflows-workflow-run name)]
      (if (plist-get result :success)
        (message "Workflow completed successfully")
        (message "Workflow failed: %s" (plist-get result :error))))))

;; ============================================================================
;; Memory-Integrated Workflows
;; ============================================================================

(defn- wrap--get-date []
  "Return current date in YYYY-MM-DD format."
  (format-time-string "%Y-%m-%d"))

(defn- wrap--make-tags [base-tags]
  "Create tags list with BASE-TAGS plus auto-injected project scope."
  (hive-mcp-memory--inject-project-scope base-tags))

(defn- wrap--git-status []
  "Get git status summary for wrap workflow."
  (let [branch (string-trim
                 (shell-command-to-string
                   "git rev-parse --abbrev-ref HEAD 2>/dev/null || echo 'none'"))
        status (shell-command-to-string "git status --porcelain 2>/dev/null")
        unmerged (string-trim
                   (shell-command-to-string
                     "git branch --no-merged main 2>/dev/null | grep -E '^\\s*(feature|fix|feat)/' | head -10 || true"))]
    (list :branch branch
          :has-uncommitted (not (string-empty-p status))
          :unmerged-feature-branches
          (when (not (string-empty-p unmerged))
            (split-string unmerged "\n" t "\\s-*")))))

(defn- wrap--store-accomplishments [accomplishments]
  "Store ACCOMPLISHMENTS as session-summary note with short-term duration.
Returns the stored entry."
  (when accomplishments
    (let [tags (hive-mcp-workflows--wrap--make-tags
                 '("session-summary" "wrap"))
          date (hive-mcp-workflows--wrap--get-date)
          content (format "## Session Summary: %s\n\n### Completed\n%s"
                          date
                          (mapconcat (lambda (a) (format "- [x] %s" a))
                                     accomplishments "\n"))]
      (hive-mcp-memory-add 'note content tags nil 'short-term))))

(defn- wrap--store-decisions [decisions]
  "Store DECISIONS as decision entries with long-term duration.
Returns list of stored entries."
  (when decisions
    (mapcar
      (lambda (decision)
        (let [tags (hive-mcp-workflows--wrap--make-tags '("wrap" "session-decision"))
              date (hive-mcp-workflows--wrap--get-date)
              content (list :title decision
                            :rationale "Session decision"
                            :date date)]
          (hive-mcp-memory-add 'decision content tags nil 'long-term)))
      decisions)))

(defn- wrap--store-conventions [conventions]
  "Store CONVENTIONS as convention entries with permanent duration.
Returns list of stored entries."
  (when conventions
    (mapcar
      (lambda (convention)
        (let [tags (hive-mcp-workflows--wrap--make-tags '("wrap"))
              date (hive-mcp-workflows--wrap--get-date)
              content (list :description convention
                            :date date)]
          (hive-mcp-memory-add 'convention content tags nil 'permanent)))
      conventions)))

(defn- wrap--sync-kanban [completed-task-ids]
  "Move COMPLETED-TASK-IDS to done status in kanban.
Returns count of successfully moved tasks."
  (when (and completed-task-ids (fboundp 'hive-mcp-kanban-task-move))
    (let [moved 0]
      (dolist [task-id completed-task-ids]
        (condition-case nil
          (do
            (hive-mcp-kanban-task-move task-id "done")
            (setq moved (1+ moved)))
          (error nil)))
      moved)))

(defn- wrap--get-kanban-status []
  "Get kanban stats if available."
  (when (fboundp 'hive-mcp-kanban-stats)
    (condition-case nil
      (hive-mcp-kanban-stats)
      (error nil))))

(defn- wrap--gather-recent-notes [& directory]
  "Get memory entries (notes/snippets) created today.
DIRECTORY specifies the project directory for scoping queries."
  (let [today (format-time-string "%Y-%m-%d")
        project-id (when directory (hive-mcp-memory-project-id directory))
        notes (ignore-errors (hive-mcp-memory-query 'note nil project-id 20))
        snippets (ignore-errors (hive-mcp-memory-query 'snippet nil project-id 20))]
    (seq-filter
      (lambda (entry)
        (when-let [created (plist-get entry :created)]
          (string-prefix-p today created)))
      (append (when (listp notes) notes)
              (when (listp snippets) snippets)))))

(defn- wrap--gather-git-commits [& directory]
  "Get commits on current branch from today.
DIRECTORY overrides `default-directory' if provided."
  (let [default-directory (or directory default-directory)]
    (let [output (shell-command-to-string
                   "git log --since='midnight' --oneline 2>/dev/null")]
      (when (and output (not (string-empty-p output)))
        (split-string output "\n" t)))))

(defn- wrap--gather-kanban-activity [& directory]
  "Get in-progress and review kanban tasks.
DIRECTORY specifies the project directory for scoping queries."
  (when (fboundp 'hive-mcp-kanban-list-tasks)
    (condition-case nil
      (let [project-id (when directory (hive-mcp-memory-project-id directory))]
        (list :in-progress (hive-mcp-kanban-list-tasks project-id "inprogress")
              :review (hive-mcp-kanban-list-tasks project-id "inreview")))
      (error nil))))

(defn- wrap--gather-channel-events []
  "Get recent channel events if channel is active."
  (when (and (fboundp 'hive-mcp-channel-get-recent-events)
             (fboundp 'hive-mcp-channel-connected-p)
             (hive-mcp-channel-connected-p))
    (condition-case nil
      (hive-mcp-channel-get-recent-events 10)
      (error nil))))

(defn- wrap--gather-session-data [& directory]
  "Auto-gather session data from all available sources.
DIRECTORY specifies the project directory for git operations and project scoping.
Returns plist with :recent-notes, :recent-commits,
:kanban-activity, :ai-interactions."
  (list :recent-notes (hive-mcp-workflows--wrap--gather-recent-notes directory)
        :recent-commits (hive-mcp-workflows--wrap--gather-git-commits directory)
        :kanban-activity (hive-mcp-workflows--wrap--gather-kanban-activity directory)
        :ai-interactions (hive-mcp-workflows--wrap--gather-channel-events)))

(defn- wrap--merge-args [gathered provided]
  "Merge GATHERED data with user-PROVIDED args.
PROVIDED takes precedence. Converts gathered data to wrap args format."
  (let [result (copy-sequence provided)]
    ;; If no accomplishments provided, derive from gathered notes
    (unless (plist-get result :accomplishments)
      (when-let [notes (plist-get gathered :recent-notes)]
        (plist-put result :accomplishments
                   (mapcar (lambda (n)
                             (let [content (plist-get n :content)]
                               (if (> (length content) 100)
                                 (concat (substring content 0 97) "...")
                                 content)))
                           (seq-take notes 5)))))
    ;; Add git commits as context
    (when-let [commits (plist-get gathered :recent-commits)]
      (unless (plist-get result :git-commits)
        (plist-put result :git-commits commits)))
    result))

(defn- wrap--emit-via-channel [args project-name]
  "Emit wrap-request event via channel for unified Clojure handling.
ARGS is the wrap arguments plist, PROJECT-NAME is the current project.
Returns t if successfully sent, nil otherwise."
  (when (and (fboundp 'hive-mcp-channel-connected-p)
             (fboundp 'hive-mcp-channel-send)
             (hive-mcp-channel-connected-p))
    (let [event (list (cons "type" "wrap-request")
                      (cons "accomplishments" (vconcat (plist-get args :accomplishments)))
                      (cons "decisions" (vconcat (plist-get args :decisions)))
                      (cons "conventions" (vconcat (plist-get args :conventions)))
                      (cons "in-progress" (vconcat (plist-get args :in-progress)))
                      (cons "next-actions" (vconcat (plist-get args :next-actions)))
                      (cons "completed-tasks" (vconcat (plist-get args :completed-tasks)))
                      (cons "project" project-name)
                      (cons "timestamp" (float-time)))]
      (hive-mcp-channel-send event))))

(defn- wrap--store-locally [args]
  "Store wrap data locally (offline fallback path).
ARGS is the wrap arguments plist.
Returns list of stored item symbols."
  (let [accomplishments (plist-get args :accomplishments)
        decisions (plist-get args :decisions)
        conventions (plist-get args :conventions)
        in-progress (plist-get args :in-progress)
        next-actions (plist-get args :next-actions)
        date (hive-mcp-workflows--wrap--get-date)
        stored nil]
    ;; Store accomplishments
    (when accomplishments
      (hive-mcp-workflows--wrap--store-accomplishments accomplishments)
      (push 'accomplishments stored))
    ;; Store decisions
    (when decisions
      (hive-mcp-workflows--wrap--store-decisions decisions)
      (push 'decisions stored))
    ;; Store conventions
    (when conventions
      (hive-mcp-workflows--wrap--store-conventions conventions)
      (push 'conventions stored))
    ;; Create full session summary note
    (when (or accomplishments decisions in-progress next-actions)
      (let [tags (hive-mcp-workflows--wrap--make-tags
                   '("session-summary" "wrap" "full-summary"))
            content (format "## Session Summary: %s\n\n### Completed\n%s\n\n### Decisions Made\n%s\n\n### In Progress\n%s\n\n### Next Actions\n%s"
                            date
                            (if accomplishments
                              (mapconcat (lambda (a) (format "- [x] %s" a))
                                         accomplishments "\n")
                              "- (none)")
                            (if decisions
                              (mapconcat (lambda (d) (format "- %s" d))
                                         decisions "\n")
                              "- (none)")
                            (if in-progress
                              (mapconcat (lambda (ip) (format "- [ ] %s" ip))
                                         in-progress "\n")
                              "- (none)")
                            (if next-actions
                              (mapconcat (lambda (na) (format "- %s" na))
                                         next-actions "\n")
                              "- (none)"))]
        (hive-mcp-memory-add 'note content tags nil 'short-term)
        (push 'session-summary stored)))
    (nreverse stored)))

(defn workflow-wrap [& args]
  "Execute wrap workflow with ARGS plist.

ARGS can contain:
  :accomplishments - list of completed tasks (stored as note, short-term)
  :decisions - list of decisions made (stored as decision, long-term)
  :conventions - list of conventions (stored as convention, permanent)
  :in-progress - list of in-progress items (for summary)
  :next-actions - list of next session priorities (for summary)
  :completed-tasks - list of kanban task IDs to mark done

Option A: If channel connected, emits wrap-request to Clojure.
Offline fallback: stores locally.

Returns structured result plist."
  (interactive)
  (let [project-name (hive-mcp-memory--get-project-name)
        date (hive-mcp-workflows--wrap--get-date)
        git-info (hive-mcp-workflows--wrap--git-status)
        kanban-before (hive-mcp-workflows--wrap--get-kanban-status)
        completed-tasks (plist-get args :completed-tasks)
        expired-count 0
        stored nil
        path nil]

    ;; 1. Cleanup expired memory entries first
    (setq expired-count (hive-mcp-memory-cleanup-expired))

    ;; 2. Try unified path via channel (Option A)
    (if (hive-mcp-workflows--wrap--emit-via-channel args project-name)
      (do
        (setq path 'channel)
        (setq stored '(channel-emitted)))
      ;; 3. Offline fallback - store locally
      (do
        (setq path 'local)
        (setq stored (hive-mcp-workflows--wrap--store-locally args))))

    ;; 4. Sync kanban - move completed tasks to done (always local)
    (when completed-tasks
      (let [moved-count (hive-mcp-workflows--wrap--sync-kanban completed-tasks)]
        (when (> moved-count 0)
          (push 'kanban-synced stored))))

    ;; 5. Get final kanban status
    (let [kanban-after (hive-mcp-workflows--wrap--get-kanban-status)]

      ;; Return result
      (list :success t
            :date date
            :project (or project-name "global")
            :path path
            :stored (if (eq path 'channel)
                      stored
                      (nreverse stored))
            :counts (list :accomplishments (length (plist-get args :accomplishments))
                          :decisions (length (plist-get args :decisions))
                          :conventions (length (plist-get args :conventions))
                          :tasks-completed (length completed-tasks))
            :expired-cleaned expired-count
            :git git-info
            :kanban (list :before kanban-before
                          :after kanban-after)
            :summary (format "Session wrapped for %s via %s. Stored: %s. Cleaned %d expired entries."
                             (or project-name "global")
                             path
                             (mapconcat #'symbol-name stored ", ")
                             expired-count)))))

(defn- catchup--entry-to-meta [entry & preview-len]
  "Convert ENTRY to metadata-only format as alist for proper JSON serialization.
Returns alist with id, type, preview (PREVIEW-LEN chars, default 80), tags."
  (let [content (plist-get entry :content)
        preview-length (or preview-len 80)
        ;; Handle both string and structured content
        content-str (if (stringp content)
                     content
                     (format "%s" content))
        entry-type (plist-get entry :type)
        type-str (if (symbolp entry-type)
                   (symbol-name entry-type)
                   (format "%s" entry-type))]
    (list (cons "id" (plist-get entry :id))
          (cons "type" type-str)
          (cons "preview" (truncate-string-to-width content-str preview-length))
          (cons "tags" (vconcat (plist-get entry :tags))))))

(defn workflow-catchup [& _args]
  "Execute optimized catchup workflow - restore context from memory.
Returns metadata-only format (~1.5k tokens vs ~10k for full content).
Use `mcp_memory_get_full` to fetch specific entries by ID when needed.
ARGS is unused but accepted for workflow handler compatibility."
  (interactive)
  (let [project-name (hive-mcp-memory--get-project-name)
        applicable-scopes (hive-mcp-memory--applicable-scope-tags)
        ;; Query raw data
        session-notes-raw (hive-mcp-memory-query 'note '("session-summary") nil 3 nil nil)
        decisions-raw (hive-mcp-memory-query 'decision nil nil 10 nil nil)
        conventions-raw (hive-mcp-memory-query 'convention nil nil 10 nil nil)
        snippets-raw (hive-mcp-memory-query 'snippet nil nil 5 nil nil)
        expiring-raw (seq-take (hive-mcp-memory-query-expiring 7) 5)
        ;; Convert to metadata-only format (vconcat for JSON array serialization)
        session-meta (vconcat (mapcar #'hive-mcp-workflows--catchup--entry-to-meta session-notes-raw))
        decisions-meta (vconcat (mapcar #'hive-mcp-workflows--catchup--entry-to-meta decisions-raw))
        conventions-meta (vconcat (mapcar #'hive-mcp-workflows--catchup--entry-to-meta conventions-raw))
        snippets-meta (vconcat (mapcar (lambda (e) (hive-mcp-workflows--catchup--entry-to-meta e 60)) snippets-raw))
        expiring-meta (vconcat (mapcar #'hive-mcp-workflows--catchup--entry-to-meta expiring-raw))
        ;; Git info
        git-branch (string-trim
                     (shell-command-to-string "git rev-parse --abbrev-ref HEAD 2>/dev/null || echo 'none'"))
        uncommitted (not (string-empty-p
                           (shell-command-to-string "git status --porcelain 2>/dev/null")))
        last-commit (string-trim
                      (shell-command-to-string "git log -1 --format='%h - %s' 2>/dev/null || echo 'none'"))]

    (list :success t
          :project project-name
          :scopes applicable-scopes
          :git (list :branch git-branch
                     :uncommitted uncommitted
                     :last-commit last-commit)
          :counts (list :sessions (length session-meta)
                        :decisions (length decisions-meta)
                        :conventions (length conventions-meta)
                        :snippets (length snippets-meta)
                        :expiring (length expiring-meta))
          :context (list :sessions session-meta
                         :decisions decisions-meta
                         :conventions conventions-meta
                         :snippets snippets-meta
                         :expiring expiring-meta)
          :hint "Use mcp_memory_get_full with ID to fetch full content")))

;; ============================================================================
;; Built-in Example Workflows
;; ============================================================================

(defn- -register-builtins []
  "Register built-in example workflows.
Idempotent: only registers if not already present."
  ;; Quick note workflow
  (unless (gethash "quick-note" hive-mcp-workflow-registry)
    (puthash "quick-note"
             '(:name "quick-note"
               :description "Add a quick note with current context"
               :steps ((:type :prompt
                        :message "Note"
                        :var :note-text)
                       (:type :memory-add
                        :mem-type "note"
                        :content "${note-text}")
                       (:type :notify
                        :message "Note saved!")))
             hive-mcp-workflow-registry))

  ;; Git commit workflow
  (unless (gethash "commit" hive-mcp-workflow-registry)
    (puthash "commit"
             '(:name "commit"
               :description "Stage all and commit with message"
               :params ((:name "message" :required t))
               :steps ((:type :shell
                        :command "git add -A")
                       (:type :shell
                        :command "git commit -m \"${message}\"")
                       (:type :notify
                        :message "Committed: ${message}")))
             hive-mcp-workflow-registry))

  ;; Wrap workflow (memory-integrated)
  (unless (gethash "wrap" hive-mcp-workflow-registry)
    (puthash "wrap"
             '(:name "wrap"
               :description "End-of-session wrap-up (Memory-Integrated)"
               :params ((:name "accomplishments" :type list :required nil
                         :description "List of completed tasks")
                        (:name "decisions" :type list :required nil
                         :description "List of decisions made")
                        (:name "conventions" :type list :required nil
                         :description "List of conventions to store permanently")
                        (:name "in-progress" :type list :required nil
                         :description "List of in-progress items")
                        (:name "next-actions" :type list :required nil
                         :description "List of next session priorities")
                        (:name "completed-tasks" :type list :required nil
                         :description "Kanban task IDs to mark done"))
               :handler hive-mcp-workflows-workflow-wrap)
             hive-mcp-workflow-registry))

  ;; Catchup workflow (memory-integrated)
  (unless (gethash "catchup" hive-mcp-workflow-registry)
    (puthash "catchup"
             '(:name "catchup"
               :description "Catch Up (Memory-Integrated)"
               :handler hive-mcp-workflows-workflow-catchup)
             hive-mcp-workflow-registry)))

;; Auto-register builtins on load
(hive-mcp-workflows--register-builtins)

(provide 'hive-mcp-workflows)
