;;; hive-mcp-org-ai.el --- -*- lexical-binding: t; -*-
;; Generated by ClojureElisp

(require 'clojure-elisp-runtime)
(require 'hive-mcp-api)

;;; Code:



(declare-function org-ai-prompt "org-ai")

(declare-function org-ai-on-region "org-ai")

(declare-function org-ai-switch-chat-model "org-ai")

(declare-function org-ai-stream-text "org-ai")

(defgroup hive-mcp-org-ai nil
  "Integration between org-ai and hive-mcp."
  :group 'org-ai
  :prefix "hive-mcp-org-ai-")

(defcustom hive-mcp-org-ai-auto-context nil
  "When non-nil, automatically include MCP context in org-ai prompts.\nContext includes buffer info, project details, git status, and relevant memory."
  :group 'hive-mcp-org-ai
  :type 'boolean)

(defcustom hive-mcp-org-ai-log-conversations t
  "When non-nil, save org-ai conversations to hive-mcp memory.\nThis enables persistent conversation history per project."
  :group 'hive-mcp-org-ai
  :type 'boolean)

(defcustom hive-mcp-org-ai-context-format 'smart
  "Format for context injection.\n- `compact': Single line summary\n- `full': Complete context JSON\n- `smart': Include only relevant sections"
  :group 'hive-mcp-org-ai
  :type '(choice (const :tag "Compact summary" compact) (const :tag "Full JSON context" full) (const :tag "Smart selection" smart)))

(defcustom hive-mcp-org-ai-include-memory t
  "When non-nil, include relevant memory entries in context."
  :group 'hive-mcp-org-ai
  :type 'boolean)

(defvar hive-mcp-org-ai--available nil)

(defvar hive-mcp-org-ai--last-conversation nil)

(defun hive-mcp-org-ai---available-p ()
  "Check if hive-mcp-api is available."
  (or hive-mcp-org-ai--available (setq hive-mcp-org-ai--available (featurep 'hive-mcp-api))))

(defun hive-mcp-org-ai---ensure-available ()
  "Ensure hive-mcp is available, error if not."
  (unless (-available-p)
    (if (require 'hive-mcp-api nil t) (setq hive-mcp-org-ai--available t) (error "Emacs-mcp-api not available.  Load hive-mcp first"))))

(defun hive-mcp-org-ai---format-context-compact (ctx)
  "Format CTX as compact one-line summary."
  (let* ((buffer (plist-get ctx :buffer))
        (project (plist-get ctx :project))
        (git (plist-get ctx :git)))
    (format "[%s @ %s%s]" (or (plist-get buffer :name) "unknown") (or (plist-get project :name) "no-project") (if (plist-get git :dirty) " (modified)" ""))))

(defun hive-mcp-org-ai---format-context-smart (ctx)
  "Format CTX with only relevant sections for org-ai."
  (let* ((parts '())
        (buffer (plist-get ctx :buffer))
        (region (plist-get ctx :region))
        (defun-ctx (plist-get ctx :defun))
        (project (plist-get ctx :project))
        (git (plist-get ctx :git))
        (memory (plist-get ctx :memory)))
    (when buffer
    (push (format "File: %s (line %d)" (or (plist-get buffer :file) (plist-get buffer :name)) (or (plist-get buffer :line) 1)) parts))
    (when defun-ctx
    (push (format "Context: %s" (plist-get defun-ctx :name)) parts))
    (when region
    (let* ((text (plist-get region :text)))
    (when (and text (< (length text) 200))
    (push (format "Selection: %s" text) parts))))
    (when project
    (let* ((name (plist-get project :name))
        (root (plist-get project :root)))
    (when name
    (push (format "Project: %s" name) parts))
    (when root
    (push (format "Root: %s" root) parts))))
    (when (and git (plist-get git :dirty))
    (let* ((modified (plist-get git :modified))
        (branch (plist-get git :branch)))
    (when branch
    (push (format "Branch: %s" branch) parts))
    (when modified
    (push (format "Modified: %s" (mapconcat #'identity (seq-take modified 3) ", ")) parts))))
    (when (and hive-mcp-org-ai-include-memory memory)
    (let* ((notes (plist-get memory :notes))
        (snippets (plist-get memory :snippets)))
    (when (and notes (> (length notes) 0))
    (push (format "Recent notes: %d available" (length notes)) parts))
    (when (and snippets (> (length snippets) 0))
    (push (format "Code snippets: %d available" (length snippets)) parts))))
    (if parts (clel-concat "# Project Context\n" (mapconcat (lambda (p)
    (clel-concat "- " p)) (nreverse parts) "\n")) "")))

(defun hive-mcp-org-ai---get-context-string ()
  "Get context string based on `hive-mcp-org-ai-context-format'."
  (when (-available-p)
    (let* ((ctx (hive-mcp-api-get-context)))
    (pcase hive-mcp-org-ai-context-format
  ((quote compact) (hive-mcp-claude-code--format-context-compact ctx))
  ((quote full) (format "```json\n%s\n```" (json-encode ctx)))
  ((quote smart) (-format-context-smart ctx))))))

(defun hive-mcp-org-ai-insert-context ()
  "Insert MCP context at point in org-ai block."
  (interactive)
  (-ensure-available)
  (let* ((ctx (-get-context-string)))
    (when ctx
    (insert "\n" ctx "\n\n")
    (message "Inserted MCP context"))))

(defun hive-mcp-org-ai-save-conversation ()
  "Save the current org-ai conversation to project memory."
  (interactive)
  (-ensure-available)
  (let* ((conversation (if (use-region-p) (buffer-substring-no-properties (region-beginning) (region-end)) (buffer-substring-no-properties (point-min) (point-max))))
        (tags (split-string (clel-read-string "Tags (comma-separated): " "org-ai,conversation") "," t " "))
        (summary (clel-read-string "Summary (optional): " nil)))
    (let* ((content (if (and summary (not (string-empty-p summary))) (format "Summary: %s\n\n%s" summary conversation) conversation)))
    (hive-mcp-api-memory-add "conversation" content tags)
    (message "Saved conversation to memory"))))

(defun hive-mcp-org-ai-query-conversations ()
  "Query previous org-ai conversations from memory."
  (interactive)
  (-ensure-available)
  (let* ((query (clel-read-string "Search for: " nil))
        (results (hive-mcp-api-memory-query "conversation" '("org-ai") 10))
        (buf (get-buffer-create "*MCP Org-AI Conversations*")))
    (with-current-buffer buf
    (erase-buffer)
    (org-mode)
    (insert "#+TITLE: Org-AI Conversation History\n\n")
    (if (equal (length results) 0) (insert "No conversations found.\n") (cl-dotimes (i (length results))
    (let* ((entry (aref results i))
        (content (alist-get 'content entry))
        (created (alist-get 'created entry))
        (tags (alist-get 'tags entry)))
    (insert (format "* Conversation %d\n" (1+ i)))
    (insert (format ":PROPERTIES:\n"))
    (insert (format ":CREATED: %s\n" created))
    (when (and tags (> (length tags) 0))
    (insert (format ":TAGS: %s\n" (mapconcat #'identity tags ", "))))
    (insert ":END:\n\n")
    (insert content)
    (insert "\n\n"))))
    (goto-char (point-min)))
    (display-buffer buf)))

(defun hive-mcp-org-ai-save-to-memory ()
  "Save selected text or region to hive-mcp memory."
  (interactive)
  (-ensure-available)
  (let* ((text (if (use-region-p) (buffer-substring-no-properties (region-beginning) (region-end)) (clel-read-string "Content: ")))
        (type (completing-read "Type: " '("note" "snippet" "decision" "convention") nil t))
        (tags (split-string (clel-read-string "Tags (comma-separated): " "org-ai") "," t " ")))
    (hive-mcp-api-memory-add type text tags)
    (message "Saved to memory as %s" type)))

(defun hive-mcp-org-ai-query-memory ()
  "Query hive-mcp memory and insert results."
  (interactive)
  (-ensure-available)
  (let* ((type (completing-read "Query type: " '("note" "snippet" "decision" "convention") nil t "note"))
        (results (hive-mcp-api-memory-query type nil 5)))
    (if (equal (length results) 0) (message "No %s entries found" type) (let* ((buf (get-buffer-create "*MCP Memory Results*")))
    (with-current-buffer buf
    (erase-buffer)
    (org-mode)
    (insert (format "#+TITLE: Memory: %s\n\n" type))
    (cl-dotimes (i (length results))
    (let* ((entry (aref results i))
        (content (alist-get 'content entry))
        (tags (alist-get 'tags entry)))
    (insert (format "* Entry %d\n" (1+ i)))
    (when (and tags (> (length tags) 0))
    (insert (format "Tags: %s\n\n" (mapconcat #'identity tags ", "))))
    (insert content)
    (insert "\n\n")))
    (goto-char (point-min)))
    (display-buffer buf)))))

(defun hive-mcp-org-ai-run-workflow ()
  "Select and run an hive-mcp workflow."
  (interactive)
  (-ensure-available)
  (let* ((workflows (hive-mcp-api-list-workflows))
        (names (mapcar (lambda (w)
    (alist-get 'name w)) workflows))
        (selected (completing-read "Run workflow: " names nil t)))
    (hive-mcp-api-run-workflow selected)
    (message "Workflow '%s' executed" selected)))

(defun hive-mcp-org-ai-show-context ()
  "Show current hive-mcp context in a buffer."
  (interactive)
  (-ensure-available)
  (let* ((ctx (hive-mcp-api-get-context))
        (formatted (-format-context-smart ctx))
        (buf (get-buffer-create "*MCP Context*")))
    (with-current-buffer buf
    (erase-buffer)
    (org-mode)
    (insert "#+TITLE: Current MCP Context\n\n")
    (insert formatted)
    (insert "\n\n* Full JSON\n\n")
    (insert "#+BEGIN_SRC json\n")
    (insert (json-encode ctx))
    (insert "\n#+END_SRC\n")
    (goto-char (point-min)))
    (display-buffer buf)))

(transient-define-prefix hive-mcp-org-ai-transient (nil) "MCP integration menu for org-ai." (list "hive-mcp + org-ai" (list "Context" ("c" "Show context" hive-mcp-org-ai-show-context) ("i" "Insert context" hive-mcp-org-ai-insert-context)) (list "Memory" ("s" "Save conversation" hive-mcp-org-ai-save-conversation) ("m" "Save to memory" hive-mcp-org-ai-save-to-memory) ("q" "Query memory" hive-mcp-org-ai-query-memory) ("h" "Query conversations" hive-mcp-org-ai-query-conversations)) (list "Workflows" ("w" "Run workflow" hive-mcp-org-ai-run-workflow)) (list "Settings" ("C" "Toggle auto-context" hive-mcp-org-ai-toggle-auto-context) ("L" "Toggle logging" hive-mcp-org-ai-toggle-logging) ("M" "Toggle memory inclusion" hive-mcp-org-ai-toggle-memory))))

(defun hive-mcp-org-ai-toggle-auto-context ()
  "Toggle automatic context injection."
  (interactive)
  (setq hive-mcp-org-ai-auto-context (not hive-mcp-org-ai-auto-context))
  (message "Auto-context %s" (if hive-mcp-org-ai-auto-context "enabled" "disabled")))

(defun hive-mcp-org-ai-toggle-logging ()
  "Toggle conversation logging."
  (interactive)
  (setq hive-mcp-org-ai-log-conversations (not hive-mcp-org-ai-log-conversations))
  (message "Conversation logging %s" (if hive-mcp-org-ai-log-conversations "enabled" "disabled")))

(defun hive-mcp-org-ai-toggle-memory ()
  "Toggle memory inclusion in context."
  (interactive)
  (setq hive-mcp-org-ai-include-memory (not hive-mcp-org-ai-include-memory))
  (message "Memory inclusion %s" (if hive-mcp-org-ai-include-memory "enabled" "disabled")))

(defun hive-mcp-org-ai---maybe-add-context (text)
  "Maybe add context to TEXT if auto-context is enabled."
  (if (and hive-mcp-org-ai-auto-context (-available-p)) (let* ((ctx (-get-context-string)))
    (if (and ctx (not (string-empty-p ctx))) (format "%s\n\n%s" ctx text) text)) text))

(defun hive-mcp-org-ai---log-conversation (prompt response)
  "Log PROMPT and RESPONSE to conversation memory if logging is enabled."
  (when (and hive-mcp-org-ai-log-conversations (-available-p))
    (ignore-errors (let* ((content (format "** User\n%s\n\n** Assistant\n%s" prompt response)))
    (setq hive-mcp-org-ai--last-conversation content)
    (hive-mcp-api-conversation-log "org-ai" content)))))

(defvar hive-mcp-org-ai-block-map (let* ((map (make-sparse-keymap)))
    (define-key map (kbd "C-c C-c m") 'hive-mcp-org-ai-insert-context)
    (define-key map (kbd "C-c C-c s") 'hive-mcp-org-ai-save-conversation)
    (define-key map (kbd "C-c C-c q") 'hive-mcp-org-ai-query-memory)
    (define-key map (kbd "C-c C-c h") 'hive-mcp-org-ai-query-conversations)
    (define-key map (kbd "C-c C-c w") 'hive-mcp-org-ai-run-workflow)
    (define-key map (kbd "C-c C-c M") 'hive-mcp-org-ai-transient)
    map)
  "Keymap for org-ai blocks with MCP integration.")

(define-minor-mode hive-mcp-org-ai-mode
  "Minor mode for hive-mcp integration with org-ai.\n\nWhen enabled, provides:\n- Context injection for AI prompts\n- Memory persistence integration\n- Conversation history\n- Workflow access\n\nKey bindings in org-ai blocks (see `hive-mcp-org-ai-block-map'):\n  \\[hive-mcp-org-ai-insert-context] - Insert context\n  \\[hive-mcp-org-ai-save-conversation] - Save conversation\n  \\[hive-mcp-org-ai-query-memory] - Query memory\n  \\[hive-mcp-org-ai-transient] - Open transient menu\n\nRequires `org-ai' package to be installed."
  :init-value nil
  :lighter " MCP-AI"
  :global t
  :group 'hive-mcp-org-ai
  (if hive-mcp-org-ai-mode (if (not (featurep 'org-ai)) (progn
  (setq hive-mcp-org-ai-mode nil)
  (message "hive-mcp-org-ai: org-ai not available, addon disabled")) (require 'hive-mcp-api nil t)) (message "Emacs-mcp-org-ai disabled")))

(with-eval-after-load 'hive-mcp-addons
  (hive-mcp-addon-register 'org-ai :version "0.1.0" :description "Integration with org-ai (AI chat in org-mode)" :requires '(org-ai hive-mcp-api) :provides '(hive-mcp-org-ai-mode hive-mcp-org-ai-transient)))

(provide 'hive-mcp-org-ai)
;;; hive-mcp-org-ai.el ends here
