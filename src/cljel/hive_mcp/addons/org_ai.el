;;; hive-mcp-org-ai.el --- -*- lexical-binding: t; -*-
;; Generated by ClojureElisp

(require 'clojure-elisp-runtime)
(require 'hive-mcp-api)

;;; Code:



(declare-function org-ai-prompt "org-ai")

(declare-function org-ai-on-region "org-ai")

(declare-function org-ai-switch-chat-model "org-ai")

(declare-function org-ai-stream-text "org-ai")

(defgroup hive-mcp-org-ai nil
  "Integration between org-ai and hive-mcp."
  :group 'org-ai
  :prefix "hive-mcp-org-ai-")

(defcustom hive-mcp-org-ai-auto-context nil
  "When non-nil, automatically include MCP context in org-ai prompts.\nContext includes buffer info, project details, git status, and relevant memory."
  :group 'hive-mcp-org-ai
  :type 'boolean)

(defcustom hive-mcp-org-ai-log-conversations t
  "When non-nil, save org-ai conversations to hive-mcp memory.\nThis enables persistent conversation history per project."
  :group 'hive-mcp-org-ai
  :type 'boolean)

(defcustom hive-mcp-org-ai-context-format 'smart
  "Format for context injection.\n- `compact': Single line summary\n- `full': Complete context JSON\n- `smart': Include only relevant sections"
  :group 'hive-mcp-org-ai
  :type '(choice (const :tag "Compact summary" compact) (const :tag "Full JSON context" full) (const :tag "Smart selection" smart)))

(defcustom hive-mcp-org-ai-include-memory t
  "When non-nil, include relevant memory entries in context."
  :group 'hive-mcp-org-ai
  :type 'boolean)

(defvar hive-mcp-org-ai--available nil)

(defvar hive-mcp-org-ai--last-conversation nil)

(defun hive-mcp-org-ai---available-p ()
  "Check if hive-mcp-api is available."
  (or hive-mcp-org-ai--available (setq hive-mcp-org-ai--available (featurep 'hive-mcp-api))))

(defun hive-mcp-org-ai---ensure-available ()
  "Ensure hive-mcp is available, error if not."
  (unless (-available-p)
    (if (require 'hive-mcp-api nil t) (setq hive-mcp-org-ai--available t) (error "Emacs-mcp-api not available.  Load hive-mcp first"))))

(defun hive-mcp-org-ai---format-context-compact (ctx)
  "Format CTX as compact one-line summary."
  (let* ((buffer (plist-get ctx :buffer))
        (project (plist-get ctx :project))
        (git (plist-get ctx :git)))
    (format "[%s @ %s%s]" (or (plist-get buffer :name) "unknown") (or (plist-get project :name) "no-project") (if (plist-get git :dirty) " (modified)" ""))))

(defun hive-mcp-org-ai---format-context-smart (ctx)
  "Format CTX with only relevant sections for org-ai."
  (let* ((parts '())
        (buffer (plist-get ctx :buffer))
        (region (plist-get ctx :region))
        (defun-ctx (plist-get ctx :defun))
        (project (plist-get ctx :project))
        (git (plist-get ctx :git))
        (memory (plist-get ctx :memory)))
    (when buffer
    (push (format "File: %s (line %d)" (or (plist-get buffer :file) (plist-get buffer :name)) (or (plist-get buffer :line) 1)) parts))
    (when defun-ctx
    (push (format "Context: %s" (plist-get defun-ctx :name)) parts))
    (when region
    (let* ((text (plist-get region :text)))
    (when (and text (< (length text) 200))
    (push (format "Selection: %s" text) parts))))
    (when project
    (let* ((name (plist-get project :name))
        (root (plist-get project :root)))
    (when name
    (push (format "Project: %s" name) parts))
    (when root
    (push (format "Root: %s" root) parts))))
    (when (and git (plist-get git :dirty))
    (let* ((modified (plist-get git :modified))
        (branch (plist-get git :branch)))
    (when branch
    (push (format "Branch: %s" branch) parts))
    (when modified
    (push (format "Modified: %s" (mapconcat #'identity (seq-take modified 3) ", ")) parts))))
    (when (and hive-mcp-org-ai-include-memory memory)
    (let* ((notes (plist-get memory :notes))
        (snippets (plist-get memory :snippets)))
    (when (and notes (> (length notes) 0))
    (push (format "Recent notes: %d available" (length notes)) parts))
    (when (and snippets (> (length snippets) 0))
    (push (format "Code snippets: %d available" (length snippets)) parts))))
    (if parts (clel-concat "# Project Context\n" (mapconcat (lambda (p)
    (clel-concat "- " p)) (nreverse parts) "\n")) "")))

(defun hive-mcp-org-ai---get-context-string ()
  "Get context string based on `hive-mcp-org-ai-context-format'."
  (when (-available-p)
    (let* ((ctx (hive-mcp-api-get-context)))
    (pcase hive-mcp-org-ai-context-format
  ((quote compact) (hive-mcp-claude-code--format-context-compact ctx))
  ((quote full) (format "```json\n%s\n```" (json-encode ctx)))
  ((quote smart) (-format-context-smart ctx))))))

(defun hive-mcp-org-ai-insert-context ()
  "Insert MCP context at point in org-ai block."
  (interactive)
  (-ensure-available)
  (let* ((ctx (-get-context-string)))
    (when ctx
    (insert "\n" ctx "\n\n")
    (message "Inserted MCP context"))))

(defun hive-mcp-org-ai-save-conversation ()
  "Save the current org-ai conversation to project memory."
  (interactive)
  (-ensure-available)
  (let* ((conversation (if (use-region-p) (buffer-substring-no-properties (region-beginning) (region-end)) (buffer-substring-no-properties (point-min) (point-max))))
        (tags (split-string (clel-read-string "Tags (comma-separated): " "org-ai,conversation") "," t " "))
        (summary (clel-read-string "Summary (optional): " nil)))
    (let* ((content (if (and summary (not (string-empty-p summary))) (format "Summary: %s\n\n%s" summary conversation) conversation)))
    (hive-mcp-api-memory-add "conversation" content tags)
    (message "Saved conversation to memory"))))

(provide 'hive-mcp-org-ai)
;;; hive-mcp-org-ai.el ends here
