;;; hive-mcp-cci.el --- -*- lexical-binding: t; -*-
;; Generated by ClojureElisp

(require 'clojure-elisp-runtime)
(require 'cl-lib)
(require 'json)
(require 'subr-x)

;;; Code:



(declare-function claude-code-ide "claude-code-ide")

(declare-function claude-code-ide--start-session "claude-code-ide")

(declare-function claude-code-ide-send-prompt "claude-code-ide")

(declare-function claude-code-ide-stop "claude-code-ide")

(declare-function hive-mcp-swarm--build-system-prompt "hive-mcp-swarm")

(declare-function hive-mcp-hivemind-status "hive-mcp-hivemind")

(declare-function hive-mcp-hivemind-agent-messages "hive-mcp-hivemind")

(declare-function hive-mcp-channel-connected-p "hive-mcp-channel")

(declare-function hive-mcp-channel-send "hive-mcp-channel")

(defgroup hive-mcp-cci nil
  "Swarm orchestration via claude-code-ide."
  :group 'hive-mcp
  :prefix "hive-mcp-cci-")

(defcustom hive-mcp-cci-default-timeout 300000
  "Default task timeout in milliseconds (5 minutes)."
  :group 'hive-mcp-cci
  :type 'integer)

(defcustom hive-mcp-cci-max-lings 10
  "Maximum number of concurrent lings."
  :group 'hive-mcp-cci
  :type 'integer)

(defcustom hive-mcp-cci-hivemind-poll-interval 5
  "Interval in seconds for polling hivemind for task completions."
  :group 'hive-mcp-cci
  :type 'integer)

(defcustom hive-mcp-cci-auto-sync t
  "If non-nil, automatically sync task status from hivemind."
  :group 'hive-mcp-cci
  :type 'boolean)

(defvar hive-mcp-cci--lings (make-hash-table :test 'equal)
  "Hash table of ling-id -> ling plist.")

(defvar hive-mcp-cci--tasks (make-hash-table :test 'equal)
  "Hash table of task-id -> task plist.")

(defvar hive-mcp-cci--pending-completions (make-hash-table :test 'equal)
  "Hash table of task-id -> completion callback.")

(defvar hive-mcp-cci--task-counter 0
  "Counter for generating unique task IDs.")

(defvar hive-mcp-cci--sync-timer nil)

(defun hive-mcp-cci---generate-ling-id (name)
  "Generate unique ling ID for NAME."
  (format "ling-%s-%d" name (random 999999999)))

(defun hive-mcp-cci---generate-task-id (ling-id)
  "Generate unique task ID for LING-ID."
  (cl-incf hive-mcp-cci--task-counter)
  (format "task-%s-%03d" (replace-regexp-in-string "^ling-" "" ling-id) hive-mcp-cci--task-counter))

(defun hive-mcp-cci---get-hivemind-status ()
  "Get hivemind status, handling both elisp and MCP responses."
  (condition-case nil
    (when (fboundp 'hive-mcp-hivemind-status) (hive-mcp-hivemind-status))
  (error nil)))

(defun hive-mcp-cci-sync-from-hivemind ()
  "Sync task completion status from hivemind coordinator.\nUpdates local task records based on hivemind agent messages."
  (interactive)
  (condition-case err
    (let* ((hivemind-status (-get-hivemind-status))
        (updated 0))
    (when hivemind-status
    (maphash (lambda (task-id task)
    (when (eq (plist-get task :status) 'dispatched)
    (let* ((ling-id (plist-get task :ling-id))
        (agent-id (plist-get (gethash ling-id hive-mcp-cci--lings) :hivemind-agent))
        (agents (alist-get 'agents hivemind-status))
        (agent-data (when (and agent-id agents)
    (alist-get (intern agent-id) agents))))
    (when agent-data
    (let* ((agent-status (alist-get 'status agent-data))
        (messages (alist-get 'messages agent-data)))
    (when (and (equal agent-status "completed") messages)
    (dolist (msg messages)
    (let* ((event-type (alist-get 'event-type msg))
        (msg-task (alist-get 'task msg))
        (data (alist-get 'data msg)))
    (when (and (equal event-type "completed") (or (equal msg-task task-id) (equal (alist-get 'task_id data) task-id)))
    (-handle-hivemind-completion task-id (or (alist-get 'status data) "success") (or (alist-get 'result data) (alist-get 'message msg)) (alist-get 'files_modified data))
    (cl-incf updated)))))))))) hive-mcp-cci--tasks))
    (when (and (called-interactively-p 'any) (> updated 0))
    (message "[cci] Synced %d task completions from hivemind" updated))
    updated)
  (error (message "[cci] Hivemind sync error: %s" (error-message-string err))
      0)))

(defun hive-mcp-cci---handle-hivemind-completion (task-id status result files)
  "Handle completion of TASK-ID with STATUS, RESULT, and FILES from hivemind."
  (when-let-star (list task (gethash task-id hive-mcp-cci--tasks)) (plist-put task :status (intern (or status "success"))) (plist-put task :result result) (plist-put task :files-modified files) (plist-put task :completed-at (format-time-string "%FT%T%z")) (when-let-star (list ling-id (plist-get task :ling-id) ling (gethash ling-id hive-mcp-cci--lings)) (plist-put ling :status 'idle) (plist-put ling :current-task nil) (cl-incf (plist-get ling :tasks-completed))) (when-let-star (list callback (gethash task-id hive-mcp-cci--pending-completions)) (remhash task-id hive-mcp-cci--pending-completions) (funcall callback task)) (-emit-event "task-completed" (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list "task-id") (clojure-core-list '.) (clojure-core-list 'user/task-id)))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list "status") (clojure-core-list '.) (clojure-core-list 'user/status)))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list "ling-id") (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'user/plist-get) (clojure-core-list 'user/task) (clojure-core-list :ling-id)))))))))) (message "[cci] Task %s completed via hivemind: %s" task-id status)))

(defun hive-mcp-cci---start-sync-timer ()
  "Start the automatic hivemind sync timer."
  (when (and hive-mcp-cci-auto-sync (not hive-mcp-cci--sync-timer))
    (setq hive-mcp-cci--sync-timer (run-with-timer hive-mcp-cci-hivemind-poll-interval hive-mcp-cci-hivemind-poll-interval #'hive-mcp-cci-sync-from-hivemind))))

(defun hive-mcp-cci---stop-sync-timer ()
  "Stop the automatic hivemind sync timer."
  (when hive-mcp-cci--sync-timer
    (cancel-timer hive-mcp-cci--sync-timer)
    (setq hive-mcp-cci--sync-timer nil)))

(defun hive-mcp-cci---emit-event (event-type data)
  "Emit EVENT-TYPE with DATA via channel if connected."
  (when (and (fboundp 'hive-mcp-channel-connected-p) (hive-mcp-channel-connected-p))
    (ignore-errors (hive-mcp-channel-send (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list "type") (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/format) (clojure-core-list "cci-%s") (clojure-core-list 'user/event-type))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list "data") (clojure-core-list '.) (clojure-core-list 'user/data)))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list "timestamp") (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'user/format-time-string) (clojure-core-list "%FT%T%z")))))))))))))

(cl-defun hive-mcp-cci-spawn (name &key presets cwd hivemind-agent)
  "Spawn a new ling with NAME using claude-code-ide.\n\nPRESETS is a list of preset names (uses hive-mcp-swarm presets).\nCWD is the working directory.\nHIVEMIND-AGENT is the agent ID to use for hivemind tracking (defaults to NAME).\n\nReturns ling-id immediately.  Session starts async."
  (interactive (list (clel-read-string "Ling name: ")))
  (unless (featurep 'claude-code-ide)
    (error "claude-code-ide not available"))
  (when (>= (hash-table-count hive-mcp-cci--lings) hive-mcp-cci-max-lings)
    (error "Maximum ling count (%d) reached" hive-mcp-cci-max-lings))
  (let* ((ling-id (-generate-ling-id symbol-name))
        (work-dir (or cwd (when (fboundp 'project-root)
    (when-let-star (list proj (project-current)) (project-root proj))) default-directory))
        (agent-id (or hivemind-agent symbol-name))
        (system-prompt (when (and presets (featurep 'hive-mcp-swarm))
    (hive-mcp-swarm--build-system-prompt presets))))
    (puthash ling-id (list :ling-id ling-id :name symbol-name :presets presets :hivemind-agent agent-id :status 'starting :cwd work-dir :session nil :current-task nil :tasks-completed 0 :spawned-at (format-time-string "%FT%T%z")) hive-mcp-cci--lings)
    (run-with-timer 0 nil (lambda (_unused)
    (condition-case err
    (let* ((default-directory work-dir))
    (claude-code-ide)
    (run-with-timer 2 nil (lambda (_unused)
    (condition-case err
    (when-let-star (list ling (gethash ling-id hive-mcp-cci--lings)) (when system-prompt
    (claude-code-ide-send-prompt system-prompt)) (plist-put ling :status 'idle) (message "[cci] Ling %s ready (hivemind: %s)" ling-id agent-id))
  (error (message "[cci] Timer error initializing ling %s: %s" ling-id (error-message-string err)))))))
  (error (when-let-star (list ling (gethash ling-id hive-mcp-cci--lings)) (plist-put ling :status 'error) (plist-put ling :error (error-message-string err)))
      (message "[cci] Spawn error: %s" (error-message-string err))))))
    (message "[cci] Spawning ling %s..." ling-id)
    ling-id))

(defun hive-mcp-cci-kill (ling-id)
  "Kill ling LING-ID."
  (interactive (list (completing-read "Kill ling: " (hash-table-keys hive-mcp-cci--lings))))
  (when-let-star (list ling (gethash ling-id hive-mcp-cci--lings)) (let* ((cwd (plist-get ling :cwd)))
    (when cwd
    (let* ((default-directory cwd))
    (ignore-errors (claude-code-ide-stop))))) (remhash ling-id hive-mcp-cci--lings) (message "[cci] Killed ling: %s" ling-id)))

(defun hive-mcp-cci-kill-all ()
  "Kill all lings."
  (interactive)
  (maphash (lambda (id _unused)
    (kill id)) hive-mcp-cci--lings)
  (clrhash hive-mcp-cci--lings)
  (message "[cci] Killed all lings"))

(cl-defun hive-mcp-cci-dispatch (ling-id prompt &key timeout callback)
  "Dispatch PROMPT to LING-ID.\n\nTIMEOUT is milliseconds (default `hive-mcp-cci-default-timeout').\nCALLBACK is called with task plist when complete (via hivemind sync).\n\nReturns task-id.\n\nThe ling should call hivemind_shout with event_type=completed when done.\nUse `hive-mcp-cci-sync-from-hivemind' to poll for completion, or rely\non automatic sync if `hive-mcp-cci-auto-sync' is enabled."
  (let* ((ling (gethash ling-id hive-mcp-cci--lings))
        (task-id (-generate-task-id ling-id))
        (agent-id (plist-get ling :hivemind-agent)))
    (unless ling
    (error "Ling not found: %s" ling-id))
    (unless (eq (plist-get ling :status) 'idle)
    (error "Ling %s is busy (status: %s)" ling-id (plist-get ling :status)))
    (puthash task-id (list :task-id task-id :ling-id ling-id :prompt prompt :status 'dispatched :timeout (or timeout hive-mcp-cci-default-timeout) :dispatched-at (format-time-string "%FT%T%z") :completed-at nil :result nil) hive-mcp-cci--tasks)
    (when callback
    (puthash task-id callback hive-mcp-cci--pending-completions))
    (plist-put ling :status 'working)
    (plist-put ling :current-task task-id)
    (let* ((cwd (plist-get ling :cwd))
        (task-prompt (format "## Task ID: %s\n\n%s\n\n---\n**IMPORTANT - Completion Reporting:**\nWhen you complete this task, use `hivemind_shout` to report:\n```\nhivemind_shout(\n  agent_id: \"%s\",\n  event_type: \"completed\",\n  task: \"%s\",\n  message: \"<brief summary>\",\n  data: {\n    \"task_id\": \"%s\",\n    \"status\": \"success\" | \"error\" | \"partial\",\n    \"result\": \"<your findings/output>\",\n    \"files_modified\": [\"<list of changed files>\"]\n  }\n)\n```" task-id prompt agent-id task-id task-id)))
    (let* ((default-directory (or cwd default-directory)))
    (claude-code-ide-send-prompt task-prompt)))
    (message "[cci] Dispatched task %s to %s" task-id ling-id)
    task-id))

(defun hive-mcp-cci-status ()
  "Get swarm status."
  (interactive)
  (let* ((total 0)
        (idle 0)
        (working 0)
        (error-count 0)
        (lings-detail '()))
    (maphash (lambda (id ling)
    (cl-incf total)
    (pcase (plist-get ling :status)
  ((quote idle) (cl-incf idle))
  ((quote working) (cl-incf working))
  ((quote error) (cl-incf error-count)))
    (push (list :id id :name (plist-get ling :name) :hivemind-agent (plist-get ling :hivemind-agent) :status (plist-get ling :status) :current-task (plist-get ling :current-task) :tasks-completed (plist-get ling :tasks-completed)) lings-detail)) hive-mcp-cci--lings)
    (let* ((status (clel-seq (clel-concat (clojure-core-list :backend) (clojure-core-list "claude-code-ide") (clojure-core-list :completion-mechanism) (clojure-core-list "hivemind") (clojure-core-list :auto-sync) (clojure-core-list 'user/hive-mcp-cci-auto-sync) (clojure-core-list :lings) (clojure-core-list (clel-seq (clel-concat (clojure-core-list :total) (clojure-core-list 'user/total) (clojure-core-list :idle) (clojure-core-list 'user/idle) (clojure-core-list :working) (clojure-core-list 'user/working) (clojure-core-list :error) (clojure-core-list 'user/error-count)))) (clojure-core-list :tasks) (clojure-core-list (clel-seq (clel-concat (clojure-core-list :total) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'user/hash-table-count) (clojure-core-list 'user/hive-mcp-cci--tasks)))) (clojure-core-list :pending) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'user/hash-table-count) (clojure-core-list 'user/hive-mcp-cci--pending-completions))))))) (clojure-core-list :lings-detail) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'user/nreverse) (clojure-core-list 'user/lings-detail))))))))
    (when (called-interactively-p 'any)
    (message "CCI Swarm: %d lings (%d idle, %d working), %d tasks, completion: hivemind" total idle working (hash-table-count hive-mcp-cci--tasks)))
    status)))

(defun hive-mcp-cci-api-spawn (name presets &optional cwd)
  "API: Spawn ling NAME with PRESETS in CWD."
  (condition-case err
    (hive-mcp-cci-spawn name :presets presets :cwd cwd)
  (error (clel-seq (clel-concat (clojure-core-list :error) (clojure-core-list "spawn-failed") (clojure-core-list :reason) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'user/error-message-string) (clojure-core-list 'user/err)))))))))

(defun hive-mcp-cci-api-dispatch (ling-id prompt &optional timeout-ms)
  "API: Dispatch PROMPT to LING-ID with TIMEOUT-MS."
  (condition-case err
    (hive-mcp-cci-dispatch ling-id prompt :timeout timeout-ms)
  (error (clel-seq (clel-concat (clojure-core-list :error) (clojure-core-list "dispatch-failed") (clojure-core-list :reason) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'user/error-message-string) (clojure-core-list 'user/err)))))))))

(defun hive-mcp-cci-api-status ()
  "API: Get status."
  (status))

(defun hive-mcp-cci-api-collect (task-id)
  "API: Get task TASK-ID result."
  (if-let-star (list task (gethash task-id hive-mcp-cci--tasks)) task (clel-seq (clel-concat (clojure-core-list :error) (clojure-core-list "task-not-found") (clojure-core-list :task-id) (clojure-core-list 'user/task-id)))))

(defun hive-mcp-cci-api-sync ()
  "API: Sync task status from hivemind."
  (sync-from-hivemind))

(define-minor-mode hive-mcp-cci-mode
  "Minor mode for swarm orchestration via claude-code-ide.\n\nProvides structured communication with ling Claude instances\nusing hivemind for task completion tracking.\n\nKey features:\n- Spawn lings via claude-code-ide (not raw vterm)\n- Dispatch tasks with structured prompts\n- Completion tracking via hivemind_shout\n- Automatic sync from hivemind coordinator"
  :init-value nil
  :lighter " CCI"
  :global t
  :group 'hive-mcp-cci
  (if hive-mcp-cci-mode (progn
  (unless (require 'claude-code-ide nil t)
    (setq hive-mcp-cci-mode nil)
    (error "claude-code-ide not available"))
  (-start-sync-timer)
  (message "hive-mcp-cci enabled (hivemind completion)")) (-stop-sync-timer)))

(defalias 'hive-mcp-cci-claude-code-ide-mode 'hive-mcp-cci-mode "Backwards compatibility alias for `hive-mcp-cci-mode'.")

(when (fboundp 'hive-mcp-addon-register)
    (hive-mcp-addon-register 'cci :version "0.1.0" :description "Swarm orchestration via claude-code-ide.el with hivemind completion" :requires '() :provides '(hive-mcp-cci-mode)))

(provide 'hive-mcp-cci)
;;; hive-mcp-cci.el ends here
