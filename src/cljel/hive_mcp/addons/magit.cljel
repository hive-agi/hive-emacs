(ns hive-mcp-magit
  "Magit integration for hive-mcp.

Features:
- Enhanced repository status (beyond basic git context)
- Branch operations (list, create, checkout)
- Staging and commits (non-interactive for MCP use)
- Diff and log viewing
- Remote operations (fetch, pull, push)

When Magit is not installed, falls back to shell git commands."
  (:require [hive-mcp-api :as api]))

;; ============================================================================
;; Forward Declarations
;; ============================================================================

;; Magit
(declare-function magit-toplevel "magit-git")
(declare-function magit-get-current-branch "magit-git")
(declare-function magit-get-upstream-branch "magit-git")
(declare-function magit-list-local-branch-names "magit-git")
(declare-function magit-list-remote-branch-names "magit-git")
(declare-function magit-stage-modified "magit-apply")
(declare-function magit-unstage-all "magit-apply")
(declare-function magit-refresh "magit-mode")
(declare-function magit-status "magit-status")

;; Addons / Transient
(declare-function hive-mcp-addon-register "hive-mcp-addons")
(declare-function transient-define-prefix "transient")

;; ============================================================================
;; Customization
;; ============================================================================

(defgroup hive-mcp-magit nil
  "Magit integration for hive-mcp."
  :group 'hive-mcp
  :group 'magit
  :prefix "hive-mcp-magit-")

(defcustom hive-mcp-magit-log-count 10
  "Default number of commits to show in log operations."
  :type 'integer
  :group 'hive-mcp-magit)

(defcustom hive-mcp-magit-diff-context-lines 3
  "Number of context lines to show in diffs."
  :type 'integer
  :group 'hive-mcp-magit)

(defcustom hive-mcp-magit-prefer-magit t
  "When non-nil, prefer Magit functions over shell commands."
  :type 'boolean
  :group 'hive-mcp-magit)

;; ============================================================================
;; Internal State
;; ============================================================================

(defvar hive-mcp-magit--last-operation nil
  "Last git operation performed.")

;; ============================================================================
;; Internal Helpers
;; ============================================================================

(defn- -magit-available-p []
  "Return non-nil if Magit is available and preferred."
  (and hive-mcp-magit-prefer-magit
       (featurep 'magit)
       (fboundp 'magit-toplevel)))

(defn- -repo-root []
  "Return the git repository root directory."
  (if (-magit-available-p)
      (magit-toplevel)
    (let [root (locate-dominating-file default-directory ".git")]
      (when root (expand-file-name root)))))

(defn- -ensure-repo []
  "Ensure we are in a git repository."
  (unless (-repo-root)
    (error "Not in a git repository")))

(defn- -shell-command [cmd]
  "Execute git CMD and return trimmed output."
  (let [default-directory (or (-repo-root) default-directory)]
    (string-trim (shell-command-to-string cmd))))

(defn- -shell-lines [cmd]
  "Execute git CMD and return list of output lines."
  (let [output (-shell-command cmd)]
    (unless (string-empty-p output)
      (split-string output "\n" t))))

;; ============================================================================
;; Status Functions
;; ============================================================================

(defn- -get-staged-files []
  "Return list of staged files."
  (-shell-lines "git diff --cached --name-only 2>/dev/null"))

(defn- -get-unstaged-files []
  "Return list of unstaged modified files."
  (-shell-lines "git diff --name-only 2>/dev/null"))

(defn- -get-untracked-files []
  "Return list of untracked files."
  (-shell-lines "git ls-files --others --exclude-standard 2>/dev/null"))

(defn- -get-current-branch []
  "Return current branch name."
  (if (-magit-available-p)
      (magit-get-current-branch)
    (-shell-command "git rev-parse --abbrev-ref HEAD 2>/dev/null")))

(defn- -get-upstream-branch []
  "Return upstream tracking branch."
  (if (-magit-available-p)
      (magit-get-upstream-branch)
    (let [result (-shell-command
                   "git rev-parse --abbrev-ref @{upstream} 2>/dev/null")]
      (unless (string-empty-p result) result))))

(defn- -get-stash-list []
  "Return list of stashes."
  (-shell-lines "git stash list --oneline 2>/dev/null"))

(defn- -get-recent-commits [&optional count]
  "Return last COUNT commits as list of plists."
  (let* [n (or count hive-mcp-magit-log-count)
         format-str "%H%x00%h%x00%an%x00%ae%x00%s%x00%ai"
         lines (-shell-lines
                 (format "git log -n%d --format='%s' 2>/dev/null" n format-str))]
    (mapcar (lambda (line)
              (let [parts (split-string line "\x00")]
                (list :hash (nth 0 parts)
                      :short-hash (nth 1 parts)
                      :author (nth 2 parts)
                      :email (nth 3 parts)
                      :subject (nth 4 parts)
                      :date (nth 5 parts))))
            lines)))

(defn- -get-ahead-behind []
  "Return commits ahead/behind upstream as plist."
  (let [result (-shell-command
                 "git rev-list --left-right --count @{upstream}...HEAD 2>/dev/null")]
    (if (string-empty-p result)
        (list :ahead 0 :behind 0)
      (let [parts (split-string result)]
        (list :behind (string-to-number (or (nth 0 parts) "0"))
              :ahead (string-to-number (or (nth 1 parts) "0")))))))

;; ============================================================================
;; Branch Functions
;; ============================================================================

(defn- -list-local-branches []
  "Return list of local branch names."
  (if (-magit-available-p)
      (magit-list-local-branch-names)
    (-shell-lines "git branch --format='%(refname:short)' 2>/dev/null")))

(defn- -list-remote-branches []
  "Return list of remote branch names."
  (if (-magit-available-p)
      (magit-list-remote-branch-names)
    (-shell-lines "git branch -r --format='%(refname:short)' 2>/dev/null")))

(defn- -create-branch [name &optional start-point]
  "Create branch NAME at START-POINT."
  (-ensure-repo)
  (let [start (or start-point "HEAD")]
    (-shell-command
      (format "git branch %s %s 2>&1"
              (shell-quote-argument name)
              (shell-quote-argument start)))))

(defn- -checkout-branch [name]
  "Checkout branch NAME."
  (-ensure-repo)
  (-shell-command
    (format "git checkout %s 2>&1" (shell-quote-argument name))))

;; ============================================================================
;; Staging Functions
;; ============================================================================

(defn- -stage-file [file]
  "Stage FILE for commit."
  (-ensure-repo)
  (let [result (-shell-command
                 (format "git add %s 2>&1" (shell-quote-argument file)))]
    (when (-magit-available-p)
      (magit-refresh))
    result))

(defn- -stage-all []
  "Stage all modified files."
  (-ensure-repo)
  (if (-magit-available-p)
      (magit-stage-modified t)
    (-shell-command "git add -u 2>&1")))

(defn- -unstage-file [file]
  "Unstage FILE."
  (-ensure-repo)
  (let [result (-shell-command
                 (format "git reset HEAD %s 2>&1" (shell-quote-argument file)))]
    (when (-magit-available-p)
      (magit-refresh))
    result))

(defn- -unstage-all []
  "Unstage all staged files."
  (-ensure-repo)
  (if (-magit-available-p)
      (magit-unstage-all)
    (-shell-command "git reset HEAD 2>&1")))

;; ============================================================================
;; Commit Functions
;; ============================================================================

(defn- -commit [message]
  "Create commit with MESSAGE."
  (-ensure-repo)
  (let [staged (-get-staged-files)]
    (unless staged
      (error "No staged changes to commit"))
    (let [result (-shell-command
                   (format "git commit -m %s 2>&1"
                           (shell-quote-argument message)))]
      (when (-magit-available-p)
        (magit-refresh))
      result)))

(defn- -commit-all [message]
  "Stage all changes and commit with MESSAGE."
  (-ensure-repo)
  (let [result (-shell-command
                 (format "git commit -am %s 2>&1"
                         (shell-quote-argument message)))]
    (when (-magit-available-p)
      (magit-refresh))
    result))

;; ============================================================================
;; Diff Functions
;; ============================================================================

(defn- -diff-staged []
  "Get diff of staged changes."
  (-ensure-repo)
  (-shell-command
    (format "git diff --cached -U%d 2>/dev/null"
            hive-mcp-magit-diff-context-lines)))

(defn- -diff-unstaged []
  "Get diff of unstaged changes."
  (-ensure-repo)
  (-shell-command
    (format "git diff -U%d 2>/dev/null"
            hive-mcp-magit-diff-context-lines)))

;; ============================================================================
;; Remote Functions
;; ============================================================================

(defn- -fetch [&optional remote]
  "Fetch from REMOTE (default: all remotes)."
  (-ensure-repo)
  (let [result (if remote
                   (-shell-command
                     (format "git fetch %s 2>&1" (shell-quote-argument remote)))
                 (-shell-command "git fetch --all 2>&1"))]
    (when (-magit-available-p)
      (magit-refresh))
    result))

(defn- -pull []
  "Pull from upstream."
  (-ensure-repo)
  (let [result (-shell-command "git pull 2>&1")]
    (when (-magit-available-p)
      (magit-refresh))
    result))

(defn- -push [&optional set-upstream]
  "Push to remote.  SET-UPSTREAM to set tracking if needed."
  (-ensure-repo)
  (let* [branch (-get-current-branch)
         upstream (-get-upstream-branch)
         cmd (if (or upstream (not set-upstream))
                 "git push 2>&1"
               (format "git push -u origin %s 2>&1"
                       (shell-quote-argument branch)))
         result (-shell-command cmd)]
    (when (-magit-available-p)
      (magit-refresh))
    result))

;; ============================================================================
;; MCP API Functions (public)
;; ============================================================================

(defn api-status [&optional directory]
  "Return comprehensive repository status as plist.
DIRECTORY overrides `default-directory' if provided."
  (let [default-directory (or directory default-directory)]
    (-ensure-repo)
    (let [branch (-get-current-branch)
          upstream (-get-upstream-branch)
          ahead-behind (-get-ahead-behind)]
      (list :repository (-repo-root)
            :branch branch
            :upstream upstream
            :ahead (plist-get ahead-behind :ahead)
            :behind (plist-get ahead-behind :behind)
            :staged (-get-staged-files)
            :staged-count (length (-get-staged-files))
            :unstaged (-get-unstaged-files)
            :unstaged-count (length (-get-unstaged-files))
            :untracked (-get-untracked-files)
            :untracked-count (length (-get-untracked-files))
            :stashes (-get-stash-list)
            :recent-commits (-get-recent-commits 5)
            :clean (and (null (-get-staged-files))
                        (null (-get-unstaged-files))
                        (null (-get-untracked-files)))
            :magit-available (-magit-available-p)))))

(defn api-branches [&optional directory]
  "Return branch information as plist.
DIRECTORY overrides `default-directory' if provided."
  (let [default-directory (or directory default-directory)]
    (-ensure-repo)
    (list :current (-get-current-branch)
          :upstream (-get-upstream-branch)
          :local (-list-local-branches)
          :remote (-list-remote-branches))))

(defn api-log [&optional count directory]
  "Return recent COUNT commits.
DIRECTORY overrides `default-directory' if provided."
  (let [default-directory (or directory default-directory)]
    (-ensure-repo)
    (-get-recent-commits count)))

(defn api-diff [&optional target directory]
  "Return diff for TARGET (staged, unstaged, or all).
DIRECTORY overrides `default-directory' if provided."
  (let [default-directory (or directory default-directory)]
    (-ensure-repo)
    (pcase target
      ((or 'nil 'staged) (-diff-staged))
      ('unstaged (-diff-unstaged))
      ('all (concat (-diff-staged)
                    "\n---\n"
                    (-diff-unstaged)))
      (_ (-diff-staged)))))

(defn api-stage [files &optional directory]
  "Stage FILES for commit.
DIRECTORY overrides `default-directory' if provided."
  (let [default-directory (or directory default-directory)]
    (-ensure-repo)
    (elisp-cond
      ((eq files 'all) (-stage-all))
      ((stringp files) (-stage-file files))
      ((listp files) (dolist (f files) (-stage-file f))))))

(defn api-commit [message &optional options directory]
  "Create commit with MESSAGE.
OPTIONS may contain :all to stage all changes first.
DIRECTORY overrides `default-directory' if provided."
  (let [default-directory (or directory default-directory)]
    (-ensure-repo)
    (if (plist-get options :all)
        (-commit-all message)
      (-commit message))))

(defn api-push [&optional options directory]
  "Push to remote.
OPTIONS may contain :set-upstream to set tracking.
DIRECTORY overrides `default-directory' if provided."
  (let [default-directory (or directory default-directory)]
    (-ensure-repo)
    (-push (plist-get options :set-upstream))))

(defn api-pull [&optional directory]
  "Pull from upstream.
DIRECTORY overrides `default-directory' if provided."
  (let [default-directory (or directory default-directory)]
    (-ensure-repo)
    (-pull)))

(defn api-fetch [&optional remote directory]
  "Fetch from REMOTE (default: all remotes).
DIRECTORY overrides `default-directory' if provided."
  (let [default-directory (or directory default-directory)]
    (-ensure-repo)
    (-fetch remote)))

;; ============================================================================
;; Interactive Commands
;; ============================================================================

(defn status []
  "Display repository status."
  (interactive)
  (let* [status (api-status)
         buf (get-buffer-create "*MCP Git Status*")]
    (with-current-buffer buf
      (let [inhibit-read-only t]
        (erase-buffer)
        (insert "=== MCP Git Status ===\n\n")
        (insert (format "Repository: %s\n" (plist-get status :repository)))
        (insert (format "Branch: %s" (plist-get status :branch)))
        (when-let* [upstream (plist-get status :upstream)]
          (insert (format " -> %s" upstream)))
        (insert "\n")
        (when (or (> (plist-get status :ahead) 0)
                  (> (plist-get status :behind) 0))
          (insert (format "[ahead %d, behind %d]\n"
                          (plist-get status :ahead)
                          (plist-get status :behind))))
        (insert "\n")
        (insert (format "Staged: %d files\n" (plist-get status :staged-count)))
        (dolist (f (plist-get status :staged))
          (insert (format "  + %s\n" f)))
        (insert (format "Unstaged: %d files\n" (plist-get status :unstaged-count)))
        (dolist (f (plist-get status :unstaged))
          (insert (format "  M %s\n" f)))
        (insert (format "Untracked: %d files\n" (plist-get status :untracked-count)))
        (dolist (f (plist-get status :untracked))
          (insert (format "  ? %s\n" f)))
        (insert (format "\nClean: %s\n" (if (plist-get status :clean) "Yes" "No")))
        (goto-char (point-min))))
    (display-buffer buf)))

(defn commit-interactive []
  "Interactive commit with prompted message."
  (interactive)
  (-ensure-repo)
  (let [message (read-string "Commit message: ")]
    (when (string-empty-p message)
      (error "Commit message cannot be empty"))
    (message "%s" (api-commit message))))

(defn stage-current-file []
  "Stage the current buffer's file."
  (interactive)
  (if-let* [file (buffer-file-name)]
      (progn
        (api-stage file)
        (message "Staged: %s" (file-name-nondirectory file)))
    (error "Buffer is not visiting a file")))

(defn open-magit-status []
  "Open Magit status if available, otherwise show MCP status."
  (interactive)
  (if (-magit-available-p)
      (magit-status)
    (status)))

;; ============================================================================
;; Transient Menu
;; ============================================================================

(defn transient []
  "MCP Magit menu."
  (interactive)
  (if (require 'transient nil t)
      (progn
        (transient-define-prefix hive-mcp-magit--menu ()
          "MCP Magit menu."
          ["hive-mcp + Magit"
           ["Status"
            ("s" "MCP Status" hive-mcp-magit-status)
            ("S" "Magit status" hive-mcp-magit-open-magit-status)]
           ["Stage & Commit"
            ("a" "Stage file" hive-mcp-magit-stage-current-file)
            ("A" "Stage all" (lambda (_unused) (interactive)
                               (message "%s" (hive-mcp-magit-api-stage 'all))))
            ("c" "Commit" hive-mcp-magit-commit-interactive)]
           ["Remote"
            ("f" "Fetch" (lambda (_unused) (interactive)
                           (message "%s" (hive-mcp-magit-api-fetch))))
            ("p" "Pull" (lambda (_unused) (interactive)
                          (message "%s" (hive-mcp-magit-api-pull))))
            ("P" "Push" (lambda (_unused) (interactive)
                          (message "%s" (hive-mcp-magit-api-push))))]])
        (hive-mcp-magit--menu))
    (message "Transient not available")))

;; ============================================================================
;; Minor Mode
;; ============================================================================

(defvar hive-mcp-magit-mode-map
  (let [map (make-sparse-keymap)]
    (define-key map (kbd "C-c g s") #'hive-mcp-magit-status)
    (define-key map (kbd "C-c g S") #'hive-mcp-magit-open-magit-status)
    (define-key map (kbd "C-c g a") #'hive-mcp-magit-stage-current-file)
    (define-key map (kbd "C-c g c") #'hive-mcp-magit-commit-interactive)
    (define-key map (kbd "C-c g g") #'hive-mcp-magit-transient)
    map)
  "Keymap for `hive-mcp-magit-mode'.")

(define-minor-mode hive-mcp-magit-mode
  "Minor mode for Magit integration."
  :init-value nil
  :lighter " MCP-Git"
  :global t
  :keymap hive-mcp-magit-mode-map
  :group 'hive-mcp-magit
  (if hive-mcp-magit-mode
      (message "hive-mcp-magit enabled")
    (message "hive-mcp-magit disabled")))

;; ============================================================================
;; Addon Lifecycle
;; ============================================================================

(defn- -addon-init []
  "Initialize magit addon."
  (require 'hive-mcp-api nil t)
  (when (require 'magit nil t)
    (require 'magit-git nil t)
    (require 'magit-apply nil t)
    (require 'magit-mode nil t))
  (message "hive-mcp-magit: initialized%s"
           (if (featurep 'magit) " (with Magit)" " (shell fallback)")))

(defn- -addon-shutdown []
  "Shutdown magit addon."
  (when hive-mcp-magit-mode
    (hive-mcp-magit-mode -1))
  (message "hive-mcp-magit: shutdown"))

;; ============================================================================
;; Addon Registration
;; ============================================================================

(with-eval-after-load 'hive-mcp-addons
  (hive-mcp-addon-register
    'magit
    :version "0.1.0"
    :description "Magit Git integration with shell fallback"
    :requires '(hive-mcp-api)
    :provides '(hive-mcp-magit-mode hive-mcp-magit-transient)
    :init #'-addon-init
    :shutdown #'-addon-shutdown))
