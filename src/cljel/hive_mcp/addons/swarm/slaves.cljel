(ns hive-mcp-swarm-slaves
  "Slave lifecycle management for hive-mcp-swarm.
Handles spawning, killing, and state management of Claude slave instances.

Design principles (SOLID/CLARITY):
- Single Responsibility: Only handles slave lifecycle
- Open/Closed: New terminal backends via dispatch, not modification
- Dependency Inversion: Callers depend on spawn/kill API, not internals

Functions provided:
- Spawn: Create new slave instances with presets
- Kill: Terminate slaves cleanly without prompts
- Safety: Depth, rate-limit, and slave count checks
- ID generation: Unique slave and task IDs")

(require 'cl-lib)

;; Soft dependencies on terminal backends
(declare-function vterm "vterm")
(declare-function vterm-mode "vterm")
(declare-function vterm-send-string "vterm")
(declare-function vterm-send-return "vterm")

(declare-function eat "eat")
(declare-function eat-mode "eat")
(declare-function eat-exec "eat")
(declare-function eat-term-send-string "eat")

(declare-function claude-code-ide "claude-code-ide")
(declare-function claude-code-ide--create-terminal-session "claude-code-ide")
(declare-function claude-code-ide-mcp-server-ensure-server "claude-code-ide-mcp-server")

;; Ollama backend via hive-mcp-ellama
(declare-function hive-mcp-ellama-swarm-spawn "hive-mcp-ellama")
(declare-function hive-mcp-ellama-swarm-dispatch "hive-mcp-ellama")

;; Dependencies on sibling modules
(declare-function hive-mcp-swarm-terminal-send "hive-mcp-swarm-terminal")
(declare-function hive-mcp-swarm-presets-build-system-prompt "hive-mcp-swarm-presets")
(declare-function hive-mcp-swarm-presets-role-to-presets "hive-mcp-swarm-presets")
(declare-function hive-mcp-swarm-presets-role-to-tier "hive-mcp-swarm-presets")
(declare-function hive-mcp-swarm-presets-merge-defaults "hive-mcp-swarm-presets")
(declare-function hive-mcp-swarm-prompts-clear-slave "hive-mcp-swarm-prompts")
(declare-function hive-mcp-swarm-events-emit-slave-spawned "hive-mcp-swarm-events")
(declare-function hive-mcp-swarm-events-emit-slave-killed "hive-mcp-swarm-events")

;; Dependencies on main module (variables)
(defvar hive-mcp-swarm--slaves)
(defvar hive-mcp-swarm--task-counter)
(defvar hive-mcp-swarm--session-id)
(defvar hive-mcp-swarm--current-depth)
(defvar hive-mcp-swarm--ancestry)
(defvar hive-mcp-swarm-max-slaves)
(defvar hive-mcp-swarm-max-depth)
(defvar hive-mcp-swarm-rate-limit-window)
(defvar hive-mcp-swarm-rate-limit-max-spawns)
(defvar hive-mcp-swarm-terminal)
(defvar hive-mcp-swarm-buffer-prefix)
(defvar hive-mcp-swarm-claude-command)
(defvar hive-mcp-swarm-prompt-mode)

;; Forward declaration for list-presets (interactive use)
(declare-function hive-mcp-swarm-list-presets "hive-mcp-swarm")

;; ============================================================================
;; Internal State
;; ============================================================================

(defvar hive-mcp-swarm-slaves--spawn-timestamps nil
  "List of recent spawn timestamps for rate limiting.")

;; ============================================================================
;; ID Generation
;; ============================================================================

(defn generate-id [name]
  "Generate unique slave ID for NAME."
  (format "swarm-%s-%d" name (floor (float-time))))

(defn generate-task-id [slave-id]
  "Generate unique task ID for SLAVE-ID."
  (cl-incf hive-mcp-swarm--task-counter)
  (format "task-%s-%03d"
          (replace-regexp-in-string "^swarm-" "" slave-id)
          hive-mcp-swarm--task-counter))

;; ============================================================================
;; Safety Checks
;; ============================================================================

(defn- -depth-label [depth]
  "Return human-readable label for DEPTH level."
  (pcase depth
    (0 "master")
    (1 "child")
    (2 "grandchild")
    (3 "great-grandchild")
    (_ (format "depth-%d" depth))))

(defn check-depth []
  "Check if we can spawn at current depth.
Returns the current depth if allowed, signals error if blocked."
  (let* [depth (string-to-number (or (getenv "CLAUDE_SWARM_DEPTH") "0"))
         master-id (getenv "CLAUDE_SWARM_MASTER")
         my-id (getenv "CLAUDE_SWARM_SLAVE_ID")]
    (setq hive-mcp-swarm--current-depth depth)
    ;; Track ancestry for loop detection
    (when (and my-id master-id)
      (push (cons my-id master-id) hive-mcp-swarm--ancestry))
    (when (>= depth hive-mcp-swarm-max-depth)
      (error "Recursion limit reached: %s (depth %d) cannot spawn children.
Maximum depth is %d (master -> child -> grandchild -> great-grandchild).
This limit prevents runaway recursive spawning."
             (-depth-label depth)
             depth
             hive-mcp-swarm-max-depth))
    depth))

(defn check-rate-limit []
  "Check if spawn rate limit allows a new spawn.
Removes old timestamps and checks count within window."
  (let* [now (float-time)
         window-start (- now hive-mcp-swarm-rate-limit-window)]
    ;; Prune old timestamps
    (setq hive-mcp-swarm-slaves--spawn-timestamps
          (cl-remove-if (lambda (ts) (< ts window-start))
                        hive-mcp-swarm-slaves--spawn-timestamps))
    ;; Check limit
    (when (>= (length hive-mcp-swarm-slaves--spawn-timestamps)
              hive-mcp-swarm-rate-limit-max-spawns)
      (error "Rate limit exceeded: %d spawns in %d seconds.
Wait before spawning more slaves to prevent spawn storms."
             hive-mcp-swarm-rate-limit-max-spawns
             hive-mcp-swarm-rate-limit-window))
    ;; Record this spawn attempt
    (push now hive-mcp-swarm-slaves--spawn-timestamps)))

(defn check-limit []
  "Check if we can spawn more slaves."
  (when (>= (hash-table-count hive-mcp-swarm--slaves) hive-mcp-swarm-max-slaves)
    (error "Maximum slave count (%d) reached.
Kill some slaves with `hive-mcp-swarm-kill' before spawning more."
           hive-mcp-swarm-max-slaves)))

;; ============================================================================
;; Project Root Helper
;; ============================================================================

(defn- -project-root []
  "Get current project root."
  (or (when (fboundp 'project-root)
        (when-let* [proj (project-current)]
          (project-root proj)))
      default-directory))

;; ============================================================================
;; Spawn Functions
;; ============================================================================

(cl-defun hive-mcp-swarm-slaves-spawn (name &key presets cwd role terminal backend model kanban-task-id injected-context)
  "Spawn a new Claude slave with NAME - FULLY ASYNC.

PRESETS is a list of preset names to apply.
CWD is the working directory (defaults to current project root).
ROLE is a predefined role that maps to presets AND tier (backend/model).
TERMINAL overrides `hive-mcp-swarm-terminal' for this spawn.
BACKEND explicitly sets the backend.
MODEL sets the model for ollama backend.
KANBAN-TASK-ID is the optional kanban task ID to link this ling with.
INJECTED-CONTEXT is optional pre-generated catchup context.

Returns the slave-id IMMEDIATELY.  The actual spawn happens async."
  (interactive
   (list (read-string "Slave name: ")
         :presets (completing-read-multiple
                   "Presets: "
                   (hive-mcp-swarm-list-presets))))
  ;; Safety checks (order matters: depth -> rate -> slave count)
  (hive-mcp-swarm-slaves/check-depth)
  (hive-mcp-swarm-slaves/check-rate-limit)
  (hive-mcp-swarm-slaves/check-limit)

  ;; Resolve role to presets and tier if provided
  (when role
    (unless presets
      (setq presets (hive-mcp-swarm-presets-role-to-presets role)))
    ;; Apply tier mapping for backend/model if not explicitly set
    (when-let* [tier (hive-mcp-swarm-presets-role-to-tier role)]
      (unless backend
        (setq backend (plist-get tier :backend)))
      (unless model
        (setq model (plist-get tier :model)))))

  ;; Merge with default presets (ling, mcp-first by default)
  (setq presets (hive-mcp-swarm-presets-merge-defaults (or presets '())))

  (let* [slave-id (hive-mcp-swarm-slaves/generate-id name)
         work-dir (or cwd (-project-root) default-directory)
         ;; Backend priority: explicit backend > terminal arg > default terminal
         term-backend (or backend terminal hive-mcp-swarm-terminal)
         parent-id (or (getenv "CLAUDE_SWARM_SLAVE_ID") "master")
         spawn-depth (1+ hive-mcp-swarm--current-depth)]

    ;; Register slave IMMEDIATELY with "spawning" status
    (puthash slave-id
             (list :slave-id slave-id
                   :name name
                   :role role
                   :presets presets
                   :status 'spawning
                   :buffer nil
                   :terminal term-backend
                   :backend term-backend
                   :model model
                   :cwd work-dir
                   :depth spawn-depth
                   :parent-id parent-id
                   :kanban-task-id kanban-task-id
                   :context-injected (not (null injected-context))
                   :current-task nil
                   :task-queue '()
                   :tasks-completed 0
                   :tasks-failed 0
                   :spawned-at (format-time-string "%FT%T%z")
                   :last-activity (format-time-string "%FT%T%z"))
             hive-mcp-swarm--slaves)

    ;; Log spawn intent
    (message "[swarm] Spawning %s (%s) at depth %d, parent: %s (async)"
             slave-id
             (-depth-label spawn-depth)
             spawn-depth
             parent-id)

    ;; Emit slave-spawned event
    (hive-mcp-swarm-events-emit-slave-spawned slave-id name presets work-dir kanban-task-id)

    ;; FULLY ASYNC: Defer ALL work to timer so we return IMMEDIATELY
    (let [ctx injected-context]
      (run-with-timer
       0 nil
       (lambda (_unused)
         (condition-case err
             (hive-mcp-swarm-slaves--do-spawn-async slave-id name presets work-dir term-backend ctx)
           (error
            ;; Mark slave as errored
            (when-let* [slave (gethash slave-id hive-mcp-swarm--slaves)]
              (plist-put slave :status 'error)
              (plist-put slave :error (error-message-string err)))
            (message "[swarm] Spawn error for %s: %s" slave-id (error-message-string err)))))))

    (when (called-interactively-p 'any)
      (message "Spawning slave: %s (async)" slave-id))

    slave-id))

(defn- -do-spawn-async [slave-id name presets work-dir term-backend &optional injected-context]
  "Actually spawn the slave buffer for SLAVE-ID.
Called async from `hive-mcp-swarm-slaves-spawn'."
  (let* [slave (gethash slave-id hive-mcp-swarm--slaves)
         buffer-name (format "%s%s*" hive-mcp-swarm-buffer-prefix name)
         base-prompt (hive-mcp-swarm-presets-build-system-prompt presets injected-context)
         ;; CRITICAL FIX: Inject actual slave-id into system prompt
         identity-section (format "## YOUR IDENTITY AND ENVIRONMENT (CRITICAL)

**Your agent ID is: `%s`**
**Your working directory is: `%s`**

You MUST use this EXACT ID in ALL hivemind tool calls:
- `hivemind_shout(agent_id: \"%s\", ...)`
- `hivemind_ask(agent_id: \"%s\", ...)`

You MUST use paths relative to your working directory or use the EXACT path above.
- CORRECT: `src/hive_mcp/foo.clj` or `%s/src/hive_mcp/foo.clj`
- WRONG: `/Users/...` or `/home/otheruser/...` (DO NOT hallucinate paths!)

DO NOT invent your own ID. DO NOT use short names like \"ling-worker\".
The coordinator tracks you by this exact ID.

---

" slave-id work-dir slave-id slave-id work-dir)
         system-prompt (if base-prompt
                           (concat identity-section base-prompt)
                         identity-section)
         buffer nil]

    (unless slave
      (error "Slave record not found: %s" slave-id))

    ;; Require terminal emulator
    (pcase term-backend
      ('claude-code-ide (unless (require 'claude-code-ide nil t)
                          (error "Claude-code-ide is required but not available")))
      ('vterm (unless (and (require 'vterm nil t)
                          (fboundp 'vterm-mode)
                          (fboundp 'vterm-send-string))
                (error "Vterm is required but not available (vterm-mode not bound)")))
      ('eat (unless (require 'eat nil t)
              (error "Eat is required but not available")))
      ('ollama (unless (require 'hive-mcp-ellama nil t)
                 (error "hive-mcp-ellama is required but not available"))))

    ;; Update status to starting
    (plist-put slave :status 'starting)

    ;; Create terminal buffer
    (setq buffer (generate-new-buffer buffer-name))
    (plist-put slave :buffer buffer)

    (let* [default-directory work-dir
           process-environment
           (append
            (list (format "CLAUDE_SWARM_DEPTH=%d" (plist-get slave :depth))
                  (format "CLAUDE_SWARM_MASTER=%s" (or hive-mcp-swarm--session-id "direct"))
                  (format "CLAUDE_SWARM_SLAVE_ID=%s" slave-id))
            process-environment)
           permission-flag (pcase hive-mcp-swarm-prompt-mode
                             ('bypass "--permission-mode bypassPermissions")
                             (_ ""))
           claude-cmd (if system-prompt
                          (let [prompt-file (make-temp-file "swarm-prompt-" nil ".md")]
                            (with-temp-file prompt-file
                              (insert system-prompt))
                            (format "cd %s && %s %s --system-prompt %s"
                                    (shell-quote-argument work-dir)
                                    hive-mcp-swarm-claude-command
                                    permission-flag
                                    (shell-quote-argument prompt-file)))
                        (format "cd %s && %s %s"
                                (shell-quote-argument work-dir)
                                hive-mcp-swarm-claude-command
                                permission-flag))]

      (pcase term-backend
        ('claude-code-ide
         ;; Use full claude-code-ide session with MCP WebSocket integration
         (when (buffer-live-p buffer)
           (kill-buffer buffer))
         (let* [prompt-file (when system-prompt
                              (let [f (make-temp-file "swarm-prompt-" nil ".md")]
                                (with-temp-file f
                                  (insert system-prompt))
                                f))
                port (when (fboundp 'claude-code-ide-mcp-server-ensure-server)
                       (claude-code-ide-mcp-server-ensure-server))
                _ (unless port
                    (error "Failed to start MCP server for claude-code-ide backend"))
                result (claude-code-ide--create-terminal-session
                        buffer-name
                        work-dir
                        port
                        nil  ;; continue
                        nil  ;; resume
                        slave-id
                        prompt-file)]
           (setq buffer (car result))
           (plist-put slave :buffer buffer)
           (plist-put slave :process (cdr result))))
        ('vterm
         (with-current-buffer buffer
           (vterm-mode)
           (run-at-time 0.5 nil
                        (lambda (_unused)
                          (condition-case err
                              (when (buffer-live-p buffer)
                                (with-current-buffer buffer
                                  (vterm-send-string claude-cmd)
                                  (vterm-send-return)))
                            (error
                             (message "[swarm] Timer error sending vterm cmd for %s: %s"
                                      slave-id (error-message-string err))))))))
        ('eat
         (with-current-buffer buffer
           (eat-mode)
           (eat-exec buffer "swarm-shell" "/bin/bash" nil '("-l")))
         (run-at-time 0.5 nil
                      (lambda (_unused)
                        (condition-case err
                            (when (buffer-live-p buffer)
                              (with-current-buffer buffer
                                (when (and (boundp 'eat-terminal) eat-terminal)
                                  (eat-term-send-string eat-terminal claude-cmd)
                                  (eat-term-send-string eat-terminal "\r"))))
                          (error
                           (message "[swarm] Timer error sending eat cmd for %s: %s"
                                    slave-id (error-message-string err)))))))
        ('ollama
         ;; Ollama backend uses hive-mcp-ellama for local LLM inference
         (when (buffer-live-p buffer)
           (kill-buffer buffer))
         (let [model (or (plist-get slave :model)
                         (bound-and-true-p hive-mcp-ellama-default-model)
                         "devstral")]
           (hive-mcp-ellama-swarm-spawn slave-id name model)
           (plist-put slave :model model)
           (plist-put slave :backend 'ollama)
           (plist-put slave :status 'idle)))))

  ;; Log completion
  (message "[swarm] Spawned %s buffer created" slave-id)

  ;; Schedule status transition to idle
  (run-at-time
   3 nil
   (lambda (_unused)
     (condition-case err
         (when-let* [s (gethash slave-id hive-mcp-swarm--slaves)]
           (when (memq (plist-get s :status) '(starting spawning))
             (plist-put s :status 'idle)))
       (error
        (message "[swarm] Timer error transitioning %s to idle: %s"
                 slave-id (error-message-string err))))))))

;; ============================================================================
;; Kill Functions
;; ============================================================================

(defn- -extract-name-from-id [slave-id]
  "Extract the name portion from SLAVE-ID.
Slave ID format: swarm-NAME-TIMESTAMP."
  (when (and slave-id (string-match "^swarm-\\(.+\\)-[0-9]+$" slave-id))
    (match-string 1 slave-id)))

(defn- -valid-kill-target-p [buffer slave-id]
  "Validate BUFFER is a valid kill target for SLAVE-ID.
Returns t if safe to kill, nil otherwise."
  (when (buffer-live-p buffer)
    (let* [buf-name (buffer-name buffer)
           buf-name-lower (downcase buf-name)
           slave-name (-extract-name-from-id slave-id)]
      (cond
       ;; Check 1: Must have swarm prefix
       ((not (string-prefix-p hive-mcp-swarm-buffer-prefix buf-name))
        (message "[swarm-kill] BLOCKED: Buffer '%s' lacks swarm prefix for slave %s"
                 buf-name slave-id)
        nil)

       ;; Check 2: Must NOT contain "coordinator"
       ((string-match-p "coordinator" buf-name-lower)
        (message "[swarm-kill] BLOCKED: Buffer '%s' contains 'coordinator' - refusing to kill"
                 buf-name)
        nil)

       ;; Check 3: Must NOT be a known coordinator pattern
       ((or (string-match-p "\\*claude-code" buf-name-lower)
            (string-match-p "\\*claude code" buf-name-lower)
            (string-match-p "master" buf-name-lower))
        (message "[swarm-kill] BLOCKED: Buffer '%s' matches coordinator pattern - refusing to kill"
                 buf-name)
        nil)

       ;; Check 4: Buffer name must contain slave name from slave-id
       ((and slave-name
             (not (string-match-p (regexp-quote slave-name) buf-name)))
        (message "[swarm-kill] BLOCKED: Buffer '%s' doesn't match slave name '%s' from ID %s"
                 buf-name slave-name slave-id)
        (message "[swarm-kill] This indicates registry corruption - buffer/slave-id mismatch!")
        nil)

       ;; All checks passed
       (t
        (message "[swarm-kill] Validated: killing buffer '%s' for slave %s (name: %s)"
                 buf-name slave-id (or slave-name "unknown"))
        t)))))

(defn kill [slave-id]
  "Kill slave SLAVE-ID without prompts.
Force-kills the buffer to prevent blocking on process/unsaved prompts.
Returns t on success, nil if slave not found or buffer invalid."
  (interactive
   (list (completing-read "Kill slave: "
                          (hash-table-keys hive-mcp-swarm--slaves))))
  (if-let* [slave (gethash slave-id hive-mcp-swarm--slaves)]
      (let [buffer (plist-get slave :buffer)
            slave-name (plist-get slave :name)]
        (cond
         ;; Buffer is nil (spawn still in progress or already dead)
         ((null buffer)
          (message "[swarm-kill] Warning: slave %s has no buffer (spawn incomplete?)" slave-id)
          (hive-mcp-swarm-events-emit-slave-killed slave-id)
          (remhash slave-id hive-mcp-swarm--slaves)
          (hive-mcp-swarm-prompts-clear-slave slave-id)
          t)

         ;; Buffer is not live (already killed externally)
         ((not (buffer-live-p buffer))
          (message "[swarm-kill] Info: slave %s buffer already dead, cleaning registry" slave-id)
          (hive-mcp-swarm-events-emit-slave-killed slave-id)
          (remhash slave-id hive-mcp-swarm--slaves)
          (hive-mcp-swarm-prompts-clear-slave slave-id)
          t)

         ;; SAFETY CHECK: Validate buffer is valid kill target
         ((not (-valid-kill-target-p buffer slave-id))
          (message "[swarm-kill] BLOCKED: Buffer '%s' failed safety validation for slave %s"
                   (buffer-name buffer) slave-id)
          (message "[swarm-kill] This prevents accidentally killing coordinator!")
          (remhash slave-id hive-mcp-swarm--slaves)
          nil)

         ;; Valid target - proceed with kill
         (t
          (with-current-buffer buffer
            ;; Step 1: Mark buffer as unmodified
            (set-buffer-modified-p nil)
            ;; Step 2: Disable process query-on-exit
            (when-let* [proc (get-buffer-process buffer)]
              (set-process-query-on-exit-flag proc nil))
            ;; Also handle vterm's internal process tracking
            (when (and (boundp 'vterm--process) vterm--process
                       (process-live-p vterm--process))
              (set-process-query-on-exit-flag vterm--process nil)))
          ;; Step 3: Kill buffer with ALL hooks disabled
          (let [kill-buffer-query-functions nil
                kill-buffer-hook nil
                vterm-exit-functions nil]
            (kill-buffer buffer))
          ;; Emit slave-killed event
          (hive-mcp-swarm-events-emit-slave-killed slave-id)
          (remhash slave-id hive-mcp-swarm--slaves)
          (hive-mcp-swarm-prompts-clear-slave slave-id)
          (message "Killed slave: %s" slave-id)
          t)))
    ;; Slave not found in registry
    (message "[swarm-kill] Slave not found: %s" slave-id)
    nil))

(defn kill-all []
  "Kill all slaves."
  (interactive)
  (let [count 0]
    (maphash (lambda (id _unused)
               (hive-mcp-swarm-slaves/kill id)
               (cl-incf count))
             hive-mcp-swarm--slaves)
    (message "Killed %d slaves" count)))

;; ============================================================================
;; Accessors
;; ============================================================================

(defn get-spawn-timestamps []
  "Get the list of recent spawn timestamps."
  hive-mcp-swarm-slaves--spawn-timestamps)

(defn get-spawn-count []
  "Get the count of recent spawns within the rate limit window."
  (length hive-mcp-swarm-slaves--spawn-timestamps))

;; ============================================================================
;; Lifecycle
;; ============================================================================

(defn init []
  "Initialize slaves module."
  (setq hive-mcp-swarm-slaves--spawn-timestamps nil))

(defn shutdown []
  "Shutdown slaves module."
  (setq hive-mcp-swarm-slaves--spawn-timestamps nil))
