(ns hive-mcp-swarm-tasks
  "Task dispatch and collection for hive-mcp-swarm.
Handles sending prompts to slaves and collecting responses.

Design principles (SOLID/CLARITY):
- Single Responsibility: Only handles task dispatch/collection
- Open/Closed: Response extraction extensible via patterns
- Dependency Inversion: Callers depend on dispatch/collect API")

(require 'cl-lib)
(require 'subr-x)

;; Dependencies on sibling modules
(declare-function hive-mcp-swarm-terminal-send "hive-mcp-swarm-terminal")
(declare-function hive-mcp-swarm-terminal-ready-p "hive-mcp-swarm-terminal")
(declare-function hive-mcp-swarm-terminal-wait-ready "hive-mcp-swarm-terminal")
(declare-function hive-mcp-swarm-slaves-generate-task-id "hive-mcp-swarm-slaves")
(declare-function hive-mcp-swarm-events-emit-dispatch-dropped "hive-mcp-swarm-events")

;; Dependencies on main module (variables)
(defvar hive-mcp-swarm--slaves)
(defvar hive-mcp-swarm--tasks)
(defvar hive-mcp-swarm-terminal)
(defvar hive-mcp-swarm-default-timeout)

;; ============================================================================
;; ACID Dispatch Queue
;; ============================================================================

(defvar hive-mcp-swarm-dispatch-queue '()
  "ACID queue for pending dispatches.
Each element is a plist:
  (:slave-id ID :prompt TEXT :timeout MS :priority PRI
   :context CTX :queued-at TIME :retries N)")

(defvar hive-mcp-swarm-dispatch-queue-timer nil
  "Timer for processing the dispatch queue.")

(defcustom hive-mcp-swarm-dispatch-queue-interval 0.5
  "Interval in seconds between queue processing attempts."
  :type 'float
  :group 'hive-mcp-swarm)

(defcustom hive-mcp-swarm-dispatch-max-retries 20
  "Maximum retries before dropping a queued dispatch.
At 0.5s intervals, 20 retries = 10 seconds max wait."
  :type 'integer
  :group 'hive-mcp-swarm)

(defcustom hive-mcp-swarm-dispatch-queue-enabled t
  "If non-nil, use ACID queue for dispatches."
  :type 'boolean
  :group 'hive-mcp-swarm)

;; ============================================================================
;; Buffer Detection Helpers
;; ============================================================================

(defn- -buffer-contains-p [buffer text &optional start-point]
  "Check if BUFFER contains TEXT after START-POINT.
Uses first 40 chars as signature.  Returns position if found, nil otherwise."
  (when (buffer-live-p buffer)
    (with-current-buffer buffer
      (save-excursion
        (goto-char (or start-point (point-min)))
        (search-forward (substring text 0 (min 40 (length text))) nil t)))))

(defn- -claude-responded-p [buffer text &optional start-point]
  "Check if Claude has responded to TEXT in BUFFER after START-POINT."
  (when (buffer-live-p buffer)
    (with-current-buffer buffer
      (save-excursion
        (goto-char (or start-point (point-min)))
        (when (search-forward (substring text 0 (min 40 (length text))) nil t)
          (search-forward "\u25cf" nil t))))))

;; ============================================================================
;; Response Extraction (DRY helper)
;; ============================================================================

(defn- -extract-response [buffer prompt]
  "Extract Claude's response to PROMPT from BUFFER.
Returns response string if complete, nil if still running."
  (when (buffer-live-p buffer)
    (with-current-buffer buffer
      (save-excursion
        (goto-char (point-min))
        (let [search-key (substring prompt 0 (min 50 (length prompt)))]
          (when (and (search-forward search-key nil t)
                     (search-forward "\u25cf" nil t))
            (let [response-start (point)]
              (cond
               ((search-forward "\n> " nil t)
                (string-trim (buffer-substring-no-properties response-start (- (point) 3))))
               ((search-forward "\n\u2500\u2500\u2500\u2500" nil t)
                (string-trim (buffer-substring-no-properties response-start (- (point) 5))))
               ((search-forward "\n\n\n" nil t)
                (string-trim (buffer-substring-no-properties response-start (- (point) 3))))))))))))

;; ============================================================================
;; Filter Matching
;; ============================================================================

(defn- -slave-matches-filter [slave filter]
  "Check if SLAVE matches FILTER criteria (:role, :status)."
  (and (or (not (plist-get filter :role))
           (equal (plist-get slave :role) (plist-get filter :role)))
       (or (not (plist-get filter :status))
           (eq (plist-get slave :status) (plist-get filter :status)))))

;; ============================================================================
;; Queue Operations
;; ============================================================================

(defn enqueue-dispatch [slave-id prompt &optional timeout priority context]
  "Add dispatch to ACID queue atomically.
SLAVE-ID is the target slave, PROMPT is the text to send.
Returns the queue entry plist."
  (let [entry (list :slave-id slave-id
                    :prompt prompt
                    :timeout timeout
                    :priority (or priority 'normal)
                    :context context
                    :queued-at (float-time)
                    :retries 0)]
    ;; Atomic append
    (setq hive-mcp-swarm-dispatch-queue
          (append hive-mcp-swarm-dispatch-queue (list entry)))
    (message "[swarm-tasks] Queued dispatch for %s (queue depth: %d)"
             slave-id (length hive-mcp-swarm-dispatch-queue))
    ;; Ensure queue processor is running
    (hive-mcp-swarm-tasks/start-queue-processor)
    entry))

(defn dequeue-dispatch []
  "Remove and return the first queue entry (FIFO).
Returns nil if queue is empty."
  (when hive-mcp-swarm-dispatch-queue
    (let [entry (car hive-mcp-swarm-dispatch-queue)]
      (setq hive-mcp-swarm-dispatch-queue (cdr hive-mcp-swarm-dispatch-queue))
      entry)))

(defn peek-queue []
  "Return first queue entry without removing it."
  (car hive-mcp-swarm-dispatch-queue))

(defn queue-depth []
  "Return current queue depth."
  (length hive-mcp-swarm-dispatch-queue))

(defn- -slave-ready-p [slave-id]
  "Check if SLAVE-ID terminal is ready to receive input."
  (when-let* [slave (gethash slave-id hive-mcp-swarm--slaves)
              buffer (plist-get slave :buffer)]
    (and (buffer-live-p buffer)
         (hive-mcp-swarm-terminal-ready-p buffer))))

(defn- -notify-dispatch-dropped [slave-id reason prompt retries queued-at]
  "Notify coordinator and user that a dispatch was dropped."
  (when (require 'hive-mcp-swarm-events nil t)
    (hive-mcp-swarm-events-emit-dispatch-dropped
     slave-id reason prompt retries queued-at))
  (display-warning
   'hive-mcp-swarm
   (format "DISPATCH DROPPED: %s - %s after %d retries. Prompt: %.50s..."
           slave-id reason retries (or prompt ""))
   :warning))

(defn- -slave-truly-dead-p [slave]
  "Check if SLAVE is truly dead vs still spawning.
Returns non-nil if slave should be considered dead."
  (if (not slave)
      t  ; No entry = truly dead
    (let [status (plist-get slave :status)
          buffer (plist-get slave :buffer)]
      (cond
       ;; Error status = dead
       ((eq status 'error) t)
       ;; Spawning/starting = not dead, just not ready yet
       ((memq status '(spawning starting)) nil)
       ;; Buffer exists - check if dead
       (buffer (not (buffer-live-p buffer)))
       ;; No buffer and not spawning/starting/error = inconsistent, treat as dead
       (t t)))))

(defn- -process-queue-entry [entry]
  "Process a single queue ENTRY, dispatching if terminal ready.
Returns:
  :success - dispatch succeeded
  :retry   - terminal not ready, should retry
  :failed  - max retries exceeded or slave dead"
  (let* [slave-id (plist-get entry :slave-id)
         prompt (plist-get entry :prompt)
         retries (plist-get entry :retries)
         timeout (plist-get entry :timeout)
         priority (plist-get entry :priority)
         context (plist-get entry :context)
         queued-at (plist-get entry :queued-at)
         slave (gethash slave-id hive-mcp-swarm--slaves)]
    (cond
     ;; Slave truly dead (not spawning) - fail
     ((-slave-truly-dead-p slave)
      (message "[swarm-tasks] Queue: %s slave dead, dropping dispatch" slave-id)
      (-notify-dispatch-dropped
       slave-id "slave-dead" prompt retries queued-at)
      :failed)
     ;; Max retries exceeded - fail
     ((>= retries hive-mcp-swarm-dispatch-max-retries)
      (message "[swarm-tasks] Queue: %s max retries (%d) exceeded, dropping"
               slave-id retries)
      (-notify-dispatch-dropped
       slave-id "max-retries-exceeded" prompt retries queued-at)
      :failed)
     ;; Terminal ready - dispatch!
     ((-slave-ready-p slave-id)
      (condition-case err
          (let [result (hive-mcp-swarm-tasks/dispatch-immediate
                        slave-id prompt
                        :timeout timeout :priority priority :context context)]
            (if (equal (plist-get result :status) "dispatched")
                (progn
                  (message "[swarm-tasks] Queue: %s dispatched after %d retries (task: %s)"
                           slave-id retries (plist-get result :task-id))
                  :success)
              (message "[swarm-tasks] Queue: %s dispatch failed: %s"
                       slave-id (plist-get result :error))
              (-notify-dispatch-dropped
               slave-id (or (plist-get result :error) "dispatch-error")
               prompt retries queued-at)
              :failed))
        (error
         (message "[swarm-tasks] Queue: %s dispatch error: %s"
                  slave-id (error-message-string err))
         (-notify-dispatch-dropped
          slave-id "dispatch-error" prompt retries queued-at)
         :failed)))
     ;; Not ready - retry
     (t
      (message "[swarm-tasks] Queue: %s not ready (retry %d/%d)"
               slave-id (1+ retries) hive-mcp-swarm-dispatch-max-retries)
      :retry))))

(defn process-queue []
  "Process all ready entries in the dispatch queue.
Called periodically by the queue timer."
  (condition-case err
      (when hive-mcp-swarm-dispatch-queue
        (let [current-queue hive-mcp-swarm-dispatch-queue
              new-queue '()]
          ;; Clear queue atomically before processing
          (setq hive-mcp-swarm-dispatch-queue nil)
          ;; Process each entry
          (dolist (entry current-queue)
            (pcase (-process-queue-entry entry)
              (:retry
               ;; Re-queue with incremented retry count
               (plist-put entry :retries (1+ (plist-get entry :retries)))
               (push entry new-queue))
              (:success nil)
              (:failed nil)))
          ;; Add remaining entries back to queue (in original order)
          (setq hive-mcp-swarm-dispatch-queue (nreverse new-queue))
          ;; Stop timer if queue empty
          (when (null hive-mcp-swarm-dispatch-queue)
            (hive-mcp-swarm-tasks/stop-queue-processor))))
    (error
     (message "[swarm-tasks] Queue processor tick error: %s"
              (error-message-string err)))))

(defn start-queue-processor []
  "Start the queue processor timer if not already running."
  (unless hive-mcp-swarm-dispatch-queue-timer
    (setq hive-mcp-swarm-dispatch-queue-timer
          (run-with-timer
           hive-mcp-swarm-dispatch-queue-interval
           hive-mcp-swarm-dispatch-queue-interval
           #'hive-mcp-swarm-tasks-process-queue))
    (message "[swarm-tasks] Queue processor started (interval: %.1fs)"
             hive-mcp-swarm-dispatch-queue-interval)))

(defn stop-queue-processor []
  "Stop the queue processor timer."
  (when hive-mcp-swarm-dispatch-queue-timer
    (cancel-timer hive-mcp-swarm-dispatch-queue-timer)
    (setq hive-mcp-swarm-dispatch-queue-timer nil)
    (message "[swarm-tasks] Queue processor stopped")))

(defn clear-queue []
  "Clear all pending dispatches from the queue.
Use with caution - dispatches will be lost."
  (interactive)
  (let [count (length hive-mcp-swarm-dispatch-queue)]
    (setq hive-mcp-swarm-dispatch-queue nil)
    (hive-mcp-swarm-tasks/stop-queue-processor)
    (message "[swarm-tasks] Cleared %d queued dispatches" count)))

(defn queue-status []
  "Return queue status as a plist for diagnostics."
  (list :depth (length hive-mcp-swarm-dispatch-queue)
        :processor-running (not (null hive-mcp-swarm-dispatch-queue-timer))
        :entries (mapcar (lambda (e)
                           (list :slave-id (plist-get e :slave-id)
                                 :retries (plist-get e :retries)
                                 :queued-at (plist-get e :queued-at)))
                         hive-mcp-swarm-dispatch-queue)))

;; ============================================================================
;; Task Dispatch
;; ============================================================================

(cl-defun hive-mcp-swarm-tasks-dispatch-immediate (slave-id prompt &key timeout priority context)
  "Dispatch PROMPT to SLAVE-ID (NON-BLOCKING).
TIMEOUT is milliseconds, PRIORITY is critical/high/normal/low.
Returns structured response plist."
  (interactive
   (list (completing-read "Slave: " (hash-table-keys hive-mcp-swarm--slaves))
         (read-string "Prompt: ")))
  (let* [slave (gethash slave-id hive-mcp-swarm--slaves)
         buffer (and slave (plist-get slave :buffer))]
    ;; Pre-validation with structured error responses
    (unless slave
      (cl-return-from hive-mcp-swarm-tasks-dispatch-immediate
        (list :status "error" :slave-id slave-id :error "slave-not-found")))
    (unless (buffer-live-p buffer)
      (cl-return-from hive-mcp-swarm-tasks-dispatch-immediate
        (list :status "error" :slave-id slave-id :error "buffer-dead")))
    ;; Generate task-id after validation
    (let [task-id (hive-mcp-swarm-slaves-generate-task-id slave-id)
          send-error nil]
      ;; Create task record
      (puthash task-id
               (list :task-id task-id :slave-id slave-id :prompt prompt
                     :status 'dispatched :priority (or priority 'normal)
                     :timeout (or timeout hive-mcp-swarm-default-timeout)
                     :context context :dispatched-at (format-time-string "%FT%T%z")
                     :completed-at nil :result nil :error nil)
               hive-mcp-swarm--tasks)
      ;; Update slave state
      (plist-put slave :status 'working)
      (plist-put slave :current-task task-id)
      (plist-put slave :last-activity (format-time-string "%FT%T%z"))
      (plist-put slave :task-start-point (with-current-buffer buffer (point-max)))
      ;; Send prompt - NON-BLOCKING, capture errors
      (condition-case err
          (hive-mcp-swarm-terminal-send buffer prompt
                                        (or (plist-get slave :terminal) hive-mcp-swarm-terminal))
        (error
         (setq send-error (error-message-string err))
         (message "[swarm-tasks] Dispatch error: %s" send-error)
         ;; Clean up task record on send failure
         (remhash task-id hive-mcp-swarm--tasks)
         ;; Reset slave state
         (plist-put slave :status 'idle)
         (plist-put slave :current-task nil)))
      ;; Return structured response
      (when (called-interactively-p 'any)
        (message (if send-error
                     "Failed to dispatch to %s: %s"
                   "Dispatched task %s to %s")
                 (if send-error slave-id task-id)
                 (if send-error send-error slave-id)))
      (if send-error
          (list :status "error" :slave-id slave-id :error send-error)
        (list :status "dispatched" :task-id task-id :slave-id slave-id)))))

(cl-defun hive-mcp-swarm-tasks-dispatch (slave-id prompt &key timeout priority context)
  "Dispatch PROMPT to SLAVE-ID with ACID queue support.
Returns structured response plist."
  (interactive
   (list (completing-read "Slave: " (hash-table-keys hive-mcp-swarm--slaves))
         (read-string "Prompt: ")))
  (if (and hive-mcp-swarm-dispatch-queue-enabled
           (not (hive-mcp-swarm-tasks--slave-ready-p slave-id)))
      ;; Queue for later - terminal not ready
      (let [entry (hive-mcp-swarm-tasks/enqueue-dispatch slave-id prompt timeout priority context)]
        (message "[swarm-tasks] Terminal not ready, queuing dispatch for %s" slave-id)
        (list :status "queued"
              :slave-id slave-id
              :queue-position (length hive-mcp-swarm-dispatch-queue)
              :queued-at (plist-get entry :queued-at)
              :message "Dispatch queued - terminal not ready"))
    ;; Dispatch immediately
    (hive-mcp-swarm-tasks-dispatch-immediate slave-id prompt
                                              :timeout timeout
                                              :priority priority
                                              :context context)))

;; ============================================================================
;; Task Collection
;; ============================================================================

(defn collect [task-id &optional timeout-ms]
  "Collect response for TASK-ID (BLOCKING).
TIMEOUT-MS defaults to 5000.  Returns task plist with :result."
  (interactive
   (list (completing-read "Task: " (hash-table-keys hive-mcp-swarm--tasks))))
  (let* [task (or (gethash task-id hive-mcp-swarm--tasks)
                  (error "Task not found: %s" task-id))
         slave (gethash (plist-get task :slave-id) hive-mcp-swarm--slaves)
         buffer (plist-get slave :buffer)
         timeout (/ (or timeout-ms 5000) 1000.0)
         start-time (float-time)
         result nil]
    ;; Poll for completion
    (while (and (< (- (float-time) start-time) timeout) (not result))
      (setq result (-extract-response buffer (plist-get task :prompt)))
      (unless result (sleep-for 0.5)))
    ;; Update task and slave
    (if result
        (progn
          (plist-put task :status 'completed)
          (plist-put task :result result)
          (plist-put task :completed-at (format-time-string "%FT%T%z"))
          (plist-put slave :status 'idle)
          (plist-put slave :current-task nil)
          (plist-put slave :tasks-completed (1+ (plist-get slave :tasks-completed))))
      (plist-put task :status 'timeout)
      (plist-put task :error "Collection timed out"))
    (when (called-interactively-p 'any)
      (message (if result "Collected result (%d chars)" "Collection timed out")
               (length (or result ""))))
    task))

;; ============================================================================
;; Broadcast
;; ============================================================================

(defn broadcast [prompt &optional slave-filter]
  "Send PROMPT to all slaves matching SLAVE-FILTER (:role, :status).
Returns list of dispatch results for each slave."
  (let [results '()
        target-count 0]
    (maphash (lambda (slave-id slave)
               (when (or (not slave-filter)
                         (-slave-matches-filter slave slave-filter))
                 (cl-incf target-count)
                 (condition-case err
                     (let [result (hive-mcp-swarm-tasks/dispatch slave-id prompt)]
                       (push result results))
                   (error
                    (message "[swarm-tasks] Broadcast to %s failed: %s"
                             slave-id (error-message-string err))
                    (push (list :status "error"
                                :slave-id slave-id
                                :error (error-message-string err))
                          results)))))
             hive-mcp-swarm--slaves)
    (when (zerop target-count)
      (message "[swarm-tasks] Broadcast: no slaves available (hash-table count: %d)"
               (hash-table-count hive-mcp-swarm--slaves)))
    (nreverse results)))

;; ============================================================================
;; Non-blocking Completion Check
;; ============================================================================

(defn check-completion [task-id]
  "Check if TASK-ID has completed (NON-BLOCKING).
Returns result string if complete, nil if still running."
  (when-let* [task (gethash task-id hive-mcp-swarm--tasks)
              slave (gethash (plist-get task :slave-id) hive-mcp-swarm--slaves)
              buffer (plist-get slave :buffer)]
    (-extract-response buffer (plist-get task :prompt))))

;; ============================================================================
;; Lifecycle
;; ============================================================================

(defn init []
  "Initialize tasks module."
  (setq hive-mcp-swarm-dispatch-queue nil)
  (message "[swarm-tasks] Tasks module initialized (ACID queue: %s)"
           (if hive-mcp-swarm-dispatch-queue-enabled "enabled" "disabled")))

(defn shutdown []
  "Shutdown tasks module."
  (hive-mcp-swarm-tasks/stop-queue-processor)
  (let [dropped (length hive-mcp-swarm-dispatch-queue)]
    (setq hive-mcp-swarm-dispatch-queue nil)
    (when (> dropped 0)
      (message "[swarm-tasks] Warning: dropped %d queued dispatches on shutdown"
               dropped))))
