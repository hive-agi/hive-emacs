;;; hive-mcp-swarm-tasks.el --- -*- lexical-binding: t; -*-
;; Generated by ClojureElisp

(require 'clojure-elisp-runtime)

;;; Code:



(require 'cl-lib)

(require 'subr-x)

(declare-function hive-mcp-swarm-terminal-send "hive-mcp-swarm-terminal")

(declare-function hive-mcp-swarm-terminal-ready-p "hive-mcp-swarm-terminal")

(declare-function hive-mcp-swarm-terminal-wait-ready "hive-mcp-swarm-terminal")

(declare-function hive-mcp-swarm-slaves-generate-task-id "hive-mcp-swarm-slaves")

(declare-function hive-mcp-swarm-events-emit-dispatch-dropped "hive-mcp-swarm-events")

(defvar hive-mcp-swarm--slaves nil)

(defvar hive-mcp-swarm--tasks nil)

(defvar hive-mcp-swarm-terminal nil)

(defvar hive-mcp-swarm-default-timeout nil)

(defvar hive-mcp-swarm-dispatch-queue '()
  "ACID queue for pending dispatches.\nEach element is a plist:\n  (:slave-id ID :prompt TEXT :timeout MS :priority PRI\n   :context CTX :queued-at TIME :retries N)")

(defvar hive-mcp-swarm-dispatch-queue-timer nil)

(defcustom hive-mcp-swarm-dispatch-queue-interval 0.5
  "Interval in seconds between queue processing attempts."
  :group 'hive-mcp-swarm
  :type 'float)

(defcustom hive-mcp-swarm-dispatch-max-retries 20
  "Maximum retries before dropping a queued dispatch.\nAt 0.5s intervals, 20 retries = 10 seconds max wait."
  :group 'hive-mcp-swarm
  :type 'integer)

(defcustom hive-mcp-swarm-dispatch-queue-enabled t
  "If non-nil, use ACID queue for dispatches."
  :group 'hive-mcp-swarm
  :type 'boolean)

(defun hive-mcp-swarm-tasks---buffer-contains-p (buffer text &optional start-point)
  "Check if BUFFER contains TEXT after START-POINT.\nUses first 40 chars as signature.  Returns position if found, nil otherwise."
  (when (buffer-live-p buffer)
    (with-current-buffer buffer
    (save-excursion
    (goto-char (or start-point (point-min)))
    (search-forward (substring text 0 (cl-min 40 (length text))) nil t)))))

(defun hive-mcp-swarm-tasks---claude-responded-p (buffer text &optional start-point)
  "Check if Claude has responded to TEXT in BUFFER after START-POINT."
  (when (buffer-live-p buffer)
    (with-current-buffer buffer
    (save-excursion
    (goto-char (or start-point (point-min)))
    (when (search-forward (substring text 0 (cl-min 40 (length text))) nil t)
    (search-forward "●" nil t))))))

(defun hive-mcp-swarm-tasks---extract-response (buffer prompt)
  "Extract Claude's response to PROMPT from BUFFER.\nReturns response string if complete, nil if still running."
  (when (buffer-live-p buffer)
    (with-current-buffer buffer
    (save-excursion
    (goto-char (point-min))
    (let* ((search-key (substring prompt 0 (cl-min 50 (length prompt)))))
    (when (and (search-forward search-key nil t) (search-forward "●" nil t))
    (let* ((response-start (point)))
    (cond
  (((search-forward "\n> " nil t) (string-trim (buffer-substring-no-properties response-start (- (point) 3)))) ((search-forward "\n────" nil t) (string-trim (buffer-substring-no-properties response-start (- (point) 5)))))))))))))

(defun hive-mcp-swarm-tasks---slave-matches-filter (slave filter)
  "Check if SLAVE matches FILTER criteria (:role, :status)."
  (and (or (not (plist-get filter :role)) (equal (plist-get slave :role) (plist-get filter :role))) (or (not (plist-get filter :status)) (eq (plist-get slave :status) (plist-get filter :status)))))

(defun hive-mcp-swarm-tasks-enqueue-dispatch (slave-id prompt &optional timeout priority context)
  "Add dispatch to ACID queue atomically.\nSLAVE-ID is the target slave, PROMPT is the text to send.\nReturns the queue entry plist."
  (let* ((entry (list :slave-id slave-id :prompt prompt :timeout timeout :priority (or priority 'normal) :context context :queued-at (float-time) :retries 0)))
    (setq hive-mcp-swarm-dispatch-queue (append hive-mcp-swarm-dispatch-queue (list entry)))
    (message "[swarm-tasks] Queued dispatch for %s (queue depth: %d)" slave-id (length hive-mcp-swarm-dispatch-queue))
    (hive-mcp-swarm-tasks-start-queue-processor)
    entry))

(defun hive-mcp-swarm-tasks-dequeue-dispatch ()
  "Remove and return the first queue entry (FIFO).\nReturns nil if queue is empty."
  (when hive-mcp-swarm-dispatch-queue
    (let* ((entry (car hive-mcp-swarm-dispatch-queue)))
    (setq hive-mcp-swarm-dispatch-queue (cdr hive-mcp-swarm-dispatch-queue))
    entry)))

(defun hive-mcp-swarm-tasks-peek-queue ()
  "Return first queue entry without removing it."
  (car hive-mcp-swarm-dispatch-queue))

(defun hive-mcp-swarm-tasks-queue-depth ()
  "Return current queue depth."
  (length hive-mcp-swarm-dispatch-queue))

(defun hive-mcp-swarm-tasks---slave-ready-p (slave-id)
  "Check if SLAVE-ID terminal is ready to receive input."
  (when-let-star (list slave (gethash slave-id hive-mcp-swarm--slaves) buffer (plist-get slave :buffer)) (and (buffer-live-p buffer) (hive-mcp-swarm-terminal-ready-p buffer))))

(defun hive-mcp-swarm-tasks---notify-dispatch-dropped (slave-id reason prompt retries queued-at)
  "Notify coordinator and user that a dispatch was dropped."
  (when (require 'hive-mcp-swarm-events nil t)
    (hive-mcp-swarm-events-emit-dispatch-dropped slave-id reason prompt retries queued-at))
  (display-warning 'hive-mcp-swarm (format "DISPATCH DROPPED: %s - %s after %d retries. Prompt: %.50s..." slave-id reason retries (or prompt "")) :warning))

(defun hive-mcp-swarm-tasks---slave-truly-dead-p (slave)
  "Check if SLAVE is truly dead vs still spawning.\nReturns non-nil if slave should be considered dead."
  (if (not slave) t (let* ((status (plist-get slave :status))
        (buffer (plist-get slave :buffer)))
    (cond
  (((eq status 'error) t) ((memq status '(spawning starting)) nil))
  ((buffer (not (buffer-live-p buffer))) (t t))))))

(provide 'hive-mcp-swarm-tasks)
;;; hive-mcp-swarm-tasks.el ends here
