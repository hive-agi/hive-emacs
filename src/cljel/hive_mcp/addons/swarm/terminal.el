;;; hive-mcp-swarm-terminal.el --- -*- lexical-binding: t; -*-
;; Generated by ClojureElisp

(require 'clojure-elisp-runtime)

;;; Code:



(require 'cl-lib)

(declare-function vterm "vterm")

(declare-function vterm-mode "vterm")

(declare-function vterm-send-string "vterm")

(declare-function vterm-send-return "vterm")

(declare-function eat "eat")

(declare-function eat-mode "eat")

(declare-function eat-exec "eat")

(declare-function eat-term-send-string "eat")

(declare-function claude-code-ide--terminal-send-string "claude-code-ide")

(declare-function claude-code-ide--terminal-send-return "claude-code-ide")

(declare-function claude-code-ide--create-terminal-session "claude-code-ide")

(declare-function claude-code-ide-mcp-server-ensure-server "claude-code-ide-mcp-server")

(declare-function hive-mcp-ellama-dispatch "hive-mcp-ellama")

(declare-function hive-mcp-swarm-events-emit-auto-started "hive-mcp-swarm-events")

(declare-function hive-mcp-swarm-events-emit-auto-error "hive-mcp-swarm-events")

(declare-function hive-mcp-swarm-events-emit-auto-completed "hive-mcp-swarm-events")

(declare-function hive-mcp-swarm-events-emit-idle-timeout "hive-mcp-swarm-events")

(declare-function hive-mcp-swarm-events-emit-prompt-stall "hive-mcp-swarm-events")

(declare-function hive-mcp-swarm-prompts-find-pending "hive-mcp-swarm-prompts")

(declare-function hive-mcp-swarm-prompts--send-desktop-notification "hive-mcp-swarm-prompts")

(declare-function hive-mcp-swarm-events-emit-ling-ready-for-wrap "hive-mcp-swarm-events")

(defvar hive-mcp-swarm--slaves)

(defvar-local hive-mcp-swarm-terminal--working-p nil "Non-nil when the terminal is actively processing a task.")

(defvar-local hive-mcp-swarm-terminal--task-start-time nil "Time when the current task started (float-time).")

(defvar-local hive-mcp-swarm-terminal--pending-prompt nil "The prompt text that was sent, for completion detection.")

(defgroup hive-mcp-swarm-terminal nil
  "Terminal backend settings for swarm."
  :group 'hive-mcp-swarm
  :prefix "hive-mcp-swarm-terminal-")

(defcustom hive-mcp-swarm-terminal-backend 'claude-code-ide
  "Terminal backend for slave sessions."
  :group 'hive-mcp-swarm-terminal
  :type '(choice (const :tag "claude-code-ide (recommended)" claude-code-ide) (const :tag "vterm" vterm) (const :tag "eat (experimental)" eat)))

(defcustom hive-mcp-swarm-terminal-send-delay 0.1
  "Delay in seconds between send-string and send-return."
  :group 'hive-mcp-swarm-terminal
  :type 'float)

(defcustom hive-mcp-swarm-terminal-ready-timeout 10
  "Seconds to wait for terminal to become ready."
  :group 'hive-mcp-swarm-terminal
  :type 'integer)

(defcustom hive-mcp-swarm-terminal-prompt-marker "â¯"
  "Marker indicating Claude CLI is ready for input."
  :group 'hive-mcp-swarm-terminal
  :type 'string)

(defcustom hive-mcp-swarm-terminal-ready-search-window 1500
  "Number of characters from buffer end to search for ready marker."
  :group 'hive-mcp-swarm-terminal
  :type 'integer)

(defcustom hive-mcp-swarm-terminal-auto-shout t
  "If non-nil, automatically emit hivemind shout when lings complete tasks."
  :group 'hive-mcp-swarm-terminal
  :type 'boolean)

(defcustom hive-mcp-swarm-terminal-completion-poll-interval 1.0
  "Interval in seconds between completion checks for working buffers."
  :group 'hive-mcp-swarm-terminal
  :type 'float)

(defcustom hive-mcp-swarm-terminal-error-patterns '(("Error:" . "cli-error") ("error:" . "cli-error") ("ERROR" . "cli-error") ("failed with exit code" . "tool-error") ("Command failed" . "tool-error") ("Traceback (most recent" . "tool-error") ("Exception:" . "tool-error") ("Panic:" . "tool-error") ("API error" . "api-error") ("rate limit" . "api-error") ("authentication failed" . "api-error") ("Killed" . "process-error") ("Segmentation fault" . "process-error") ("Out of memory" . "process-error"))
  "Alist of (PATTERN . ERROR-TYPE) for detecting errors in terminal output."
  :group 'hive-mcp-swarm-terminal
  :type '(alist :key-type string :value-type string))

(defcustom hive-mcp-swarm-terminal-error-search-lines 100
  "Number of lines to search for error patterns in terminal output."
  :group 'hive-mcp-swarm-terminal
  :type 'integer)

(defcustom hive-mcp-swarm-terminal-idle-timeout 30.0
  "Seconds of inactivity before a working slave is considered idle."
  :group 'hive-mcp-swarm-terminal
  :type 'float)

(defcustom hive-mcp-swarm-terminal-idle-poll-interval 5.0
  "Interval in seconds between idle detection checks."
  :group 'hive-mcp-swarm-terminal
  :type 'float)

(defcustom hive-mcp-swarm-terminal-auto-wrap t
  "If non-nil, automatically trigger wrap when lings complete tasks."
  :group 'hive-mcp-swarm-terminal
  :type 'boolean)

(defcustom hive-mcp-swarm-terminal-lazy-render t
  "If non-nil, only flush process output for visible vterm buffers."
  :group 'hive-mcp-swarm-terminal
  :type 'boolean)

(defcustom hive-mcp-swarm-terminal-lazy-render-interval 10
  "Ticks between forced flushes for invisible buffers."
  :group 'hive-mcp-swarm-terminal
  :type 'integer)

(defvar hive-mcp-swarm-terminal--completion-timer nil
  "Timer for polling task completion across all working slave buffers.")

(defvar hive-mcp-swarm-terminal--completion-callback nil
  "Callback to invoke when task completion is detected.")

(defvar hive-mcp-swarm-terminal--activity-timestamps (make-hash-table :test 'equal)
  "Hash of slave-id -> last-activity-timestamp (float-time).")

(defvar hive-mcp-swarm-terminal--last-shout-timestamps (make-hash-table :test 'equal)
  "Hash of slave-id -> last-shout-timestamp (float-time).")

(defvar hive-mcp-swarm-terminal--idle-timer nil
  "Timer for polling idle detection across working slaves.")

(defvar hive-mcp-swarm-terminal--idle-emitted (make-hash-table :test 'equal)
  "Hash of slave-id -> t for slaves that have already had idle event emitted.")

(defvar hive-mcp-swarm-terminal--buffer-sizes (make-hash-table :test 'equal)
  "Hash of slave-id -> last-known-buffer-size.")

(defvar hive-mcp-swarm-terminal--wrapped-sessions (make-hash-table :test 'equal)
  "Hash of slave-id -> t for sessions that have already been auto-wrapped.")

(defvar hive-mcp-swarm-terminal--lazy-tick-count 0
  "Counter for lazy render ticks.")

(defun hive-mcp-swarm-terminal-backend-available-p (backend)
  "Check if BACKEND is available."
  (pcase backend
  ((quote claude-code-ide) (require 'claude-code-ide nil t))
  ((quote vterm) (and (require 'vterm nil t) (fboundp 'vterm-mode) (fboundp 'vterm-send-string)))
  ((quote eat) (require 'eat nil t))
  ('_ nil)))

(defun hive-mcp-swarm-terminal-detect-buffer-backend (buffer)
  "Detect terminal backend used in BUFFER."
  (when (buffer-live-p buffer)
    (with-current-buffer buffer
    (cond
  (((and (derived-mode-p 'vterm-mode) (bound-and-true-p claude-code-ide-session-id)) 'claude-code-ide) ((derived-mode-p 'vterm-mode) 'vterm))
  (((derived-mode-p 'eat-mode) 'eat) (t nil))))))

(defun hive-mcp-swarm-terminal---find-slave-by-buffer (buffer)
  "Find slave-id that owns BUFFER by iterating slaves hash."
  (when (and (buffer-live-p buffer) (boundp 'hive-mcp-swarm--slaves) (hash-table-p hive-mcp-swarm--slaves))
    (catch 'found (maphash (lambda (id slave)
    (when (eq (plist-get slave :buffer) buffer)
    (signal 'error 'found))) hive-mcp-swarm--slaves) nil)))

(defun hive-mcp-swarm-terminal---buffer-visible-p (buffer)
  "Return non-nil if BUFFER is displayed in any window across all frames."
  (and (buffer-live-p buffer) (get-buffer-window buffer t)))

(defun hive-mcp-swarm-terminal---should-flush-p (buffer)
  "Return non-nil if BUFFER should have its process output flushed."
  (or (not hive-mcp-swarm-terminal-lazy-render) (hive-mcp-swarm-terminal---buffer-visible-p buffer) (zerop (mod hive-mcp-swarm-terminal--lazy-tick-count (max 1 hive-mcp-swarm-terminal-lazy-render-interval)))))

(defun hive-mcp-swarm-terminal---flush-buffer (buffer)
  "Flush pending process output for BUFFER if it should be flushed.\nReturns non-nil if a flush was actually performed."
  (when (and (buffer-live-p buffer) (hive-mcp-swarm-terminal---should-flush-p buffer))
    (when-let-star (list proc (get-buffer-process buffer)) (accept-process-output proc 0.01) t)))

(defun hive-mcp-swarm-terminal---on-window-buffer-change (frame)
  "Flush pending output for newly-visible swarm terminal buffers in FRAME."
  (when hive-mcp-swarm-terminal-lazy-render
    (walk-windows (lambda (win)
    (let* ((buf (window-buffer win)))
    (when (buffer-live-p buf)
    (when-let-star (list proc (get-buffer-process buf)) (accept-process-output proc 0.1))))) nil frame)))

(defun hive-mcp-swarm-terminal---detect-error (buffer)
  "Detect error patterns in BUFFER's recent output.\nReturns (ERROR-TYPE . ERROR-PREVIEW) if error found, nil otherwise."
  (when (buffer-live-p buffer)
    (with-current-buffer buffer
    (save-excursion
    (goto-char (point-max))
    (let* ((search-start (save-excursion
    (forward-line (- hive-mcp-swarm-terminal-error-search-lines))
    (point)))
        (recent-text (buffer-substring-no-properties search-start (point-max))))
    (catch 'found-error (dolist (pattern-pair hive-mcp-swarm-terminal-error-patterns)
    (let* ((pattern (car pattern-pair))
        (error-type (cdr pattern-pair)))
    (when (string-match-p (regexp-quote pattern) recent-text)
    (let* ((error-preview (when (string-match (clel-concat "^.*" (regexp-quote pattern) ".*$") recent-text)
    (substring recent-text (match-beginning 0) (min (match-end 0) (+ (match-beginning 0) 200))))))
    (signal 'error 'found-error))))) nil))))))

(defun hive-mcp-swarm-terminal---truncate-for-preview (text max-length)
  "Truncate TEXT to MAX-LENGTH chars, adding ellipsis if needed."
  (if (and text (> (length text) max-length)) (clel-concat (substring text 0 (- max-length 3)) "...") (or text "")))

(defun hive-mcp-swarm-terminal---send-vterm (buffer text)
  "Send TEXT to vterm BUFFER, then return. Non-blocking."
  (with-current-buffer buffer
    (vterm-send-string text)
    (run-at-time hive-mcp-swarm-terminal-send-delay nil (lambda (_unused)
    (condition-case err
    (when (buffer-live-p buffer)
    (with-current-buffer buffer
    (vterm-send-return)))
  (error (message "[swarm-terminal] Timer error in vterm send-return: %s" (error-message-string err))))))))

(defun hive-mcp-swarm-terminal---send-eat (buffer text)
  "Send TEXT to eat BUFFER, then return. Non-blocking."
  (with-current-buffer buffer
    (when (and (boundp 'eat-terminal) eat-terminal)
    (eat-term-send-string eat-terminal text)
    (run-at-time hive-mcp-swarm-terminal-send-delay nil (lambda (_unused)
    (condition-case err
    (when (and (buffer-live-p buffer) (boundp 'eat-terminal) eat-terminal)
    (with-current-buffer buffer
    (eat-term-send-string eat-terminal "\r")))
  (error (message "[swarm-terminal] Timer error in eat send-return: %s" (error-message-string err)))))))))

(defun hive-mcp-swarm-terminal---send-ollama (buffer text)
  "Send TEXT to Ollama via ellama. Non-blocking.\nBUFFER is the swarm worker buffer (used for logging)."
  (let* ((slave-id (hive-mcp-swarm-terminal---find-slave-by-buffer buffer))
        (slave (and slave-id (gethash slave-id hive-mcp-swarm--slaves)))
        (model (or (and slave (plist-get slave :model)) "devstral-small-2")))
    (if (fboundp 'hive-mcp-ellama-dispatch) (hive-mcp-ellama-dispatch text model (lambda (response)
    (when (buffer-live-p buffer)
    (with-current-buffer buffer
    (goto-char (point-max))
    (insert (format "\n--- Ollama Response ---\n%s\n" response))))
    (when slave
    (plist-put slave :last-response response)
    (plist-put slave :status 'idle)))) (error "hive-mcp-ellama not available"))))

(defun hive-mcp-swarm-terminal---send-claude-code-ide (buffer text)
  "Send TEXT via claude-code-ide abstraction.\nBlocking is OK for individual slaves since they're isolated."
  (with-current-buffer buffer
    (if (fboundp 'claude-code-ide--terminal-send-string) (let* ((text-lines (length (split-string text "\n")))
        (paste-delay (min 2.0 (+ 0.1 (* 0.01 text-lines)))))
    (claude-code-ide--terminal-send-string text)
    (sit-for paste-delay)
    (when (fboundp 'claude-code-ide--terminal-send-return)
    (claude-code-ide--terminal-send-return))) (error "claude-code-ide terminal functions not available"))))

(defun hive-mcp-swarm-terminal-send (buffer text &optional backend)
  "Send TEXT to terminal BUFFER using BACKEND. NON-BLOCKING.\nReturns immediately - uses timers for delayed operations."
  (unless (buffer-live-p buffer)
    (error "Terminal buffer is dead"))
  (with-current-buffer buffer
    (setq-local hive-mcp-swarm-terminal--working-p t)
    (setq-local hive-mcp-swarm-terminal--task-start-time (float-time))
    (setq-local hive-mcp-swarm-terminal--pending-prompt text))
  (when hive-mcp-swarm-terminal-auto-shout
    (when-let-star (list slave-id (hive-mcp-swarm-terminal---find-slave-by-buffer buffer)) (hive-mcp-swarm-terminal-record-activity slave-id) (let* ((task-preview (hive-mcp-swarm-terminal---truncate-for-preview text 100)))
    (when (fboundp 'hive-mcp-swarm-events-emit-auto-started)
    (hive-mcp-swarm-events-emit-auto-started slave-id task-preview))
    (message "[swarm-terminal] Auto-shout: %s started task" slave-id))))
  (let* ((backend (or backend (hive-mcp-swarm-terminal-detect-buffer-backend buffer) hive-mcp-swarm-terminal-backend)))
    (pcase backend
  ((quote claude-code-ide) (hive-mcp-swarm-terminal---send-claude-code-ide buffer text))
  ((quote vterm) (hive-mcp-swarm-terminal---send-vterm buffer text))
  ((quote eat) (hive-mcp-swarm-terminal---send-eat buffer text))
  ((quote ollama) (hive-mcp-swarm-terminal---send-ollama buffer text))
  ('_ (error "Unknown terminal backend: %s" backend)))))

(defun hive-mcp-swarm-terminal-ready-p (buffer)
  "Check if terminal BUFFER is ready for input (non-blocking check)."
  (when (buffer-live-p buffer)
    (with-current-buffer buffer
    (save-excursion
    (goto-char (point-max))
    (let* ((search-start (max (point-min) (- (point-max) hive-mcp-swarm-terminal-ready-search-window))))
    (search-backward hive-mcp-swarm-terminal-prompt-marker search-start t))))))

(defun hive-mcp-swarm-terminal-wait-ready (buffer callback &optional timeout-secs)
  "Wait for BUFFER to be ready, then call CALLBACK. NON-BLOCKING.\nUses timer-based polling instead of blocking sit-for loop.\nCALLBACK receives (buffer success-p) arguments."
  (let* ((timeout (or timeout-secs hive-mcp-swarm-terminal-ready-timeout))
        (start-time (float-time))
        (check-interval 0.2)
        (timer nil))
    (setq timer (run-with-timer 0 check-interval (lambda (_unused)
    (condition-case err
    (cond
  (((not (buffer-live-p buffer)) (cancel-timer timer) (funcall callback buffer nil)) ((hive-mcp-swarm-terminal-ready-p buffer) (cancel-timer timer) (funcall callback buffer t))))
  (error (cancel-timer timer)
      (message "[swarm-terminal] Timer error in wait-ready: %s" (error-message-string err))
      (ignore-errors (funcall callback buffer nil)))))))))

(defun hive-mcp-swarm-terminal-create-buffer (name dir backend &optional slave-id)
  "Create terminal buffer NAME in DIR using BACKEND.\nReturns the buffer (async startup - may not be immediately ready)."
  (unless (hive-mcp-swarm-terminal-backend-available-p backend)
    (error "Terminal backend not available: %s" backend))
  (let* ((default-directory dir))
    (pcase backend
  ((quote claude-code-ide) (let* ((port (when (fboundp 'claude-code-ide-mcp-server-ensure-server)
    (claude-code-ide-mcp-server-ensure-server)))
        (_ (unless port
    (error "Failed to start MCP server")))
        (result (claude-code-ide--create-terminal-session name dir port nil nil slave-id)))
    (car result)))
  ((quote vterm) (let* ((buf (generate-new-buffer name)))
    (with-current-buffer buf
    (vterm-mode))
    buf))
  ((quote eat) (let* ((buf (generate-new-buffer name)))
    (with-current-buffer buf
    (eat-mode)
    (eat-exec buf "swarm-shell" "/bin/bash" nil '("-l")))
    buf)))))

(defun hive-mcp-swarm-terminal-kill-buffer (buffer)
  "Kill terminal BUFFER without prompts.\nHandles process cleanup to prevent confirmation dialogs."
  (when (buffer-live-p buffer)
    (with-current-buffer buffer
    (set-buffer-modified-p nil)
    (when-let-star (list proc (get-buffer-process buffer)) (set-process-query-on-exit-flag proc nil))
    (when (and (boundp 'vterm--process) (processp vterm--process) (process-live-p vterm--process))
    (set-process-query-on-exit-flag vterm--process nil)))
    (let* ((kill-buffer-query-functions nil)
        (kill-buffer-hook nil)
        (vterm-exit-functions nil))
    (hive-mcp-swarm-terminal-kill-buffer buffer))))

(defun hive-mcp-swarm-terminal---check-buffer-completion (buffer)
  "Check if BUFFER has completed its task (working -> ready transition).\nReturns a plist with completion info if done, nil otherwise."
  (when (buffer-live-p buffer)
    (with-current-buffer buffer
    (hive-mcp-swarm-terminal---flush-buffer buffer)
    (when (and hive-mcp-swarm-terminal--working-p (hive-mcp-swarm-terminal-ready-p buffer))
    (let* ((slave-id (hive-mcp-swarm-terminal---find-slave-by-buffer buffer))
        (start-time hive-mcp-swarm-terminal--task-start-time)
        (duration (when start-time
    (- (float-time) start-time)))
        (error-info (hive-mcp-swarm-terminal---detect-error buffer))
        (status (if error-info "error" "completed")))
    (setq-local hive-mcp-swarm-terminal--working-p nil)
    (setq-local hive-mcp-swarm-terminal--task-start-time nil)
    (setq-local hive-mcp-swarm-terminal--pending-prompt nil)
    (when slave-id
    (if error-info (list :slave-id slave-id :duration duration :status status :error-type (car error-info) :error-preview (cdr error-info)) (list :slave-id slave-id :duration duration :status status))))))))

(defun hive-mcp-swarm-terminal---check-buffer-activity (slave-id buffer)
  "Check if BUFFER has new output since last check for SLAVE-ID.\nReturns t if activity was recorded, nil otherwise."
  (when (buffer-live-p buffer)
    (hive-mcp-swarm-terminal---flush-buffer buffer)
    (let* ((current-size (buffer-size buffer))
        (last-size (gethash slave-id hive-mcp-swarm-terminal--buffer-sizes 0)))
    (puthash slave-id current-size hive-mcp-swarm-terminal--buffer-sizes)
    (when (> current-size last-size)
    (hive-mcp-swarm-terminal-record-activity slave-id)
    t))))

(defun hive-mcp-swarm-terminal---completion-watcher-tick ()
  "Check all working slave buffers for completion.\nCalled periodically by the completion watcher timer."
  (condition-case err
    (when (and hive-mcp-swarm-terminal-auto-shout (boundp 'hive-mcp-swarm--slaves) (hash-table-p hive-mcp-swarm--slaves))
    (cl-incf hive-mcp-swarm-terminal--lazy-tick-count)
    (maphash (lambda (slave-id slave)
    (when-let-star (list buffer (plist-get slave :buffer)) (hive-mcp-swarm-terminal---check-buffer-activity slave-id buffer))
    (when-let-star (list buffer (plist-get slave :buffer) completion-info (hive-mcp-swarm-terminal---check-buffer-completion buffer)) (let* ((completed-slave-id (plist-get completion-info :slave-id))
        (duration (plist-get completion-info :duration))
        (status (plist-get completion-info :status))
        (error-type (plist-get completion-info :error-type))
        (error-preview (plist-get completion-info :error-preview)))
    (if (string= status "error") (progn
  (when (fboundp 'hive-mcp-swarm-events-emit-auto-error)
    (hive-mcp-swarm-events-emit-auto-error completed-slave-id duration error-type error-preview))
  (message "[swarm-terminal] Auto-shout: %s error detected (%s, %.1fs)" completed-slave-id error-type (or duration 0))) (when (fboundp 'hive-mcp-swarm-events-emit-auto-completed)
    (hive-mcp-swarm-events-emit-auto-completed completed-slave-id duration status)))
    (when (functionp hive-mcp-swarm-terminal--completion-callback)
    (funcall hive-mcp-swarm-terminal--completion-callback buffer completed-slave-id duration status error-type error-preview))))) hive-mcp-swarm--slaves))
  (error (message "[swarm-terminal] Completion watcher tick error: %s" (error-message-string err)))))

(defun hive-mcp-swarm-terminal-start-completion-watcher (callback)
  "Start the completion watcher timer with CALLBACK.\nCALLBACK is called with (buffer slave-id duration-secs) on completion."
  (hive-mcp-swarm-terminal-stop-completion-watcher)
  (setq hive-mcp-swarm-terminal--completion-callback callback)
  (setq hive-mcp-swarm-terminal--lazy-tick-count 0)
  (setq hive-mcp-swarm-terminal--completion-timer (run-with-timer hive-mcp-swarm-terminal-completion-poll-interval hive-mcp-swarm-terminal-completion-poll-interval #'hive-mcp-swarm-terminal--completion-watcher-tick))
  (when hive-mcp-swarm-terminal-lazy-render
    (add-hook 'window-buffer-change-functions #'hive-mcp-swarm-terminal--on-window-buffer-change))
  (message "[swarm-terminal] Completion watcher started (interval: %.1fs, lazy: %s)" hive-mcp-swarm-terminal-completion-poll-interval (if hive-mcp-swarm-terminal-lazy-render "on" "off")))

(defun hive-mcp-swarm-terminal-stop-completion-watcher ()
  "Stop the completion watcher timer and clean up lazy render hook."
  (when hive-mcp-swarm-terminal--completion-timer
    (cancel-timer hive-mcp-swarm-terminal--completion-timer)
    (setq hive-mcp-swarm-terminal--completion-timer nil)
    (setq hive-mcp-swarm-terminal--completion-callback nil)
    (setq hive-mcp-swarm-terminal--lazy-tick-count 0)
    (remove-hook 'window-buffer-change-functions #'hive-mcp-swarm-terminal--on-window-buffer-change)
    (message "[swarm-terminal] Completion watcher stopped")))

(defun hive-mcp-swarm-terminal-reset-working-state (buffer)
  "Reset working state for BUFFER."
  (when (buffer-live-p buffer)
    (with-current-buffer buffer
    (setq-local hive-mcp-swarm-terminal--working-p nil)
    (setq-local hive-mcp-swarm-terminal--task-start-time nil)
    (setq-local hive-mcp-swarm-terminal--pending-prompt nil))))

(defun hive-mcp-swarm-terminal-record-activity (slave-id)
  "Record that SLAVE-ID had terminal activity (output)."
  (puthash slave-id (float-time) hive-mcp-swarm-terminal--activity-timestamps)
  (remhash slave-id hive-mcp-swarm-terminal--idle-emitted))

(defun hive-mcp-swarm-terminal---get-activity-timestamp (slave-id)
  "Get the last activity timestamp for SLAVE-ID, or nil if none."
  (gethash slave-id hive-mcp-swarm-terminal--activity-timestamps))

(defun hive-mcp-swarm-terminal-record-shout (slave-id)
  "Record that SLAVE-ID sent a hivemind_shout."
  (puthash slave-id (float-time) hive-mcp-swarm-terminal--last-shout-timestamps)
  (remhash slave-id hive-mcp-swarm-terminal--idle-emitted))

(defun hive-mcp-swarm-terminal---get-shout-timestamp (slave-id)
  "Get the last shout timestamp for SLAVE-ID, or nil if none."
  (gethash slave-id hive-mcp-swarm-terminal--last-shout-timestamps))

(defun hive-mcp-swarm-terminal---slave-idle-p (slave-id)
  "Check if SLAVE-ID is considered idle based on timestamps."
  (let* ((now (float-time))
        (activity-time (hive-mcp-swarm-terminal---get-activity-timestamp slave-id))
        (shout-time (hive-mcp-swarm-terminal---get-shout-timestamp slave-id))
        (timeout hive-mcp-swarm-terminal-idle-timeout))
    (when activity-time
    (let* ((activity-age (- now activity-time))
        (shout-age (if shout-time (- now shout-time) most-positive-fixnum)))
    (and (> activity-age timeout) (> shout-age timeout))))))

(defun hive-mcp-swarm-terminal---slave-needs-idle-event-p (slave-id)
  "Check if SLAVE-ID needs an idle-timeout event emitted."
  (and (not (gethash slave-id hive-mcp-swarm-terminal--idle-emitted)) (hive-mcp-swarm-terminal---slave-idle-p slave-id) (when (and (boundp 'hive-mcp-swarm--slaves) (hash-table-p hive-mcp-swarm--slaves))
    (let* ((slave (gethash slave-id hive-mcp-swarm--slaves)))
    (eq (plist-get slave :status) 'working)))))

(defun hive-mcp-swarm-terminal-clear-slave-timestamps (slave-id)
  "Clear all timestamp records for SLAVE-ID.\nCalled when a slave is killed."
  (remhash slave-id hive-mcp-swarm-terminal--activity-timestamps)
  (remhash slave-id hive-mcp-swarm-terminal--last-shout-timestamps)
  (remhash slave-id hive-mcp-swarm-terminal--idle-emitted)
  (remhash slave-id hive-mcp-swarm-terminal--buffer-sizes))

(defun hive-mcp-swarm-terminal---idle-watcher-tick ()
  "Check all working slaves for idle timeout.\nCalled periodically by the idle watcher timer."
  (condition-case err
    (when (and (boundp 'hive-mcp-swarm--slaves) (hash-table-p hive-mcp-swarm--slaves))
    (maphash (lambda (_slave-id slave)
    (when-let-star (list buffer (plist-get slave :buffer)) (when (buffer-live-p buffer)
    (hive-mcp-swarm-terminal---flush-buffer buffer)))) hive-mcp-swarm--slaves)
    (maphash (lambda (slave-id _slave)
    (when (hive-mcp-swarm-terminal---slave-needs-idle-event-p slave-id)
    (puthash slave-id t hive-mcp-swarm-terminal--idle-emitted)
    (let* ((activity-time (hive-mcp-swarm-terminal---get-activity-timestamp slave-id))
        (idle-duration (if activity-time (- (float-time) activity-time) 0))
        (pending-prompt (when (fboundp 'hive-mcp-swarm-prompts-find-pending)
    (hive-mcp-swarm-prompts-find-pending slave-id)))
        (prompt-text (and pending-prompt (plist-get pending-prompt :prompt))))
    (if pending-prompt (progn
  (when (fboundp 'hive-mcp-swarm-events-emit-prompt-stall)
    (hive-mcp-swarm-events-emit-prompt-stall slave-id idle-duration prompt-text))
  (when (fboundp 'hive-mcp-swarm-prompts--send-desktop-notification)
    (hive-mcp-swarm-prompts--send-desktop-notification (format "STALLED: %s" slave-id) (format "Waiting %.0fs for response: %s" idle-duration (truncate-string-to-width (or prompt-text "") 80))))
  (message "[swarm-terminal] Layer 2: %s PROMPT-STALL for %.1fs - coordinator must respond!" slave-id idle-duration)) (progn
  (when (fboundp 'hive-mcp-swarm-events-emit-idle-timeout)
    (hive-mcp-swarm-events-emit-idle-timeout slave-id idle-duration))
  (message "[swarm-terminal] Layer 2: %s idle for %.1fs without shout" slave-id idle-duration)))))) hive-mcp-swarm--slaves))
  (error (message "[swarm-terminal] Idle watcher tick error: %s" (error-message-string err)))))

(defun hive-mcp-swarm-terminal-start-idle-watcher ()
  "Start the idle detection watcher timer."
  (hive-mcp-swarm-terminal-stop-idle-watcher)
  (setq hive-mcp-swarm-terminal--idle-timer (run-with-timer hive-mcp-swarm-terminal-idle-poll-interval hive-mcp-swarm-terminal-idle-poll-interval #'hive-mcp-swarm-terminal--idle-watcher-tick))
  (message "[swarm-terminal] Layer 2 idle watcher started (timeout: %.0fs, interval: %.0fs)" hive-mcp-swarm-terminal-idle-timeout hive-mcp-swarm-terminal-idle-poll-interval))

(defun hive-mcp-swarm-terminal-stop-idle-watcher ()
  "Stop the idle detection watcher timer."
  (when hive-mcp-swarm-terminal--idle-timer
    (cancel-timer hive-mcp-swarm-terminal--idle-timer)
    (setq hive-mcp-swarm-terminal--idle-timer nil)
    (message "[swarm-terminal] Layer 2 idle watcher stopped")))

(defun hive-mcp-swarm-terminal-reset-idle-state ()
  "Reset all idle detection state."
  (clrhash hive-mcp-swarm-terminal--activity-timestamps)
  (clrhash hive-mcp-swarm-terminal--last-shout-timestamps)
  (clrhash hive-mcp-swarm-terminal--idle-emitted)
  (clrhash hive-mcp-swarm-terminal--buffer-sizes))

(defun hive-mcp-swarm-terminal---session-wrapped-p (slave-id)
  "Check if SLAVE-ID has already been auto-wrapped this session."
  (gethash slave-id hive-mcp-swarm-terminal--wrapped-sessions))

(defun hive-mcp-swarm-terminal---mark-session-wrapped (slave-id)
  "Mark SLAVE-ID as having been auto-wrapped."
  (puthash slave-id t hive-mcp-swarm-terminal--wrapped-sessions))

(defun hive-mcp-swarm-terminal---should-auto-wrap-p (slave-id)
  "Check if SLAVE-ID should trigger auto-wrap."
  (and hive-mcp-swarm-terminal-auto-wrap (not (hive-mcp-swarm-terminal---session-wrapped-p slave-id)) (when (and (boundp 'hive-mcp-swarm--slaves) (hash-table-p hive-mcp-swarm--slaves))
    (let* ((slave (gethash slave-id hive-mcp-swarm--slaves)))
    (and slave (not (eq (plist-get slave :status) 'working)))))))

(defun hive-mcp-swarm-terminal-trigger-auto-wrap (slave-id reason)
  "Trigger auto-wrap for SLAVE-ID with REASON.\nReturns t if wrap was triggered, nil if already wrapped or disabled."
  (when (hive-mcp-swarm-terminal---should-auto-wrap-p slave-id)
    (hive-mcp-swarm-terminal---mark-session-wrapped slave-id)
    (when (fboundp 'hive-mcp-swarm-events-emit-ling-ready-for-wrap)
    (hive-mcp-swarm-events-emit-ling-ready-for-wrap slave-id reason))
    (message "[swarm-terminal] Auto-wrap triggered for %s (reason: %s)" slave-id reason)
    t))

(defun hive-mcp-swarm-terminal-reset-wrap-state ()
  "Reset all auto-wrap state."
  (clrhash hive-mcp-swarm-terminal--wrapped-sessions))

(defun hive-mcp-swarm-terminal-clear-slave-wrap-state (slave-id)
  "Clear wrap state for SLAVE-ID."
  (remhash slave-id hive-mcp-swarm-terminal--wrapped-sessions))

(provide 'hive-mcp-swarm-terminal)
;;; hive-mcp-swarm-terminal.el ends here
