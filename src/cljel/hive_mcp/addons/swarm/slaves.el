;;; hive-mcp-swarm-slaves.el --- -*- lexical-binding: t; -*-
;; Generated by ClojureElisp

(require 'clojure-elisp-runtime)

;;; Code:



(require 'cl-lib)

(declare-function vterm "vterm")

(declare-function vterm-mode "vterm")

(declare-function vterm-send-string "vterm")

(declare-function vterm-send-return "vterm")

(declare-function eat "eat")

(declare-function eat-mode "eat")

(declare-function eat-exec "eat")

(declare-function eat-term-send-string "eat")

(declare-function claude-code-ide "claude-code-ide")

(declare-function claude-code-ide--create-terminal-session "claude-code-ide")

(declare-function claude-code-ide-mcp-server-ensure-server "claude-code-ide-mcp-server")

(declare-function hive-mcp-ellama-swarm-spawn "hive-mcp-ellama")

(declare-function hive-mcp-ellama-swarm-dispatch "hive-mcp-ellama")

(declare-function hive-mcp-swarm-terminal-send "hive-mcp-swarm-terminal")

(declare-function hive-mcp-swarm-presets-build-system-prompt "hive-mcp-swarm-presets")

(declare-function hive-mcp-swarm-presets-role-to-presets "hive-mcp-swarm-presets")

(declare-function hive-mcp-swarm-presets-role-to-tier "hive-mcp-swarm-presets")

(declare-function hive-mcp-swarm-presets-merge-defaults "hive-mcp-swarm-presets")

(declare-function hive-mcp-swarm-prompts-clear-slave "hive-mcp-swarm-prompts")

(declare-function hive-mcp-swarm-events-emit-slave-spawned "hive-mcp-swarm-events")

(declare-function hive-mcp-swarm-events-emit-slave-killed "hive-mcp-swarm-events")

(defvar hive-mcp-swarm--slaves nil)

(defvar hive-mcp-swarm--task-counter nil)

(defvar hive-mcp-swarm--session-id nil)

(defvar hive-mcp-swarm--current-depth nil)

(defvar hive-mcp-swarm--ancestry nil)

(defvar hive-mcp-swarm-max-slaves nil)

(defvar hive-mcp-swarm-max-depth nil)

(defvar hive-mcp-swarm-rate-limit-window nil)

(defvar hive-mcp-swarm-rate-limit-max-spawns nil)

(defvar hive-mcp-swarm-terminal nil)

(defvar hive-mcp-swarm-buffer-prefix nil)

(defvar hive-mcp-swarm-claude-command nil)

(defvar hive-mcp-swarm-prompt-mode nil)

(declare-function hive-mcp-swarm-list-presets "hive-mcp-swarm")

(defvar hive-mcp-swarm-slaves--spawn-timestamps nil)

(defun hive-mcp-swarm-slaves-generate-id (name)
  "Generate unique slave ID for NAME."
  (format "swarm-%s-%d" name (floor (float-time))))

(defun hive-mcp-swarm-slaves-generate-task-id (slave-id)
  "Generate unique task ID for SLAVE-ID."
  (cl-incf hive-mcp-swarm--task-counter)
  (format "task-%s-%03d" (replace-regexp-in-string "^swarm-" "" slave-id) hive-mcp-swarm--task-counter))

(defun hive-mcp-swarm-slaves---depth-label (depth)
  "Return human-readable label for DEPTH level."
  (pcase depth
  (0 "master")
  (1 "child")
  (2 "grandchild")
  (3 "great-grandchild")
  ('_ (format "depth-%d" depth))))

(defun hive-mcp-swarm-slaves-check-depth ()
  "Check if we can spawn at current depth.\nReturns the current depth if allowed, signals error if blocked."
  (let* ((depth (string-to-number (or (getenv "CLAUDE_SWARM_DEPTH") "0")))
        (master-id (getenv "CLAUDE_SWARM_MASTER"))
        (my-id (getenv "CLAUDE_SWARM_SLAVE_ID")))
    (setq hive-mcp-swarm--current-depth depth)
    (when (and my-id master-id)
    (push (cons my-id master-id) hive-mcp-swarm--ancestry))
    (when (>= depth hive-mcp-swarm-max-depth)
    (error "Recursion limit reached: %s (depth %d) cannot spawn children.\nMaximum depth is %d (master -> child -> grandchild -> great-grandchild).\nThis limit prevents runaway recursive spawning." (-depth-label depth) depth hive-mcp-swarm-max-depth))
    depth))

(defun hive-mcp-swarm-slaves-check-rate-limit ()
  "Check if spawn rate limit allows a new spawn.\nRemoves old timestamps and checks count within window."
  (let* ((now (float-time))
        (window-start (- now hive-mcp-swarm-rate-limit-window)))
    (setq hive-mcp-swarm-slaves--spawn-timestamps (cl-remove-if (lambda (ts)
    (< ts window-start)) hive-mcp-swarm-slaves--spawn-timestamps))
    (when (>= (length hive-mcp-swarm-slaves--spawn-timestamps) hive-mcp-swarm-rate-limit-max-spawns)
    (error "Rate limit exceeded: %d spawns in %d seconds.\nWait before spawning more slaves to prevent spawn storms." hive-mcp-swarm-rate-limit-max-spawns hive-mcp-swarm-rate-limit-window))
    (push now hive-mcp-swarm-slaves--spawn-timestamps)))

(defun hive-mcp-swarm-slaves-check-limit ()
  "Check if we can spawn more slaves."
  (when (>= (hash-table-count hive-mcp-swarm--slaves) hive-mcp-swarm-max-slaves)
    (error "Maximum slave count (%d) reached.\nKill some slaves with `hive-mcp-swarm-kill' before spawning more." hive-mcp-swarm-max-slaves)))

(defun hive-mcp-swarm-slaves---project-root ()
  "Get current project root."
  (or (when (fboundp 'project-root)
    (when-let-star (list proj (project-current)) (project-root proj))) default-directory))

(cl-defun hive-mcp-swarm-slaves-spawn (name &key presets cwd role terminal backend model kanban-task-id injected-context)
  "Spawn a new Claude slave with NAME - FULLY ASYNC.\n\nPRESETS is a list of preset names to apply.\nCWD is the working directory (defaults to current project root).\nROLE is a predefined role that maps to presets AND tier (backend/model).\nTERMINAL overrides `hive-mcp-swarm-terminal' for this spawn.\nBACKEND explicitly sets the backend.\nMODEL sets the model for ollama backend.\nKANBAN-TASK-ID is the optional kanban task ID to link this ling with.\nINJECTED-CONTEXT is optional pre-generated catchup context.\n\nReturns the slave-id IMMEDIATELY.  The actual spawn happens async."
  (interactive (list (clel-read-string "Slave name: ") :presets (completing-read-multiple "Presets: " (hive-mcp-swarm-list-presets))))
  (hive-mcp-swarm-slaves-check-depth)
  (hive-mcp-swarm-slaves-check-rate-limit)
  (hive-mcp-swarm-slaves-check-limit)
  (when role
    (unless presets
    (setq presets (hive-mcp-swarm-presets-role-to-presets role)))
    (when-let-star (list tier (hive-mcp-swarm-presets-role-to-tier role)) (unless backend
    (setq backend (plist-get tier :backend))) (unless model
    (setq model (plist-get tier :model)))))
  (setq presets (hive-mcp-swarm-presets-merge-defaults (or presets '())))
  (let* ((slave-id (hive-mcp-swarm-slaves-generate-id symbol-name))
        (work-dir (or cwd (-project-root) default-directory))
        (term-backend (or backend terminal hive-mcp-swarm-terminal))
        (parent-id (or (getenv "CLAUDE_SWARM_SLAVE_ID") "master"))
        (spawn-depth (1+ hive-mcp-swarm--current-depth)))
    (puthash slave-id (list :slave-id slave-id :name symbol-name :role role :presets presets :status 'spawning :buffer nil :terminal term-backend :backend term-backend :model model :cwd work-dir :depth spawn-depth :parent-id parent-id :kanban-task-id kanban-task-id :context-injected (not (null injected-context)) :current-task nil :task-queue '() :tasks-completed 0 :tasks-failed 0 :spawned-at (format-time-string "%FT%T%z") :last-activity (format-time-string "%FT%T%z")) hive-mcp-swarm--slaves)
    (message "[swarm] Spawning %s (%s) at depth %d, parent: %s (async)" slave-id (-depth-label spawn-depth) spawn-depth parent-id)
    (hive-mcp-swarm-events-emit-slave-spawned slave-id symbol-name presets work-dir kanban-task-id)
    (let* ((ctx injected-context))
    (run-with-timer 0 nil (lambda (_unused)
    (condition-case err
    (hive-mcp-swarm-slaves--do-spawn-async slave-id symbol-name presets work-dir term-backend ctx)
  (error (when-let-star (list slave (gethash slave-id hive-mcp-swarm--slaves)) (plist-put slave :status 'error) (plist-put slave :error (error-message-string err)))
      (message "[swarm] Spawn error for %s: %s" slave-id (error-message-string err)))))))
    (when (called-interactively-p 'any)
    (message "Spawning slave: %s (async)" slave-id))
    slave-id))

(defun hive-mcp-swarm-slaves---do-spawn-async (slave-id name presets work-dir term-backend &optional injected-context)
  "Actually spawn the slave buffer for SLAVE-ID.\nCalled async from `hive-mcp-swarm-slaves-spawn'."
  (let* ((slave (gethash slave-id hive-mcp-swarm--slaves))
        (buffer-name (format "%s%s*" hive-mcp-swarm-buffer-prefix name))
        (base-prompt (hive-mcp-swarm-presets-build-system-prompt presets injected-context))
        (identity-section (format "## YOUR IDENTITY AND ENVIRONMENT (CRITICAL)\n\n**Your agent ID is: `%s`**\n**Your working directory is: `%s`**\n\nYou MUST use this EXACT ID in ALL hivemind tool calls:\n- `hivemind_shout(agent_id: \"%s\", ...)`\n- `hivemind_ask(agent_id: \"%s\", ...)`\n\nYou MUST use paths relative to your working directory or use the EXACT path above.\n- CORRECT: `src/hive_mcp/foo.clj` or `%s/src/hive_mcp/foo.clj`\n- WRONG: `/Users/...` or `/home/otheruser/...` (DO NOT hallucinate paths!)\n\nDO NOT invent your own ID. DO NOT use short names like \"ling-worker\".\nThe coordinator tracks you by this exact ID.\n\n---\n\n" slave-id work-dir slave-id slave-id work-dir))
        (system-prompt (if base-prompt (clel-concat identity-section base-prompt) identity-section))
        (buffer nil))
    (unless slave
    (error "Slave record not found: %s" slave-id))
    (pcase term-backend
  ((quote claude-code-ide) (unless (require 'claude-code-ide nil t)
    (error "Claude-code-ide is required but not available")))
  ((quote vterm) (unless (and (require 'vterm nil t) (fboundp 'vterm-mode) (fboundp 'vterm-send-string))
    (error "Vterm is required but not available (vterm-mode not bound)")))
  ((quote eat) (unless (require 'eat nil t)
    (error "Eat is required but not available")))
  ((quote ollama) (unless (require 'hive-mcp-ellama nil t)
    (error "hive-mcp-ellama is required but not available"))))
    (plist-put slave :status 'starting)
    (setq buffer (generate-new-buffer buffer-name))
    (plist-put slave :buffer buffer)
    (let* ((default-directory work-dir)
        (process-environment (append (list (format "CLAUDE_SWARM_DEPTH=%d" (plist-get slave :depth)) (format "CLAUDE_SWARM_MASTER=%s" (or hive-mcp-swarm--session-id "direct")) (format "CLAUDE_SWARM_SLAVE_ID=%s" slave-id)) process-environment))
        (permission-flag (pcase hive-mcp-swarm-prompt-mode
  ((quote bypass) "--permission-mode bypassPermissions")
  ('_ "")))
        (claude-cmd (if system-prompt (let* ((prompt-file (make-temp-file "swarm-prompt-" nil ".md")))
    (with-temp-file prompt-file (insert system-prompt))
    (format "cd %s && %s %s --system-prompt %s" (shell-quote-argument work-dir) hive-mcp-swarm-claude-command permission-flag (shell-quote-argument prompt-file))) (format "cd %s && %s %s" (shell-quote-argument work-dir) hive-mcp-swarm-claude-command permission-flag))))
    (pcase term-backend
  ((quote claude-code-ide) (when (buffer-live-p buffer)
    (kill-buffer buffer)) (let* ((prompt-file (when system-prompt
    (let* ((f (make-temp-file "swarm-prompt-" nil ".md")))
    (with-temp-file f (insert system-prompt))
    f)))
        (port (when (fboundp 'claude-code-ide-mcp-server-ensure-server)
    (claude-code-ide-mcp-server-ensure-server)))
        (_ (unless port
    (error "Failed to start MCP server for claude-code-ide backend")))
        (result (claude-code-ide--create-terminal-session buffer-name work-dir port nil nil slave-id prompt-file)))
    (setq buffer (car result))
    (plist-put slave :buffer buffer)
    (plist-put slave :process (cdr result))))
  ((quote vterm) (with-current-buffer buffer
    (vterm-mode)
    (run-at-time 0.5 nil (lambda (_unused)
    (condition-case err
    (when (buffer-live-p buffer)
    (with-current-buffer buffer
    (vterm-send-string claude-cmd)
    (vterm-send-return)))
  (error (message "[swarm] Timer error sending vterm cmd for %s: %s" slave-id (error-message-string err))))))))
  ((quote eat) (with-current-buffer buffer
    (eat-mode)
    (eat-exec buffer "swarm-shell" "/bin/bash" nil '("-l"))) (run-at-time 0.5 nil (lambda (_unused)
    (condition-case err
    (when (buffer-live-p buffer)
    (with-current-buffer buffer
    (when (and (boundp 'eat-terminal) eat-terminal)
    (eat-term-send-string eat-terminal claude-cmd)
    (eat-term-send-string eat-terminal "\r"))))
  (error (message "[swarm] Timer error sending eat cmd for %s: %s" slave-id (error-message-string err)))))))
  ((quote ollama) (when (buffer-live-p buffer)
    (kill-buffer buffer)) (let* ((model (or (plist-get slave :model) (bound-and-true-p hive-mcp-ellama-default-model) "devstral")))
    (hive-mcp-ellama-swarm-spawn slave-id name model)
    (plist-put slave :model model)
    (plist-put slave :backend 'ollama)
    (plist-put slave :status 'idle)))))
    (message "[swarm] Spawned %s buffer created" slave-id)
    (run-at-time 3 nil (lambda (_unused)
    (condition-case err
    (when-let-star (list s (gethash slave-id hive-mcp-swarm--slaves)) (when (memq (plist-get s :status) '(starting spawning))
    (plist-put s :status 'idle)))
  (error (message "[swarm] Timer error transitioning %s to idle: %s" slave-id (error-message-string err))))))))

(defun hive-mcp-swarm-slaves---extract-name-from-id (slave-id)
  "Extract the name portion from SLAVE-ID.\nSlave ID format: swarm-NAME-TIMESTAMP."
  (when (and slave-id (string-match "^swarm-\\(.+\\)-[0-9]+$" slave-id))
    (match-string 1 slave-id)))

(defun hive-mcp-swarm-slaves---valid-kill-target-p (buffer slave-id)
  "Validate BUFFER is a valid kill target for SLAVE-ID.\nReturns t if safe to kill, nil otherwise."
  (when (buffer-live-p buffer)
    (let* ((buf-name (buffer-name buffer))
        (buf-name-lower (downcase buf-name))
        (slave-name (-extract-name-from-id slave-id)))
    (cond
  (((not (string-prefix-p hive-mcp-swarm-buffer-prefix buf-name)) (message "[swarm-kill] BLOCKED: Buffer '%s' lacks swarm prefix for slave %s" buf-name slave-id) nil) ((string-match-p "coordinator" buf-name-lower) (message "[swarm-kill] BLOCKED: Buffer '%s' contains 'coordinator' - refusing to kill" buf-name) nil))
  (((or (string-match-p "\\*claude-code" buf-name-lower) (string-match-p "\\*claude code" buf-name-lower) (string-match-p "master" buf-name-lower)) (message "[swarm-kill] BLOCKED: Buffer '%s' matches coordinator pattern - refusing to kill" buf-name) nil) ((and slave-name (not (string-match-p (regexp-quote slave-name) buf-name))) (message "[swarm-kill] BLOCKED: Buffer '%s' doesn't match slave name '%s' from ID %s" buf-name slave-name slave-id) (message "[swarm-kill] This indicates registry corruption - buffer/slave-id mismatch!") nil))))))

(defun hive-mcp-swarm-slaves-kill (slave-id)
  "Kill slave SLAVE-ID without prompts.\nForce-kills the buffer to prevent blocking on process/unsaved prompts.\nReturns t on success, nil if slave not found or buffer invalid."
  (interactive (list (completing-read "Kill slave: " (hash-table-keys hive-mcp-swarm--slaves))))
  (if-let-star (list slave (gethash slave-id hive-mcp-swarm--slaves)) (let* ((buffer (plist-get slave :buffer))
        (slave-name (plist-get slave :name)))
    (cond
  (((null buffer) (message "[swarm-kill] Warning: slave %s has no buffer (spawn incomplete?)" slave-id) (hive-mcp-swarm-events-emit-slave-killed slave-id) (remhash slave-id hive-mcp-swarm--slaves) (hive-mcp-swarm-prompts-clear-slave slave-id) t) ((not (buffer-live-p buffer)) (message "[swarm-kill] Info: slave %s buffer already dead, cleaning registry" slave-id) (hive-mcp-swarm-events-emit-slave-killed slave-id) (remhash slave-id hive-mcp-swarm--slaves) (hive-mcp-swarm-prompts-clear-slave slave-id) t))
  (((not (-valid-kill-target-p buffer slave-id)) (message "[swarm-kill] BLOCKED: Buffer '%s' failed safety validation for slave %s" (buffer-name buffer) slave-id) (message "[swarm-kill] This prevents accidentally killing coordinator!") (remhash slave-id hive-mcp-swarm--slaves) nil) (t (with-current-buffer buffer
    (set-buffer-modified-p nil)
    (when-let-star (list proc (get-buffer-process buffer)) (set-process-query-on-exit-flag proc nil))
    (when (and (boundp 'vterm--process) vterm--process (process-live-p vterm--process))
    (set-process-query-on-exit-flag vterm--process nil))) (let* ((kill-buffer-query-functions nil)
        (kill-buffer-hook nil)
        (vterm-exit-functions nil))
    (kill-buffer buffer)) (hive-mcp-swarm-events-emit-slave-killed slave-id) (remhash slave-id hive-mcp-swarm--slaves) (hive-mcp-swarm-prompts-clear-slave slave-id) (message "Killed slave: %s" slave-id) t)))) (message "[swarm-kill] Slave not found: %s" slave-id) nil))

(defun hive-mcp-swarm-slaves-kill-all ()
  "Kill all slaves."
  (interactive)
  (let* ((count 0))
    (maphash (lambda (id _unused)
    (hive-mcp-swarm-slaves-kill id)
    (cl-incf count)) hive-mcp-swarm--slaves)
    (message "Killed %d slaves" count)))

(defun hive-mcp-swarm-slaves-get-spawn-timestamps ()
  "Get the list of recent spawn timestamps."
  hive-mcp-swarm-slaves--spawn-timestamps)

(defun hive-mcp-swarm-slaves-get-spawn-count ()
  "Get the count of recent spawns within the rate limit window."
  (length hive-mcp-swarm-slaves--spawn-timestamps))

(defun hive-mcp-swarm-slaves-init ()
  "Initialize slaves module."
  (setq hive-mcp-swarm-slaves--spawn-timestamps nil))

(defun hive-mcp-swarm-slaves-shutdown ()
  "Shutdown slaves module."
  (setq hive-mcp-swarm-slaves--spawn-timestamps nil))

(provide 'hive-mcp-swarm-slaves)
;;; hive-mcp-swarm-slaves.el ends here
