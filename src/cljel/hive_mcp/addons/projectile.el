;;; hive-mcp-projectile.el --- -*- lexical-binding: t; -*-
;; Generated by ClojureElisp

(require 'clojure-elisp-runtime)
(require 'hive-mcp-api)

;;; Code:



(declare-function projectile-project-root "projectile")

(declare-function projectile-project-name "projectile")

(declare-function projectile-project-type "projectile")

(declare-function projectile-current-project-files "projectile")

(declare-function projectile-recentf-files "projectile")

(declare-function projectile-switch-project-by-name "projectile")

(declare-function projectile-project-p "projectile")

(declare-function projectile-invalidate-cache "projectile")

(defvar projectile-known-projects nil)

(declare-function hive-mcp-addon-register "hive-mcp-addons")

(declare-function transient-define-prefix "transient")

(defgroup hive-mcp-projectile nil
  "Projectile integration for hive-mcp."
  :group 'projectile
  :prefix "hive-mcp-projectile-")

(defcustom hive-mcp-projectile-max-files 1000
  "Maximum number of files to return in project file listings."
  :group 'hive-mcp-projectile
  :type 'integer)

(defcustom hive-mcp-projectile-max-search-results 100
  "Maximum number of search results to return."
  :group 'hive-mcp-projectile
  :type 'integer)

(defcustom hive-mcp-projectile-use-ripgrep t
  "When non-nil, prefer ripgrep over grep for searching."
  :group 'hive-mcp-projectile
  :type 'boolean)

(defvar hive-mcp-projectile--initialized nil)

(defun hive-mcp-projectile---ensure-projectile ()
  "Ensure projectile is available."
  (and (featurep 'projectile) (fboundp 'projectile-project-root)))

(defun hive-mcp-projectile---in-project-p ()
  "Return non-nil if currently in a projectile project."
  (and (-ensure-projectile) (projectile-project-p)))

(defun hive-mcp-projectile---ripgrep-available-p ()
  "Return non-nil if ripgrep is available."
  (and hive-mcp-projectile-use-ripgrep (executable-find "rg")))

(defun hive-mcp-projectile---get-project-root ()
  "Get current projectile project root, or nil."
  (when (-ensure-projectile)
    (condition-case nil
    (projectile-project-root)
  (error nil))))

(defun hive-mcp-projectile---get-project-name ()
  "Get current projectile project name, or nil."
  (when (-ensure-projectile)
    (condition-case nil
    (projectile-project-name)
  (error nil))))

(defun hive-mcp-projectile---get-project-type ()
  "Get current projectile project type as a string."
  (when (-ensure-projectile)
    (condition-case nil
    (let* ((type (projectile-project-type)))
    (if type (symbol-name type) "generic"))
  (error "unknown"))))

(defun hive-mcp-projectile---detect-extended-type (root)
  "Detect extended project type based on files in ROOT."
  (when root
    (let* ((markers nil))
    (dolist (pair '(("package.json" . npm) ("Cargo.toml" . cargo) ("go.mod" . go-mod) ("deps.edn" . clojure-deps) ("project.clj" . leiningen) ("shadow-cljs.edn" . shadow-cljs) ("pyproject.toml" . python-pyproject) ("pom.xml" . maven) ("build.gradle" . gradle) ("Makefile" . make) ("Dockerfile" . docker) (".git" . git)))
    (when (file-exists-p (expand-file-name (car pair) root))
    (push (cdr pair) markers)))
    (nreverse markers))))

(defun hive-mcp-projectile---list-files (&optional pattern)
  "List project files, optionally filtered by PATTERN."
  (when (-in-project-p)
    (let* ((files (projectile-current-project-files))
        (filtered (if pattern (seq-filter (lambda (f)
    (or (string-match-p (regexp-quote pattern) f) (string-match-p (wildcard-to-regexp pattern) f))) files) files)))
    (seq-take filtered hive-mcp-projectile-max-files))))

(defun hive-mcp-projectile---find-file-matches (filename)
  "Find files in project matching FILENAME."
  (when (-in-project-p)
    (let* ((files (projectile-current-project-files))
        (matches (seq-filter (lambda (f)
    (or (string= (file-name-nondirectory f) filename) (string-match-p (regexp-quote filename) (file-name-nondirectory f)))) files)))
    matches)))

(defun hive-mcp-projectile---recent-files ()
  "Get recently visited files in current project."
  (when (-in-project-p)
    (condition-case nil
    (projectile-recentf-files)
  (error nil))))

(defun hive-mcp-projectile---search (pattern)
  "Search project for PATTERN using rg or grep."
  (when-let-star (list root (-get-project-root)) (let* ((default-directory root)
        (cmd (if (-ripgrep-available-p) (format "rg --line-number --no-heading --color=never -e %s ." (shell-quote-argument pattern)) (format "grep -r -n -H -e %s ." (shell-quote-argument pattern))))
        (output (shell-command-to-string cmd))
        (lines (split-string output "\n" t))
        (results nil))
    (dolist (line (seq-take lines hive-mcp-projectile-max-search-results))
    (when (string-match "^\\([^:]+\\):\\([0-9]+\\):\\(.*\\)$" line)
    (push (list :file (match-string 1 line) :line (string-to-number (match-string 2 line)) :content (string-trim (match-string 3 line))) results)))
    (nreverse results))))

(defun hive-mcp-projectile-api-project-info ()
  "Get current project info as plist."
  (when (-in-project-p)
    (let* ((root (-get-project-root)))
    (list :name (-get-project-name) :root root :type (-get-project-type) :extended-types (-detect-extended-type root) :file-count (length (projectile-current-project-files)) :in-project t))))

(defun hive-mcp-projectile-api-list-projects ()
  "List all known projectile projects."
  (if (-ensure-projectile) (let* ((projects (or (and (boundp 'projectile-known-projects) projectile-known-projects) nil)))
    (apply #'vector (mapcar (lambda (root)
    (list :root root :name (file-name-nondirectory (directory-file-name root)) :exists (file-directory-p root) :types (-detect-extended-type root))) projects))) (list )))

(defun hive-mcp-projectile-api-project-files (&optional pattern)
  "List files in current project, optionally filtered by PATTERN."
  (if (-in-project-p) (apply #'vector (-list-files pattern)) (list )))

(defun hive-mcp-projectile-api-find-file (filename)
  "Find files matching FILENAME in current project."
  (if (-in-project-p) (let* ((matches (-find-file-matches filename))
        (root (-get-project-root)))
    (apply #'vector (mapcar (lambda (f)
    (list :relative f :absolute (expand-file-name f root))) matches))) (list )))

(defun hive-mcp-projectile-api-recent-files ()
  "Get recently visited files in current project."
  (if (-in-project-p) (apply #'vector (or (-recent-files) '())) (list )))

(defun hive-mcp-projectile-api-search (pattern)
  "Search current project for PATTERN."
  (if (-in-project-p) (apply #'vector (-search pattern)) (list )))

(defun hive-mcp-projectile-show-info ()
  "Display current project info."
  (interactive)
  (if (-in-project-p) (let* ((info (api-project-info))
        (buf (get-buffer-create "*MCP Project Info*")))
    (with-current-buffer buf
    (erase-buffer)
    (insert "=== Projectile Project Info ===\n\n")
    (insert (format "Name: %s\n" (plist-get info :name)))
    (insert (format "Root: %s\n" (plist-get info :root)))
    (insert (format "Type: %s\n" (plist-get info :type)))
    (insert (format "Extended Types: %s\n" (mapconcat #'symbol-name (plist-get info :extended-types) ", ")))
    (insert (format "File Count: %d\n" (plist-get info :file-count)))
    (goto-char (point-min)))
    (display-buffer buf)) (message "Not in a projectile project")))

(provide 'hive-mcp-projectile)
;;; hive-mcp-projectile.el ends here
