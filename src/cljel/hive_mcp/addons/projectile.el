;;; hive-mcp-projectile.el --- -*- lexical-binding: t; -*-
;; Generated by ClojureElisp

(require 'clojure-elisp-runtime)
(require 'hive-mcp-api)

;;; Code:



(declare-function projectile-project-root "projectile")

(declare-function projectile-project-name "projectile")

(declare-function projectile-project-type "projectile")

(declare-function projectile-current-project-files "projectile")

(declare-function projectile-recentf-files "projectile")

(declare-function projectile-switch-project-by-name "projectile")

(declare-function projectile-project-p "projectile")

(declare-function projectile-invalidate-cache "projectile")

(defvar projectile-known-projects)

(declare-function hive-mcp-addon-register "hive-mcp-addons")

(declare-function transient-define-prefix "transient")

(defgroup hive-mcp-projectile nil
  "Projectile integration for hive-mcp."
  :group 'projectile
  :prefix "hive-mcp-projectile-")

(defcustom hive-mcp-projectile-max-files 1000
  "Maximum number of files to return in project file listings."
  :group 'hive-mcp-projectile
  :type 'integer)

(defcustom hive-mcp-projectile-max-search-results 100
  "Maximum number of search results to return."
  :group 'hive-mcp-projectile
  :type 'integer)

(defcustom hive-mcp-projectile-use-ripgrep t
  "When non-nil, prefer ripgrep over grep for searching."
  :group 'hive-mcp-projectile
  :type 'boolean)

(defvar hive-mcp-projectile--initialized nil
  "Whether the addon has been initialized.")

(defun hive-mcp-projectile---ensure-projectile ()
  "Ensure projectile is available."
  (and (featurep 'projectile) (fboundp 'projectile-project-root)))

(defun hive-mcp-projectile---in-project-p ()
  "Return non-nil if currently in a projectile project."
  (and (hive-mcp-projectile---ensure-projectile) (projectile-project-p)))

(defun hive-mcp-projectile---ripgrep-available-p ()
  "Return non-nil if ripgrep is available."
  (and hive-mcp-projectile-use-ripgrep (executable-find "rg")))

(defun hive-mcp-projectile---get-project-root ()
  "Get current projectile project root, or nil."
  (when (hive-mcp-projectile---ensure-projectile)
    (condition-case nil
    (projectile-project-root)
  (error nil))))

(defun hive-mcp-projectile---get-project-name ()
  "Get current projectile project name, or nil."
  (when (hive-mcp-projectile---ensure-projectile)
    (condition-case nil
    (projectile-project-name)
  (error nil))))

(defun hive-mcp-projectile---get-project-type ()
  "Get current projectile project type as a string."
  (when (hive-mcp-projectile---ensure-projectile)
    (condition-case nil
    (let* ((type (projectile-project-type)))
    (if type (symbol-name type) "generic"))
  (error "unknown"))))

(defun hive-mcp-projectile---detect-extended-type (root)
  "Detect extended project type based on files in ROOT."
  (when root
    (let* ((markers nil))
    (dolist (pair '(("package.json" . npm) ("Cargo.toml" . cargo) ("go.mod" . go-mod) ("deps.edn" . clojure-deps) ("project.clj" . leiningen) ("shadow-cljs.edn" . shadow-cljs) ("pyproject.toml" . python-pyproject) ("pom.xml" . maven) ("build.gradle" . gradle) ("Makefile" . make) ("Dockerfile" . docker) (".git" . git)))
    (when (file-exists-p (expand-file-name (car pair) root))
    (push (cdr pair) markers)))
    (nreverse markers))))

(defun hive-mcp-projectile---list-files (&optional pattern)
  "List project files, optionally filtered by PATTERN."
  (when (hive-mcp-projectile---in-project-p)
    (let* ((files (projectile-current-project-files))
        (filtered (if pattern (seq-filter (lambda (f)
    (or (string-match-p (regexp-quote pattern) f) (string-match-p (wildcard-to-regexp pattern) f))) files) files)))
    (seq-take filtered hive-mcp-projectile-max-files))))

(defun hive-mcp-projectile---find-file-matches (filename)
  "Find files in project matching FILENAME."
  (when (hive-mcp-projectile---in-project-p)
    (let* ((files (projectile-current-project-files))
        (matches (seq-filter (lambda (f)
    (or (string= (file-name-nondirectory f) filename) (string-match-p (regexp-quote filename) (file-name-nondirectory f)))) files)))
    matches)))

(defun hive-mcp-projectile---recent-files ()
  "Get recently visited files in current project."
  (when (hive-mcp-projectile---in-project-p)
    (condition-case nil
    (projectile-recentf-files)
  (error nil))))

(defun hive-mcp-projectile---search (pattern)
  "Search project for PATTERN using rg or grep."
  (when-let-star (list root (hive-mcp-projectile---get-project-root)) (let* ((default-directory root)
        (cmd (if (hive-mcp-projectile---ripgrep-available-p) (format "rg --line-number --no-heading --color=never -e %s ." (shell-quote-argument pattern)) (format "grep -r -n -H -e %s ." (shell-quote-argument pattern))))
        (output (shell-command-to-string cmd))
        (lines (split-string output "\n" t))
        (results nil))
    (dolist (line (seq-take lines hive-mcp-projectile-max-search-results))
    (when (string-match "^\\([^:]+\\):\\([0-9]+\\):\\(.*\\)$" line)
    (push (list :file (match-string 1 line) :line (string-to-number (match-string 2 line)) :content (string-trim (match-string 3 line))) results)))
    (nreverse results))))

(defun hive-mcp-projectile-api-project-info ()
  "Get current project info as plist."
  (when (hive-mcp-projectile---in-project-p)
    (let* ((root (hive-mcp-projectile---get-project-root)))
    (list :name (hive-mcp-projectile---get-project-name) :root root :type (hive-mcp-projectile---get-project-type) :extended-types (hive-mcp-projectile---detect-extended-type root) :file-count (length (projectile-current-project-files)) :in-project t))))

(defun hive-mcp-projectile-api-list-projects ()
  "List all known projectile projects."
  (if (hive-mcp-projectile---ensure-projectile) (let* ((projects (or (and (boundp 'projectile-known-projects) projectile-known-projects) nil)))
    (apply #'vector (mapcar (lambda (root)
    (list :root root :name (file-name-nondirectory (directory-file-name root)) :exists (file-directory-p root) :types (hive-mcp-projectile---detect-extended-type root))) projects))) (list )))

(defun hive-mcp-projectile-api-project-files (&optional pattern)
  "List files in current project, optionally filtered by PATTERN."
  (if (hive-mcp-projectile---in-project-p) (apply #'vector (hive-mcp-projectile---list-files pattern)) (list )))

(defun hive-mcp-projectile-api-find-file (filename)
  "Find files matching FILENAME in current project."
  (if (hive-mcp-projectile---in-project-p) (let* ((matches (hive-mcp-projectile---find-file-matches filename))
        (root (hive-mcp-projectile---get-project-root)))
    (apply #'vector (mapcar (lambda (f)
    (list :relative f :absolute (expand-file-name f root))) matches))) (list )))

(defun hive-mcp-projectile-api-recent-files ()
  "Get recently visited files in current project."
  (if (hive-mcp-projectile---in-project-p) (apply #'vector (or (hive-mcp-projectile---recent-files) '())) (list )))

(defun hive-mcp-projectile-api-search (pattern)
  "Search current project for PATTERN."
  (if (hive-mcp-projectile---in-project-p) (apply #'vector (hive-mcp-projectile---search pattern)) (list )))

(defun hive-mcp-projectile-show-info ()
  "Display current project info."
  (interactive)
  (if (hive-mcp-projectile---in-project-p) (let* ((info (hive-mcp-projectile-api-project-info))
        (buf (get-buffer-create "*MCP Project Info*")))
    (with-current-buffer buf
    (erase-buffer)
    (insert "=== Projectile Project Info ===\n\n")
    (insert (format "Name: %s\n" (plist-get info :name)))
    (insert (format "Root: %s\n" (plist-get info :root)))
    (insert (format "Type: %s\n" (plist-get info :type)))
    (insert (format "Extended Types: %s\n" (mapconcat #'symbol-name (plist-get info :extended-types) ", ")))
    (insert (format "File Count: %d\n" (plist-get info :file-count)))
    (goto-char (point-min)))
    (display-buffer buf)) (message "Not in a projectile project")))

(defun hive-mcp-projectile-list-projects ()
  "Display all known projects."
  (interactive)
  (let* ((projects (hive-mcp-projectile-api-list-projects))
        (buf (get-buffer-create "*MCP Known Projects*")))
    (with-current-buffer buf
    (erase-buffer)
    (insert "=== Known Projectile Projects ===\n\n")
    (if (equal (length projects) 0) (insert "No projects found.\n") (cl-dotimes (i (length projects))
    (let* ((proj (aref projects i)))
    (insert (format "%d. %s\n   Root: %s\n   Exists: %s\n\n" (1+ i) (plist-get proj :name) (plist-get proj :root) (if (plist-get proj :exists) "yes" "NO")))))))
    (goto-char (point-min))
    (display-buffer buf)))

(defun hive-mcp-projectile-search-interactive (pattern)
  "Search project for PATTERN and display results."
  (interactive "sSearch pattern: ")
  (if (hive-mcp-projectile---in-project-p) (let* ((results (hive-mcp-projectile-api-search pattern))
        (buf (get-buffer-create "*MCP Project Search*")))
    (with-current-buffer buf
    (erase-buffer)
    (insert (format "=== Search Results for '%s' ===\n\n" pattern))
    (insert (format "Found: %d matches\n\n" (length results)))
    (if (equal (length results) 0) (insert "No matches found.\n") (cl-dotimes (i (length results))
    (let* ((match (aref results i)))
    (insert (format "%s:%d: %s\n" (plist-get match :file) (plist-get match :line) (plist-get match :content))))))
    (goto-char (point-min))
    (grep-mode))
    (display-buffer buf)) (message "Not in a projectile project")))

(defun hive-mcp-projectile-transient ()
  "MCP Projectile menu."
  (interactive)
  (if (require 'transient nil t) (progn
  (transient-define-prefix hive-mcp-projectile--menu ()
  "MCP Projectile menu."
  ["hive-mcp + Projectile" ["Info" ("i" "Project info" hive-mcp-projectile-show-info) ("p" "List projects" hive-mcp-projectile-list-projects)] ["Search" ("s" "Search" hive-mcp-projectile-search-interactive)]])
  (hive-mcp-projectile--menu)) (message "Transient not available")))

(defun hive-mcp-projectile---addon-init ()
  "Initialize projectile addon.\nDoes nothing if projectile is not available."
  (if (not (featurep 'projectile)) (message "hive-mcp-projectile: projectile package not found, addon disabled") (require 'hive-mcp-api nil t)))

(defun hive-mcp-projectile---addon-shutdown ()
  "Shutdown projectile addon."
  (setq hive-mcp-projectile--initialized nil)
  (message "hive-mcp-projectile: shutdown"))

(define-minor-mode hive-mcp-projectile-mode
  "Minor mode for Projectile integration."
  :init-value nil
  :lighter " MCP-Proj"
  :global t
  :group 'hive-mcp-projectile
  (if hive-mcp-projectile-mode (hive-mcp-projectile---addon-init) (message "hive-mcp-projectile disabled")))

(with-eval-after-load 'hive-mcp-addons
  (hive-mcp-addon-register 'projectile :version "0.1.0" :description "Projectile project management integration" :requires '(projectile hive-mcp-api) :provides '(hive-mcp-projectile-mode hive-mcp-projectile-transient) :init #'-addon-init :shutdown #'-addon-shutdown))

(provide 'hive-mcp-projectile)
;;; hive-mcp-projectile.el ends here
