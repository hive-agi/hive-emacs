;;; hive-mcp-claude-code.el --- -*- lexical-binding: t; -*-
;; Generated by ClojureElisp

(require 'clojure-elisp-runtime)

;;; Code:



(require 'claude-code nil t)

(declare-function hive-mcp-api-get-context "hive-mcp-api")

(declare-function hive-mcp-api-memory-add "hive-mcp-api")

(declare-function hive-mcp-api-memory-query "hive-mcp-api")

(declare-function hive-mcp-api-list-workflows "hive-mcp-api")

(declare-function hive-mcp-api-run-workflow "hive-mcp-api")

(declare-function hive-mcp-api-notify "hive-mcp-api")

(declare-function hive-mcp-api-conversation-log "hive-mcp-api")

(declare-function hive-mcp-api-capabilities "hive-mcp-api")

(defgroup hive-mcp-claude-code nil
  "Integration between claude-code.el and hive-mcp."
  :group 'claude-code
  :prefix "hive-mcp-claude-code-")

(defcustom hive-mcp-claude-code-auto-context nil
  "When non-nil, automatically include MCP context in commands.\nContext includes buffer info, project, git status, and relevant memory."
  :group 'hive-mcp-claude-code
  :type 'boolean)

(defcustom hive-mcp-claude-code-log-conversations nil
  "When non-nil, log conversations to hive-mcp memory.\nThis enables persistent conversation history per project."
  :group 'hive-mcp-claude-code
  :type 'boolean)

(defcustom hive-mcp-claude-code-context-format 'compact
  "Format for context injection.\n- `compact': Single line summary\n- `full': Complete context JSON\n- `smart': Include only relevant sections"
  :group 'hive-mcp-claude-code
  :type '(choice (const :tag "Compact summary" compact) (const :tag "Full JSON context" full) (const :tag "Smart selection" smart)))

(defcustom hive-mcp-claude-code-notify-on-complete t
  "When non-nil, use hive-mcp notifications when Claude completes."
  :group 'hive-mcp-claude-code
  :type 'boolean)

(defvar hive-mcp-claude-code--available nil)

(defun hive-mcp-claude-code---available-p ()
  "Check if hive-mcp-api is available."
  (or hive-mcp-claude-code--available (setq hive-mcp-claude-code--available (featurep 'hive-mcp-api))))

(defun hive-mcp-claude-code---ensure-available ()
  "Ensure hive-mcp is available, error if not."
  (unless (hive-mcp-claude-code--available-p)
    (if (require 'hive-mcp-api nil t) (setq hive-mcp-claude-code--available t) (error "Emacs-mcp-api not available.  Load hive-mcp first"))))

(defun hive-mcp-claude-code---format-context-compact (ctx)
  "Format CTX as compact one-line summary."
  (let* ((buffer (plist-get ctx :buffer))
        (project (plist-get ctx :project))
        (git (plist-get ctx :git)))
    (format "[%s @ %s%s]" (or (plist-get buffer :name) "unknown") (or (plist-get project :name) "no-project") (if (plist-get git :dirty) " (modified)" ""))))

(defun hive-mcp-claude-code---format-context-smart (ctx)
  "Format CTX with only relevant sections."
  (let* ((parts '())
        (buffer (plist-get ctx :buffer))
        (region (plist-get ctx :region))
        (defun-ctx (plist-get ctx :defun))
        (project (plist-get ctx :project))
        (git (plist-get ctx :git))
        (memory (plist-get ctx :memory)))
    (when buffer
    (push (format "File: %s:%d" (or (plist-get buffer :file) (plist-get buffer :name)) (or (plist-get buffer :line) 1)) parts))
    (when region
    (push (format "Selected: %s" (plist-get region :text)) parts))
    (when defun-ctx
    (push (format "In: %s" (plist-get defun-ctx :name)) parts))
    (when (and git (plist-get git :dirty))
    (let* ((modified (plist-get git :modified)))
    (when modified
    (push (format "Modified files: %s" (mapconcat #'identity (seq-take modified 3) ", ")) parts))))
    (when memory
    (let* ((notes (plist-get memory :notes)))
    (when (and notes (> (length notes) 0))
    (push (format "Recent notes: %d" (length notes)) parts))))
    (string-join (nreverse parts) "\n")))

(defun hive-mcp-claude-code---get-context-string ()
  "Get context string based on `hive-mcp-claude-code-context-format'."
  (when (hive-mcp-claude-code--available-p)
    (let* ((ctx (hive-mcp-api-get-context)))
    (pcase hive-mcp-claude-code-context-format
  ((quote compact) (hive-mcp-claude-code--format-context-compact ctx))
  ((quote full) (json-encode ctx))
  ((quote smart) (hive-mcp-claude-code--format-context-smart ctx))))))

(defun hive-mcp-claude-code-send-with-context ()
  "Read command and send to Claude with hive-mcp context."
  (interactive)
  (hive-mcp-claude-code--ensure-available)
  (let* ((ctx-string (hive-mcp-claude-code--get-context-string))
        (cmd (clel-read-string "Claude command: " nil 'claude-code-command-history))
        (full-cmd (if ctx-string (format "%s\n\nContext:\n%s" cmd ctx-string) cmd)))
    (claude-code--do-send-command full-cmd)))

(defun hive-mcp-claude-code-save-to-memory ()
  "Save selected text or prompt to project memory."
  (interactive)
  (hive-mcp-claude-code--ensure-available)
  (let* ((text (if (use-region-p) (buffer-substring-no-properties (region-beginning) (region-end)) (clel-read-string "Note content: ")))
        (type (completing-read "Type: " '("note" "snippet" "convention" "decision") nil t))
        (tags (split-string (clel-read-string "Tags (comma-separated): ") "," t " ")))
    (hive-mcp-api-memory-add type text tags)
    (message "Saved to project memory as %s" type)))

(provide 'hive-mcp-claude-code)
;;; hive-mcp-claude-code.el ends here
