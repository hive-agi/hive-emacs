;;; hive-mcp-log.el --- -*- lexical-binding: t; -*-
;; Generated by ClojureElisp

(require 'clojure-elisp-runtime)

;;; Code:



(defgroup hive-mcp-log nil
  "Structured logging settings for hive-mcp."
  :group 'hive-mcp
  :prefix "hive-mcp-log-")

(defcustom hive-mcp-log-level 'info
  "Minimum log level to emit.\nLevels in order: debug < info < warn < error.\nSet to 'debug for verbose output, 'error for minimal."
  :group 'hive-mcp-log
  :type '(choice (const :tag "Debug (all messages)" debug) (const :tag "Info (normal operation)" info) (const :tag "Warn (potential issues)" warn) (const :tag "Error (failures only)" error)))

(defcustom hive-mcp-log-components nil
  "List of components to log, or nil to log all.\nValid components: swarm, memory, channel, api, context, workflow,\nkanban, hivemind, graceful, etc.\nWhen nil, all components are logged."
  :group 'hive-mcp-log
  :type '(choice (const :tag "All components" nil) (repeat :tag "Specific components" symbol)))

(defcustom hive-mcp-log-to-messages t
  "If non-nil, emit log entries to *Messages* buffer."
  :group 'hive-mcp-log
  :type 'boolean)

(defcustom hive-mcp-log-to-buffer nil
  "If non-nil, emit log entries to dedicated *hive-mcp-log* buffer."
  :group 'hive-mcp-log
  :type 'boolean)

(defcustom hive-mcp-log-history-size 500
  "Number of log entries to keep in ring buffer history."
  :group 'hive-mcp-log
  :type 'integer)

(defcustom hive-mcp-log-include-timestamp t
  "If non-nil, include timestamps in log output."
  :group 'hive-mcp-log
  :type 'boolean)

(defcustom hive-mcp-log-timing-threshold-ms 100
  "Log timing warnings when operations exceed this threshold (milliseconds).\nSet to 0 to always log timing, or a large value to only log slow operations."
  :group 'hive-mcp-log
  :type 'integer)

(defvar hive-mcp-log--history nil)

(defvar hive-mcp-log--level-priority '((debug . 0) (info . 1) (warn . 2) (error . 3))
  "Priority mapping for log levels.")

(defvar hive-mcp-log--level-labels '((debug . "DEBUG") (info . "INFO ") (warn . "WARN ") (error . "ERROR"))
  "Display labels for log levels.")

(defvar hive-mcp-log--buffer-name "*hive-mcp-log*"
  "Name of the dedicated log buffer.")

(defvar hive-mcp-log--mcp-call-stats nil)

(defun hive-mcp-log--ensure-history ()
  "Ensure the log history ring buffer exists."
  (if hive-mcp-log--history nil (progn
  (setq hive-mcp-log--history (make-ring hive-mcp-log-history-size)))))

(defun hive-mcp-log--ensure-stats ()
  "Ensure the MCP stats hash table exists."
  (if hive-mcp-log--mcp-call-stats nil (progn
  (setq hive-mcp-log--mcp-call-stats (make-hash-table :test 'equal)))))

(defun hive-mcp-log--level-enabled-p (level)
  "Return non-nil if LEVEL is enabled based on current log level."
  (let* ((level-pri (alist-get level hive-mcp-log--level-priority 1))
        (min-pri (alist-get hive-mcp-log-level hive-mcp-log--level-priority 1)))
    (>= level-pri min-pri)))

(defun hive-mcp-log--component-enabled-p (component)
  "Return non-nil if COMPONENT should be logged."
  (or (null hive-mcp-log-components) (memq (if (stringp component) (intern component) component) hive-mcp-log-components)))

(defun hive-mcp-log--format-timestamp ()
  "Return formatted timestamp string."
  (format-time-string "%H:%M:%S.%3N"))

(defun hive-mcp-log--format-entry (level component message)
  "Format a log entry with LEVEL, COMPONENT, and MESSAGE."
  (let* ((level-label (alist-get level hive-mcp-log--level-labels "?????"))
        (comp-str (if (stringp component) component (symbol-name component))))
    (if hive-mcp-log-include-timestamp (format "[%s] [%s] [%s] %s" (hive-mcp-log--format-timestamp) level-label comp-str message) (format "[%s] [%s] %s" level-label comp-str message))))

(defun hive-mcp-log--level-face (level)
  "Return face for LEVEL."
  (pcase level
  ((quote debug) 'font-lock-comment-face)
  ((quote info) 'default)
  ((quote warn) 'warning)
  ((quote error) 'error)
  ('_ 'default)))

(defun hive-mcp-log--write-to-buffer (formatted-msg level)
  "Write FORMATTED-MSG with LEVEL to the dedicated log buffer."
  (let* ((buf (get-buffer-create hive-mcp-log--buffer-name)))
    (with-current-buffer buf
    (goto-char (point-max))
    (let* ((inhibit-read-only t))
    (insert (propertize (clel-str formatted-msg "\n") 'face (hive-mcp-log--level-face level)))))))

(defun hive-mcp-log--emit (level component message)
  "Emit a log entry with LEVEL, COMPONENT, and MESSAGE."
  (let* ((entry (list :timestamp (current-time) :level level :component (if (stringp component) (intern component) component) :message message)))
    (hive-mcp-log--ensure-history)
    (ring-insert hive-mcp-log--history entry)
    (let* ((formatted (hive-mcp-log--format-entry level component message)))
    (when hive-mcp-log-to-messages
    (message "%s" formatted))
    (when hive-mcp-log-to-buffer
    (hive-mcp-log--write-to-buffer formatted level)))))

(defun hive-mcp-log-log (&rest args)
  (let ((level (nth 0 args)) (component (nth 1 args)) (format-string (nth 2 args)) (args (nthcdr 3 args)))
    "Log a message at LEVEL for COMPONENT using FORMAT-STRING and ARGS.\n\nLEVEL is one of: debug, info, warn, error.\nCOMPONENT is a symbol or string identifying the subsystem.\nFORMAT-STRING and ARGS work like `format'."
  (when (and (hive-mcp-log--level-enabled-p level) (hive-mcp-log--component-enabled-p component))
    (let* ((message (apply format format-string args)))
    (hive-mcp-log--emit level component message)))))

(defun hive-mcp-log-log-debug (&rest args)
  (let ((component (nth 0 args)) (format-string (nth 1 args)) (args (nthcdr 2 args)))
    "Log a debug message for COMPONENT using FORMAT-STRING and ARGS."
  (apply hive-mcp-log-log 'debug component format-string args)))

(defun hive-mcp-log-log-info (&rest args)
  (let ((component (nth 0 args)) (format-string (nth 1 args)) (args (nthcdr 2 args)))
    "Log an info message for COMPONENT using FORMAT-STRING and ARGS."
  (apply hive-mcp-log-log 'info component format-string args)))

(defun hive-mcp-log-log-warn (&rest args)
  (let ((component (nth 0 args)) (format-string (nth 1 args)) (args (nthcdr 2 args)))
    "Log a warning message for COMPONENT using FORMAT-STRING and ARGS."
  (apply hive-mcp-log-log 'warn component format-string args)))

(defun hive-mcp-log-log-error (&rest args)
  (let ((component (nth 0 args)) (format-string (nth 1 args)) (args (nthcdr 2 args)))
    "Log an error message for COMPONENT using FORMAT-STRING and ARGS."
  (apply hive-mcp-log-log 'error component format-string args)))

(defun hive-mcp-log-log-recent (&optional count)
  "Return the COUNT most recent log entries (default: 10).\nReturns a list of plists with :timestamp, :level, :component, :message."
  (hive-mcp-log--ensure-history)
  (let* ((n (or count 10))
        (len (ring-length hive-mcp-log--history))
        (limit (cl-min n len)))
    (cl-loop for i from 0 below limit collect (ring-ref hive-mcp-log--history i))))

(defun hive-mcp-log-log-filter-by-component (component)
  "Return all log entries for COMPONENT from history."
  (hive-mcp-log--ensure-history)
  (let* ((comp-sym (if (stringp component) (intern component) component))
        (len (ring-length hive-mcp-log--history)))
    (seq-filter (lambda ()
    (eq (plist-get entry :component) comp-sym)) (cl-loop for i from 0 below len collect (ring-ref hive-mcp-log--history i)))))

(defun hive-mcp-log-log-filter-by-level (level)
  "Return all log entries at or above LEVEL from history."
  (hive-mcp-log--ensure-history)
  (let* ((min-pri (alist-get level hive-mcp-log--level-priority 1))
        (len (ring-length hive-mcp-log--history)))
    (seq-filter (lambda ()
    (let* ((entry-level (plist-get entry :level))
        (entry-pri (alist-get entry-level hive-mcp-log--level-priority 1)))
    (>= entry-pri min-pri))) (cl-loop for i from 0 below len collect (ring-ref hive-mcp-log--history i)))))

(defun hive-mcp-log-log-clear-history ()
  "Clear the log history ring buffer."
  (interactive)
  (setq hive-mcp-log--history nil)
  (hive-mcp-log--ensure-history)
  (message "Log history cleared"))

(defun hive-mcp-log-log-show-buffer ()
  "Show the dedicated log buffer."
  (interactive)
  (let* ((buf (get-buffer-create hive-mcp-log--buffer-name)))
    (with-current-buffer buf
    (unless (derived-mode-p 'hive-mcp-log-mode)
    (hive-mcp-log-mode)))
    (display-buffer buf)))

(defvar hive-mcp-log-mode-map (make-sparse-keymap)
  "Keymap for hive-mcp-log-mode.")

(defun hive-mcp-log-mcp-call-start (tool-name)
  "Record the start of an MCP call to TOOL-NAME.\nReturns a timing token to pass to `mcp-call-end'."
  (hive-mcp-log-log-debug 'mcp "Starting MCP call: %s" tool-name)
  (list :tool tool-name :start (current-time)))

(defun hive-mcp-log-mcp-call-end (timing-token &optional success)
  "Record the end of an MCP call using TIMING-TOKEN.\nSUCCESS indicates whether the call succeeded."
  (hive-mcp-log--ensure-stats)
  (let* ((tool-name (plist-get timing-token :tool))
        (start-time (plist-get timing-token :start))
        (elapsed-ms (* 1000.0 (float-time (time-subtract (current-time) start-time))))
        (stats (gethash tool-name hive-mcp-log--mcp-call-stats)))
    (if stats (progn
  (plist-put stats :count (1+ (plist-get stats :count)))
  (plist-put stats :total-ms (+ (plist-get stats :total-ms) elapsed-ms))
  (when (> elapsed-ms (plist-get stats :max-ms))
    (plist-put stats :max-ms elapsed-ms))) (puthash tool-name (list :count 1 :total-ms elapsed-ms :max-ms elapsed-ms) hive-mcp-log--mcp-call-stats))
    (let* ((level (if (> elapsed-ms hive-mcp-log-timing-threshold-ms) 'warn 'debug)))
    (hive-mcp-log-log level 'mcp "MCP call %s: %.1fms%s" tool-name elapsed-ms (if success "" " (FAILED)")))))

(defun hive-mcp-log-mcp-stats ()
  "Return MCP call statistics as an alist.\nEach entry is (TOOL-NAME . (:count N :total-ms M :max-ms X :avg-ms A))."
  (hive-mcp-log--ensure-stats)
  (let* ((result nil))
    (maphash (lambda ()
    (let* ((count (plist-get stats :count))
        (total (plist-get stats :total-ms))
        (avg (if (> count 0) (/ total count) 0)))
    (push (cons tool (list :count count :total-ms total :max-ms (plist-get stats :max-ms) :avg-ms avg)) result))) hive-mcp-log--mcp-call-stats)
    (clel-sort result (lambda ()
    (> (plist-get (cdr a) :total-ms) (plist-get (cdr b) :total-ms))))))

(defun hive-mcp-log-mcp-stats-reset ()
  "Reset MCP call statistics."
  (interactive)
  (when hive-mcp-log--mcp-call-stats
    (clrhash hive-mcp-log--mcp-call-stats))
  (message "MCP statistics reset"))

(defun hive-mcp-log-mcp-stats-report ()
  "Display a report of MCP call statistics."
  (interactive)
  (let* ((stats (hive-mcp-log-mcp-stats)))
    (if (null stats) (message "No MCP call statistics recorded") (with-output-to-temp-buffer "*hive-mcp-stats*" (princ "MCP Call Statistics\n") (princ "====================\n\n") (princ (format "%-30s %8s %10s %10s %10s\n" "Tool" "Count" "Total(ms)" "Max(ms)" "Avg(ms)")) (princ (make-string 70 -p-)) (princ "\n") (mapc (lambda ()
    (let* ((tool (car entry))
        (data (cdr entry)))
    (princ (format "%-30s %8d %10.1f %10.1f %10.1f\n" tool (plist-get data :count) (plist-get data :total-ms) (plist-get data :max-ms) (plist-get data :avg-ms))))) stats)))))

(defun hive-mcp-log-with-timing (component operation body-fn)
  "Execute BODY-FN, logging timing for OPERATION under COMPONENT.\nReturns the result of BODY-FN.\n\nNote: This is a function version; see hive-mcp-log-with-timing macro for\nthe macro version in the compiled Elisp."
  (let* ((start (current-time))
        (result (funcall body-fn))
        (elapsed-ms (* 1000.0 (float-time (time-subtract (current-time) start)))))
    (if (> elapsed-ms hive-mcp-log-timing-threshold-ms) (hive-mcp-log-log-warn component "%s took %.1fms (threshold: %dms)" operation elapsed-ms hive-mcp-log-timing-threshold-ms) (hive-mcp-log-log-debug component "%s completed in %.1fms" operation elapsed-ms))
    result))

(defun hive-mcp-log-instrument-mcp (tool-name body-fn)
  "Execute BODY-FN as an MCP call to TOOL-NAME with timing instrumentation.\nReturns the result of BODY-FN."
  (let* ((token (hive-mcp-log-mcp-call-start tool-name))
        (success nil)
        (result nil))
    (unwind-protect
    (progn
  (setq result (funcall body-fn))
  (setq success t)
  result)
  (hive-mcp-log-mcp-call-end token success))))

(provide 'hive-mcp-log)

(provide 'hive-mcp-log)
;;; hive-mcp-log.el ends here
