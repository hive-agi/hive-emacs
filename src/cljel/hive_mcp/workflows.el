;;; hive-mcp-workflows.el --- -*- lexical-binding: t; -*-
;; Generated by ClojureElisp

(require 'clojure-elisp-runtime)

;;; Code:



(require 'hive-mcp-memory)

(defgroup hive-mcp-workflows nil
  "Workflow settings for hive-mcp."
  :group 'hive-mcp
  :prefix "hive-mcp-workflow-")

(defcustom hive-mcp-workflows-file (expand-file-name "workflows.el" (expand-file-name "hive-mcp" user-emacs-directory))
  "File storing user workflow definitions."
  :group 'hive-mcp-workflows
  :type 'file)

(defvar hive-mcp-workflow-registry (make-hash-table :test 'equal)
  "Registry of user-defined workflows.\nEach entry is NAME -> plist with :description :params :steps :on-error.")

(defvar hive-mcp-workflow-step-handlers (make-hash-table :test 'eq)
  "Handlers for custom workflow step types.\nEach entry is TYPE -> function taking (step env) and returning env.")

(defvar hive-mcp-workflow-before-hook nil)

(defvar hive-mcp-workflow-after-hook nil)

(defun hive-mcp-workflows-workflow-register (name spec)
  "Register workflow NAME with SPEC.\nThread-safe: overwrites existing entry atomically."
  (puthash name spec hive-mcp-workflow-registry)
  (hive-mcp-workflow--save)
  (message "Workflow '%s' registered" name))

(defun hive-mcp-workflows-workflow-unregister (name)
  "Remove workflow NAME from registry."
  (remhash name hive-mcp-workflow-registry)
  (hive-mcp-workflow--save))

(defun hive-mcp-workflows-workflow-get (name)
  "Get workflow spec by NAME."
  (gethash name hive-mcp-workflow-registry))

(defun hive-mcp-workflows-workflow-list ()
  "Return list of all workflows with metadata."
  (let* ((workflows nil))
    (maphash (lambda (name spec)
    (push (list :name name :description (plist-get spec :description) :params (plist-get spec :params)) workflows)) hive-mcp-workflow-registry)
    (nreverse workflows)))

(defun hive-mcp-workflows-workflow-run (&rest args)
  (let ((name (nth 0 args)) (args (nthcdr 1 args)))
    "Execute workflow NAME with optional ARGS plist.\nRuns before/after hooks around execution."
  (if-let ((spec (gethash name hive-mcp-workflow-registry)))
    (progn
  (run-hook-with-args 'hive-mcp-workflow-before-hook name args)
  (let* ((result (hive-mcp-workflow--execute spec args)))
    (run-hook-with-args 'hive-mcp-workflow-after-hook name result)
    result))
  (error "Unknown workflow: %s" name))))

(defun hive-mcp-workflows---execute (spec args)
  "Execute workflow SPEC with ARGS.\nSupports two modes:\n  1. :handler - direct function invocation with args plist\n  2. :steps - step-by-step execution with env passing\nState transitions are guarded: checks current step state before advancing."
  (let* ((handler (plist-get spec :handler)))
    (if handler (condition-case err
    (funcall handler args)
  (error (list :success nil :error (error-message-string err)))) (let* ((steps (plist-get spec :steps))
        (on-error (or (plist-get spec :on-error) :stop))
        (env (hive-mcp-workflows--init-env spec args))
        (step-num 0))
    (catch 'workflow-abort (dolist (step steps)
    (setq step-num (1+ step-num))
    (condition-case err
    (setq env (hive-mcp-workflows--run-step step env))
  (error (pcase on-error
  ('stop (signal 'error 'workflow-abort))
  ('continue nil)
  ('ask (unless (yes-or-no-p (format "Step %d failed: %s. Continue? " step-num (error-message-string err)))
    (signal 'error 'workflow-abort))))))) (list :success t :env env))))))

(defun hive-mcp-workflows---init-env (spec args)
  "Initialize environment for workflow SPEC with ARGS.\nApplies defaults and validates required params."
  (let* ((env (copy-sequence args))
        (params (plist-get spec :params)))
    (dolist (param params)
    (let* ((name (plist-get param :name))
        (default (plist-get param :default)))
    (unless (plist-get env (intern (clel-concat ":" name)))
    (when default
    (setq env (plist-put env (intern (clel-concat ":" name)) default))))))
    (dolist (param params)
    (when (plist-get param :required)
    (let* ((name (plist-get param :name)))
    (unless (plist-get env (intern (clel-concat ":" name)))
    (error "Required parameter missing: %s" name)))))
    env))

(defun hive-mcp-workflows---run-step (step env)
  "Run a single workflow STEP with ENV.  Return updated ENV.\nChecks for custom handler first, then falls through to built-in types."
  (let* ((type (plist-get step :type)))
    (if-let ((handler (gethash type hive-mcp-workflow-step-handlers)))
    (funcall handler step env)
  (pcase type
  ('elisp (hive-mcp-workflows--step-elisp step env))
  ('shell (hive-mcp-workflows--step-shell step env))
  ('prompt (hive-mcp-workflows--step-prompt step env))
  ('confirm (hive-mcp-workflows--step-confirm step env))
  ('condition (hive-mcp-workflows--step-condition step env))
  ('memory-add (hive-mcp-workflows--step-memory-add step env))
  ('notify (hive-mcp-workflows--step-notify step env))
  ('_ (error "Unknown step type: %s" type))))))

(defun hive-mcp-workflows---step-elisp (step env)
  "Execute elisp code from STEP with ENV bindings."
  (let* ((code (plist-get step :code))
        (result (eval (read code) t)))
    (if-let ((var (plist-get step :var)))
    (plist-put env var result)
  env)))

(defun hive-mcp-workflows---step-shell (step env)
  "Execute shell command from STEP with ENV variable substitution."
  (let* ((cmd-template (plist-get step :command))
        (cmd (hive-mcp-workflows--substitute-vars cmd-template env))
        (result (string-trim (shell-command-to-string cmd))))
    (if-let ((var (plist-get step :var)))
    (plist-put env var result)
  env)))

(defun hive-mcp-workflows---step-prompt (step env)
  "Prompt user for input using message from STEP, store result in ENV."
  (let* ((msg (plist-get step :message))
        (default (plist-get step :default))
        (result (clel-read-string (clel-concat msg ": ") default)))
    (plist-put env (plist-get step :var) result)))

(defun hive-mcp-workflows---step-confirm (step env)
  "Ask user for confirmation using message from STEP.\nReturns ENV if confirmed, otherwise signals error."
  (unless (yes-or-no-p (plist-get step :message))
    (error "User cancelled"))
  env)

(defun hive-mcp-workflows---step-condition (step env)
  "Execute conditional branch from STEP based on test result in ENV."
  (let* ((test-fn (plist-get step :test)))
    (if (funcall test-fn env) (when-let ((then-step (plist-get step :then)))
    (hive-mcp-workflows--run-step then-step env)) (when-let ((else-step (plist-get step :else)))
    (hive-mcp-workflows--run-step else-step env)))))

(defun hive-mcp-workflows---step-memory-add (step env)
  "Add memory entry from STEP, substituting variables from ENV."
  (let* ((type (plist-get step :mem-type))
        (content (hive-mcp-workflows--substitute-vars (plist-get step :content) env))
        (tags (plist-get step :tags)))
    (hive-mcp-memory-add (intern type) content tags))
  env)

(defun hive-mcp-workflows---step-notify (step env)
  "Show notification from STEP message, substituting variables from ENV."
  (let* ((msg (hive-mcp-workflows--substitute-vars (plist-get step :message) env))
        (level (or (plist-get step :level) 'info)))
    (pcase level
  ((quote error) (user-error "%s" msg))
  ((quote warning) (display-warning 'hive-mcp msg :warning))
  ('_ (message "[MCP] %s" msg))))
  env)

(defun hive-mcp-workflows---substitute-vars (template env)
  "Substitute ${var} in TEMPLATE with values from ENV."
  (if (stringp template) (replace-regexp-in-string "\\${\\([^}]+\\)}" (lambda (match)
    (let* ((var-name (match-string 1 match))
        (var-key (intern (clel-concat ":" var-name)))
        (value (plist-get env var-key)))
    (if value (format "%s" value) match))) template) template))

(defun hive-mcp-workflows-workflow-register-step-type (type handler)
  "Register workflow step TYPE with HANDLER function.\nHANDLER receives (step env) and should return updated env."
  (puthash type handler hive-mcp-workflow-step-handlers))

(defun hive-mcp-workflows---save ()
  "Save workflows to file."
  (make-directory (file-name-directory hive-mcp-workflows-file) t)
  (with-temp-file hive-mcp-workflows-file (let* ((workflows nil))
    (maphash (lambda (k v)
    (push (cons k v) workflows)) hive-mcp-workflow-registry)
    (insert ";;; hive-mcp workflows - auto-generated\n")
    (insert ";;; Do not edit manually\n\n")
    (insert "(setq hive-mcp-workflow--saved-data\n  '")
    (prin1 workflows (current-buffer))
    (insert ")\n"))))

(defun hive-mcp-workflows---load ()
  "Load workflows from file."
  (when (file-exists-p hive-mcp-workflows-file)
    (load hive-mcp-workflows-file t t)
    (when (boundp 'hive-mcp-workflow--saved-data)
    (dolist (wf hive-mcp-workflow--saved-data)
    (puthash (car wf) (cdr wf) hive-mcp-workflow-registry)))))

(defun hive-mcp-workflows-workflow-run-interactive ()
  "Interactively run a workflow."
  (interactive)
  (let* ((workflows (hive-mcp-workflows-workflow-list))
        (names (mapcar (lambda (wf)
    (plist-get wf :name)) workflows))
        (name (completing-read "Workflow: " names nil t)))
    (let* ((result (hive-mcp-workflows-workflow-run name)))
    (if (plist-get result :success) (message "Workflow completed successfully") (message "Workflow failed: %s" (plist-get result :error))))))

(defun hive-mcp-workflows--wrap--get-date ()
  "Return current date in YYYY-MM-DD format."
  (format-time-string "%Y-%m-%d"))

(defun hive-mcp-workflows--wrap--make-tags (base-tags)
  "Create tags list with BASE-TAGS plus auto-injected project scope."
  (hive-mcp-memory--inject-project-scope base-tags))

(defun hive-mcp-workflows--wrap--git-status ()
  "Get git status summary for wrap workflow."
  (let* ((branch (string-trim (shell-command-to-string "git rev-parse --abbrev-ref HEAD 2>/dev/null || echo 'none'")))
        (status (shell-command-to-string "git status --porcelain 2>/dev/null"))
        (unmerged (string-trim (shell-command-to-string "git branch --no-merged main 2>/dev/null | grep -E '^\\s*(feature|fix|feat)/' | head -10 || true"))))
    (list :branch branch :has-uncommitted (not (string-empty-p status)) :unmerged-feature-branches (when (not (string-empty-p unmerged))
    (split-string unmerged "\n" t "\\s-*")))))

(defun hive-mcp-workflows--wrap--store-accomplishments (accomplishments)
  "Store ACCOMPLISHMENTS as session-summary note with short-term duration.\nReturns the stored entry."
  (when accomplishments
    (let* ((tags (hive-mcp-workflows--wrap--make-tags '("session-summary" "wrap")))
        (date (hive-mcp-workflows--wrap--get-date))
        (content (format "## Session Summary: %s\n\n### Completed\n%s" date (mapconcat (lambda (a)
    (format "- [x] %s" a)) accomplishments "\n"))))
    (hive-mcp-memory-add 'note content tags nil 'short-term))))

(defun hive-mcp-workflows--wrap--store-decisions (decisions)
  "Store DECISIONS as decision entries with long-term duration.\nReturns list of stored entries."
  (when decisions
    (mapcar (lambda (decision)
    (let* ((tags (hive-mcp-workflows--wrap--make-tags '("wrap" "session-decision")))
        (date (hive-mcp-workflows--wrap--get-date))
        (content (list :title decision :rationale "Session decision" :date date)))
    (hive-mcp-memory-add 'decision content tags nil 'long-term))) decisions)))

(defun hive-mcp-workflows--wrap--store-conventions (conventions)
  "Store CONVENTIONS as convention entries with permanent duration.\nReturns list of stored entries."
  (when conventions
    (mapcar (lambda (convention)
    (let* ((tags (hive-mcp-workflows--wrap--make-tags '("wrap")))
        (date (hive-mcp-workflows--wrap--get-date))
        (content (list :description convention :date date)))
    (hive-mcp-memory-add 'convention content tags nil 'permanent))) conventions)))

(defun hive-mcp-workflows--wrap--sync-kanban (completed-task-ids)
  "Move COMPLETED-TASK-IDS to done status in kanban.\nReturns count of successfully moved tasks."
  (when (and completed-task-ids (fboundp 'hive-mcp-kanban-task-move))
    (let* ((moved 0))
    (dolist (task-id completed-task-ids)
    (condition-case nil
    (progn
  (hive-mcp-kanban-task-move task-id "done")
  (setq moved (1+ moved)))
  (error nil)))
    moved)))

(defun hive-mcp-workflows--wrap--get-kanban-status ()
  "Get kanban stats if available."
  (when (fboundp 'hive-mcp-kanban-stats)
    (condition-case nil
    (hive-mcp-kanban-stats)
  (error nil))))

(defun hive-mcp-workflows--wrap--gather-recent-notes (&rest args)
  (let ((directory (nthcdr 0 args)))
    "Get memory entries (notes/snippets) created today.\nDIRECTORY specifies the project directory for scoping queries."
  (let* ((today (format-time-string "%Y-%m-%d"))
        (project-id (when directory
    (hive-mcp-memory-project-id directory)))
        (notes (ignore-errors (hive-mcp-memory-query 'note nil project-id 20)))
        (snippets (ignore-errors (hive-mcp-memory-query 'snippet nil project-id 20))))
    (seq-filter (lambda (entry)
    (when-let ((created (plist-get entry :created)))
    (string-prefix-p today created))) (append (when (listp notes)
    notes) (when (listp snippets)
    snippets))))))

(defun hive-mcp-workflows--wrap--gather-git-commits (&rest args)
  (let ((directory (nthcdr 0 args)))
    "Get commits on current branch from today.\nDIRECTORY overrides `default-directory' if provided."
  (let* ((default-directory (or directory default-directory)))
    (let* ((output (shell-command-to-string "git log --since='midnight' --oneline 2>/dev/null")))
    (when (and output (not (string-empty-p output)))
    (split-string output "\n" t))))))

(defun hive-mcp-workflows--wrap--gather-kanban-activity (&rest args)
  (let ((directory (nthcdr 0 args)))
    "Get in-progress and review kanban tasks.\nDIRECTORY specifies the project directory for scoping queries."
  (when (fboundp 'hive-mcp-kanban-list-tasks)
    (condition-case nil
    (let* ((project-id (when directory
    (hive-mcp-memory-project-id directory))))
    (list :in-progress (hive-mcp-kanban-list-tasks project-id "inprogress") :review (hive-mcp-kanban-list-tasks project-id "inreview")))
  (error nil)))))

(defun hive-mcp-workflows--wrap--gather-channel-events ()
  "Get recent channel events if channel is active."
  (when (and (fboundp 'hive-mcp-channel-get-recent-events) (fboundp 'hive-mcp-channel-connected-p) (hive-mcp-channel-connected-p))
    (condition-case nil
    (hive-mcp-channel-get-recent-events 10)
  (error nil))))

(defun hive-mcp-workflows--wrap--gather-session-data (&rest args)
  (let ((directory (nthcdr 0 args)))
    "Auto-gather session data from all available sources.\nDIRECTORY specifies the project directory for git operations and project scoping.\nReturns plist with :recent-notes, :recent-commits,\n:kanban-activity, :ai-interactions."
  (list :recent-notes (hive-mcp-workflows--wrap--gather-recent-notes directory) :recent-commits (hive-mcp-workflows--wrap--gather-git-commits directory) :kanban-activity (hive-mcp-workflows--wrap--gather-kanban-activity directory) :ai-interactions (hive-mcp-workflows--wrap--gather-channel-events))))

(defun hive-mcp-workflows--wrap--merge-args (gathered provided)
  "Merge GATHERED data with user-PROVIDED args.\nPROVIDED takes precedence. Converts gathered data to wrap args format."
  (let* ((result (copy-sequence provided)))
    (unless (plist-get result :accomplishments)
    (when-let ((notes (plist-get gathered :recent-notes)))
    (plist-put result :accomplishments (mapcar (lambda (n)
    (let* ((content (plist-get n :content)))
    (if (> (length content) 100) (clel-concat (substring content 0 97) "...") content))) (seq-take notes 5)))))
    (when-let ((commits (plist-get gathered :recent-commits)))
    (unless (plist-get result :git-commits)
    (plist-put result :git-commits commits)))
    result))

(defun hive-mcp-workflows--wrap--emit-via-channel (args project-name)
  "Emit wrap-request event via channel for unified Clojure handling.\nARGS is the wrap arguments plist, PROJECT-NAME is the current project.\nReturns t if successfully sent, nil otherwise."
  (when (and (fboundp 'hive-mcp-channel-connected-p) (fboundp 'hive-mcp-channel-send) (hive-mcp-channel-connected-p))
    (let* ((event (list (cons "type" "wrap-request") (cons "accomplishments" (vconcat (plist-get args :accomplishments))) (cons "decisions" (vconcat (plist-get args :decisions))) (cons "conventions" (vconcat (plist-get args :conventions))) (cons "in-progress" (vconcat (plist-get args :in-progress))) (cons "next-actions" (vconcat (plist-get args :next-actions))) (cons "completed-tasks" (vconcat (plist-get args :completed-tasks))) (cons "project" project-name) (cons "timestamp" (float-time)))))
    (hive-mcp-channel-send event))))

(defun hive-mcp-workflows--wrap--store-locally (args)
  "Store wrap data locally (offline fallback path).\nARGS is the wrap arguments plist.\nReturns list of stored item symbols."
  (let* ((accomplishments (plist-get args :accomplishments))
        (decisions (plist-get args :decisions))
        (conventions (plist-get args :conventions))
        (in-progress (plist-get args :in-progress))
        (next-actions (plist-get args :next-actions))
        (date (hive-mcp-workflows--wrap--get-date))
        (stored nil))
    (when accomplishments
    (hive-mcp-workflows--wrap--store-accomplishments accomplishments)
    (push 'accomplishments stored))
    (when decisions
    (hive-mcp-workflows--wrap--store-decisions decisions)
    (push 'decisions stored))
    (when conventions
    (hive-mcp-workflows--wrap--store-conventions conventions)
    (push 'conventions stored))
    (when (or accomplishments decisions in-progress next-actions)
    (let* ((tags (hive-mcp-workflows--wrap--make-tags '("session-summary" "wrap" "full-summary")))
        (content (format "## Session Summary: %s\n\n### Completed\n%s\n\n### Decisions Made\n%s\n\n### In Progress\n%s\n\n### Next Actions\n%s" date (if accomplishments (mapconcat (lambda (a)
    (format "- [x] %s" a)) accomplishments "\n") "- (none)") (if decisions (mapconcat (lambda (d)
    (format "- %s" d)) decisions "\n") "- (none)") (if in-progress (mapconcat (lambda (ip)
    (format "- [ ] %s" ip)) in-progress "\n") "- (none)") (if next-actions (mapconcat (lambda (na)
    (format "- %s" na)) next-actions "\n") "- (none)"))))
    (hive-mcp-memory-add 'note content tags nil 'short-term)
    (push 'session-summary stored)))
    (nreverse stored)))

(defun hive-mcp-workflows-workflow-wrap (&rest args)
  (let ((args (nthcdr 0 args)))
    "Execute wrap workflow with ARGS plist.\n\nARGS can contain:\n  :accomplishments - list of completed tasks (stored as note, short-term)\n  :decisions - list of decisions made (stored as decision, long-term)\n  :conventions - list of conventions (stored as convention, permanent)\n  :in-progress - list of in-progress items (for summary)\n  :next-actions - list of next session priorities (for summary)\n  :completed-tasks - list of kanban task IDs to mark done\n\nOption A: If channel connected, emits wrap-request to Clojure.\nOffline fallback: stores locally.\n\nReturns structured result plist."
  (interactive)
  (let* ((project-name (hive-mcp-memory--get-project-name))
        (date (hive-mcp-workflows--wrap--get-date))
        (git-info (hive-mcp-workflows--wrap--git-status))
        (kanban-before (hive-mcp-workflows--wrap--get-kanban-status))
        (completed-tasks (plist-get args :completed-tasks))
        (expired-count 0)
        (stored nil)
        (path nil))
    (setq expired-count (hive-mcp-memory-cleanup-expired))
    (if (hive-mcp-workflows--wrap--emit-via-channel args project-name) (progn
  (setq path 'channel)
  (setq stored '(channel-emitted))) (progn
  (setq path 'local)
  (setq stored (hive-mcp-workflows--wrap--store-locally args))))
    (when completed-tasks
    (let* ((moved-count (hive-mcp-workflows--wrap--sync-kanban completed-tasks)))
    (when (> moved-count 0)
    (push 'kanban-synced stored))))
    (let* ((kanban-after (hive-mcp-workflows--wrap--get-kanban-status)))
    (list :success t :date date :project (or project-name "global") :path path :stored (if (eq path 'channel) stored (nreverse stored)) :counts (list :accomplishments (length (plist-get args :accomplishments)) :decisions (length (plist-get args :decisions)) :conventions (length (plist-get args :conventions)) :tasks-completed (length completed-tasks)) :expired-cleaned expired-count :git git-info :kanban (list :before kanban-before :after kanban-after) :summary (format "Session wrapped for %s via %s. Stored: %s. Cleaned %d expired entries." (or project-name "global") path (mapconcat #'symbol-name stored ", ") expired-count))))))

(defun hive-mcp-workflows--catchup--entry-to-meta (&rest args)
  (let ((entry (nth 0 args)) (preview-len (nthcdr 1 args)))
    "Convert ENTRY to metadata-only format as alist for proper JSON serialization.\nReturns alist with id, type, preview (PREVIEW-LEN chars, default 80), tags."
  (let* ((content (plist-get entry :content))
        (preview-length (or preview-len 80))
        (content-str (if (stringp content) content (format "%s" content)))
        (entry-type (plist-get entry :type))
        (type-str (if (symbolp entry-type) (symbol-name entry-type) (format "%s" entry-type))))
    (list (cons "id" (plist-get entry :id)) (cons "type" type-str) (cons "preview" (truncate-string-to-width content-str preview-length)) (cons "tags" (vconcat (plist-get entry :tags)))))))

(defun hive-mcp-workflows-workflow-catchup (&rest args)
  (let ((_args (nthcdr 0 args)))
    "Execute optimized catchup workflow - restore context from memory.\nReturns metadata-only format (~1.5k tokens vs ~10k for full content).\nUse `mcp_memory_get_full` to fetch specific entries by ID when needed.\nARGS is unused but accepted for workflow handler compatibility."
  (interactive)
  (let* ((project-name (hive-mcp-memory--get-project-name))
        (applicable-scopes (hive-mcp-memory--applicable-scope-tags))
        (session-notes-raw (hive-mcp-memory-query 'note '("session-summary") nil 3 nil nil))
        (decisions-raw (hive-mcp-memory-query 'decision nil nil 10 nil nil))
        (conventions-raw (hive-mcp-memory-query 'convention nil nil 10 nil nil))
        (snippets-raw (hive-mcp-memory-query 'snippet nil nil 5 nil nil))
        (expiring-raw (seq-take (hive-mcp-memory-query-expiring 7) 5))
        (session-meta (vconcat (mapcar #'hive-mcp-workflows--catchup--entry-to-meta session-notes-raw)))
        (decisions-meta (vconcat (mapcar #'hive-mcp-workflows--catchup--entry-to-meta decisions-raw)))
        (conventions-meta (vconcat (mapcar #'hive-mcp-workflows--catchup--entry-to-meta conventions-raw)))
        (snippets-meta (vconcat (mapcar (lambda (e)
    (hive-mcp-workflows--catchup--entry-to-meta e 60)) snippets-raw)))
        (expiring-meta (vconcat (mapcar #'hive-mcp-workflows--catchup--entry-to-meta expiring-raw)))
        (git-branch (string-trim (shell-command-to-string "git rev-parse --abbrev-ref HEAD 2>/dev/null || echo 'none'")))
        (uncommitted (not (string-empty-p (shell-command-to-string "git status --porcelain 2>/dev/null"))))
        (last-commit (string-trim (shell-command-to-string "git log -1 --format='%h - %s' 2>/dev/null || echo 'none'"))))
    (list :success t :project project-name :scopes applicable-scopes :git (list :branch git-branch :uncommitted uncommitted :last-commit last-commit) :counts (list :sessions (length session-meta) :decisions (length decisions-meta) :conventions (length conventions-meta) :snippets (length snippets-meta) :expiring (length expiring-meta)) :context (list :sessions session-meta :decisions decisions-meta :conventions conventions-meta :snippets snippets-meta :expiring expiring-meta) :hint "Use mcp_memory_get_full with ID to fetch full content"))))

(defun hive-mcp-workflows---register-builtins ()
  "Register built-in example workflows.\nIdempotent: only registers if not already present."
  (unless (gethash "quick-note" hive-mcp-workflow-registry)
    (puthash "quick-note" '(:name "quick-note" :description "Add a quick note with current context" :steps ((:type :prompt :message "Note" :var :note-text) (:type :memory-add :mem-type "note" :content "${note-text}") (:type :notify :message "Note saved!"))) hive-mcp-workflow-registry))
  (unless (gethash "commit" hive-mcp-workflow-registry)
    (puthash "commit" '(:name "commit" :description "Stage all and commit with message" :params ((:name "message" :required t)) :steps ((:type :shell :command "git add -A") (:type :shell :command "git commit -m \"${message}\"") (:type :notify :message "Committed: ${message}"))) hive-mcp-workflow-registry))
  (unless (gethash "wrap" hive-mcp-workflow-registry)
    (puthash "wrap" '(:name "wrap" :description "End-of-session wrap-up (Memory-Integrated)" :params ((:name "accomplishments" :type list :required nil :description "List of completed tasks") (:name "decisions" :type list :required nil :description "List of decisions made") (:name "conventions" :type list :required nil :description "List of conventions to store permanently") (:name "in-progress" :type list :required nil :description "List of in-progress items") (:name "next-actions" :type list :required nil :description "List of next session priorities") (:name "completed-tasks" :type list :required nil :description "Kanban task IDs to mark done")) :handler hive-mcp-workflows-workflow-wrap) hive-mcp-workflow-registry))
  (unless (gethash "catchup" hive-mcp-workflow-registry)
    (puthash "catchup" '(:name "catchup" :description "Catch Up (Memory-Integrated)" :handler hive-mcp-workflows-workflow-catchup) hive-mcp-workflow-registry)))

(hive-mcp-workflows--register-builtins)

(provide 'hive-mcp-workflows)

(provide 'hive-mcp-workflows)
;;; hive-mcp-workflows.el ends here
