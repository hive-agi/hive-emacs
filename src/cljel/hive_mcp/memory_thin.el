;;; hive-mcp-memory.el --- -*- lexical-binding: t; -*-
;; Generated by ClojureElisp

(require 'clojure-elisp-runtime)

;;; Code:



(require 'project)

(require 'seq)

(require 'parseedn)

(unless (fboundp 'plistp)
    (defun plistp (object) "Return non-nil if OBJECT is a plist." (and (listp object) (or (null object) (and (keywordp (car object)) (plistp (cddr object)))))))

(defgroup hive-mcp-memory nil
  "Memory and persistence settings for hive-mcp."
  :group 'hive-mcp
  :prefix "hive-mcp-memory-")

(defcustom hive-mcp-conversation-max-entries 100
  "Maximum conversation log entries per project.\nSent to server as configuration hint."
  :group 'hive-mcp-memory
  :type 'integer)

(defcustom hive-mcp-project-config-file ".hive-project.edn"
  "Filename for project-specific hive-mcp configuration.\nThis file should contain an EDN map with at least :project-id key.\nExample: {:project-id \"my-project\" :aliases [\"old-name\"]}"
  :group 'hive-mcp-memory
  :type 'string)

(defconst durations '(ephemeral short medium long permanent) "Valid duration categories, ordered shortest to longest.\nThese correspond to Chroma metadata TTL values.")

(defcustom hive-mcp-memory-duration-days '((ephemeral . 1) (short . 7) (medium . 30) (long . 90) (permanent . nil))
  "Days before expiration per duration. nil = never expires.\nUsed for client-side duration display and hints."
  :group 'hive-mcp-memory
  :type '(alist :key-type symbol :value-type (choice integer (const nil))))

(defcustom hive-mcp-memory-default-duration 'medium
  "Default duration for new entries."
  :group 'hive-mcp-memory
  :type 'symbol)

(defvar hive-mcp-memory--project-config-cache (make-hash-table :test 'equal)
  "Cache for project config files. Maps project-root to parsed config.")

(defvar hive-mcp-memory--cache (make-hash-table :test 'equal)
  "Compatibility variable for hive-mcp-reset.\nIn thin/Chroma-delegate mode this is unused; storage is server-side.\nKept so (clrhash hive-mcp-memory--cache) in hive-mcp.el doesn't error.")

(defvar hive-mcp-memory-add-hook nil
  "Hook run after adding memory entry. Args: TYPE ENTRY PROJECT-ID.")

(defun hive-mcp-memory---parse-edn-string (str)
  "Parse an EDN string STR into elisp using parseedn.\nReturns a hash-table for maps, vectors for vectors, etc."
  (parseedn-read-str str))

(defun hive-mcp-memory---edn-get (edn key)
  "Get KEY from EDN hash-table or alist.\nKEY should be a keyword symbol like :project-id."
  (cond
  ((hash-table-p edn) (gethash key edn))
  ((listp edn) (cdr (assoc key edn)))
  (t nil)))

(defun hive-mcp-memory---read-project-config (&optional project-root)
  "Read and parse .hive-project.edn from PROJECT-ROOT.\nReturns alist of config values, or nil if file doesn't exist.\nCaches result per project root."
  (let* ((root (or project-root (hive-mcp-memory---get-project-root)))
        (cached (gethash root hive-mcp-memory--project-config-cache 'not-found)))
    (if (not (eq cached 'not-found)) cached (let* ((config-path (when root
    (expand-file-name hive-mcp-project-config-file root)))
        (config (when (and config-path (file-exists-p config-path))
    (condition-case nil
    (hive-mcp-memory---parse-edn-string (with-temp-buffer
    (insert-file-contents config-path)
    (buffer-string)))
  (error nil)))))
    (puthash root config hive-mcp-memory--project-config-cache)
    config))))

(defun hive-mcp-memory---get-stable-project-id (&optional project-root)
  "Get stable project ID from config file at PROJECT-ROOT.\nReturns the :project-id value from .hive-project.edn, or nil if not found."
  (when-let-star (list config (hive-mcp-memory---read-project-config project-root) project-id (hive-mcp-memory---edn-get config :project-id)) (if (stringp project-id) project-id (symbol-name project-id))))

(defun hive-mcp-memory-clear-config-cache ()
  "Clear the project config cache. Call after editing .hive-project.edn."
  (interactive)
  (clrhash hive-mcp-memory--project-config-cache)
  (message "Cleared hive-mcp project config cache"))

(defun hive-mcp-memory---get-project-root ()
  "Get current project root, or nil if not in a project."
  (when-let-star (list proj (project-current)) (project-root proj)))

(defun hive-mcp-memory---get-project-name ()
  "Get current project name (directory basename), or nil if not in a project."
  (when-let-star (list root (hive-mcp-memory---get-project-root)) (file-name-nondirectory (directory-file-name root))))

(defun hive-mcp-memory---project-id (&optional project-root)
  "Return unique ID for PROJECT-ROOT (defaults to current project).\nResolution order:\n  1. Stable :project-id from .hive-project.edn (survives renames)\n  2. Fallback: SHA1 hash of absolute path (filesystem-safe)\nReturns \"global\" if not in a project.\nPROJECT-ROOT must be a string path or nil."
  (let* ((root (cond
  ((stringp project-root) project-root)
  ((null project-root) (hive-mcp-memory---get-project-root))
  (t (progn
  (message "[hive-mcp] Warning: project-root not a string: %S" project-root)
  (hive-mcp-memory---get-project-root))))))
    (if root (or (hive-mcp-memory---get-stable-project-id root) (substring (sha1 (expand-file-name root)) 0 16)) "global")))

(defun hive-mcp-memory---project-id-hash (&optional project-root)
  "Return SHA1 hash ID for PROJECT-ROOT (ignores config).\nUse this for migration when you need the path-based hash.\nPROJECT-ROOT must be a string path or nil."
  (let* ((root (cond
  ((stringp project-root) project-root)
  ((null project-root) (hive-mcp-memory---get-project-root))
  (t (progn
  (message "[hive-mcp] Warning: project-root not a string: %S" project-root)
  (hive-mcp-memory---get-project-root))))))
    (if root (substring (sha1 (expand-file-name root)) 0 16) "global")))

(defun hive-mcp-memory---make-scope-tag (level &optional name)
  "Create a scope tag for LEVEL with optional NAME.\nLEVEL is one of: global, domain, project.\nNAME is required for domain and project levels."
  (pcase level
  ((quote global) "scope:global")
  ((quote domain) (format "scope:domain:%s" name))
  ((quote project) (format "scope:project:%s" name))
  ('_ (error "Invalid scope level: %s" level))))

(defun hive-mcp-memory---parse-scope-tag (tag)
  "Parse a scope TAG into (level . name) cons.\nReturns nil if TAG is not a scope tag."
  (cond
  ((string= tag "scope:global") '(global . nil))
  ((string-prefix-p "scope:domain:" tag) (cons 'domain (substring tag (length "scope:domain:"))))
  ((string-prefix-p "scope:project:" tag) (cons 'project (substring tag (length "scope:project:"))))
  (t nil)))

(defun hive-mcp-memory---has-scope-tag-p (tags)
  "Return non-nil if TAGS contains any scope tag."
  (seq-some (lambda (tag)
    (string-prefix-p "scope:" tag)) tags))

(defun hive-mcp-memory---inject-project-scope (tags)
  "Inject current project scope into TAGS if no scope present.\nReturns modified tags list."
  (if (hive-mcp-memory---has-scope-tag-p tags) tags (if-let-star (list project-name (hive-mcp-memory---get-project-name)) (cons (hive-mcp-memory---make-scope-tag 'project project-name) tags) tags)))

(defun hive-mcp-memory---applicable-scope-tags (&optional project-name domain-name)
  "Return list of scope tags applicable to current context.\nPROJECT-NAME defaults to current project.\nDOMAIN-NAME is optional domain filter.\nAlways includes scope:global."
  (let* ((tags (list "scope:global")))
    (when domain-name
    (push (hive-mcp-memory---make-scope-tag 'domain domain-name) tags))
    (when-let-star (list proj (or project-name (hive-mcp-memory---get-project-name))) (push (hive-mcp-memory---make-scope-tag 'project proj) tags))
    tags))

(defun hive-mcp-memory---calculate-expires (duration)
  "Calculate expiration timestamp for DURATION.\nReturns ISO 8601 timestamp or nil for permanent entries.\nUsed for client-side display; actual TTL managed by Chroma."
  (let* ((days (alist-get duration hive-mcp-memory-duration-days)))
    (cond
  ((null days) nil)
  ((equal days 0) (format-time-string "%FT%T%z"))
  (t (format-time-string "%FT%T%z" (time-add (current-time) (days-to-time days)))))))

(defun hive-mcp-memory---duration-next (duration)
  "Return next longer DURATION in hierarchy, or nil if permanent."
  (let* ((pos (seq-position hive-mcp-memory-durations duration)))
    (when (and pos (< (1+ pos) (length hive-mcp-memory-durations)))
    (nth (1+ pos) hive-mcp-memory-durations))))

(defun hive-mcp-memory---duration-prev (duration)
  "Return next shorter DURATION in hierarchy, or nil if ephemeral."
  (let* ((pos (seq-position hive-mcp-memory-durations duration)))
    (when (and pos (> pos 0))
    (nth (1- pos) hive-mcp-memory-durations))))

(defun hive-mcp-memory---generate-id ()
  "Generate a unique ID for memory entries.\nNote: In Chroma-delegate mode, IDs are generated server-side.\nThis is provided for backwards compatibility."
  (format "%s-%s" (format-time-string "%Y%m%d%H%M%S") (substring (md5 (format "%s%s" (random) (current-time))) 0 8)))

(defun hive-mcp-memory---timestamp ()
  "Return current ISO 8601 timestamp."
  (format-time-string "%FT%T%z"))

(defun hive-mcp-memory---normalize-content (content)
  "Normalize CONTENT for consistent hashing.\nTrims whitespace, collapses multiple spaces/newlines."
  (let* ((text (cond
  ((stringp content) content)
  ((plistp content) (format "%S" content))
  (t (format "%S" content)))))
    (setq text (string-trim text))
    (setq text (replace-regexp-in-string "[ \t]+" " " text))
    (setq text (replace-regexp-in-string "\n+" "\n" text))
    text))

(defun hive-mcp-memory-content-hash (content)
  "Compute SHA-256 hash of normalized CONTENT.\nReturns a 64-character hex string."
  (secure-hash 'sha256 (hive-mcp-memory---normalize-content content)))

(defalias 'hive-mcp-memory--project-id 'hive-mcp-memory---project-id)

(defalias 'hive-mcp-memory--project-id-hash 'hive-mcp-memory---project-id-hash)

(defalias 'hive-mcp-memory--get-project-root 'hive-mcp-memory---get-project-root)

(defalias 'hive-mcp-memory--get-project-name 'hive-mcp-memory---get-project-name)

(defalias 'hive-mcp-memory--make-scope-tag 'hive-mcp-memory---make-scope-tag)

(defalias 'hive-mcp-memory--parse-scope-tag 'hive-mcp-memory---parse-scope-tag)

(defalias 'hive-mcp-memory--has-scope-tag-p 'hive-mcp-memory---has-scope-tag-p)

(defalias 'hive-mcp-memory--inject-project-scope 'hive-mcp-memory---inject-project-scope)

(defalias 'hive-mcp-memory--applicable-scope-tags 'hive-mcp-memory---applicable-scope-tags)

(defalias 'hive-mcp-memory--calculate-expires 'hive-mcp-memory---calculate-expires)

(defalias 'hive-mcp-memory--duration-next 'hive-mcp-memory---duration-next)

(defalias 'hive-mcp-memory--duration-prev 'hive-mcp-memory---duration-prev)

(defalias 'hive-mcp-memory--generate-id 'hive-mcp-memory---generate-id)

(defalias 'hive-mcp-memory--timestamp 'hive-mcp-memory---timestamp)

(defalias 'hive-mcp-memory--normalize-content 'hive-mcp-memory---normalize-content)

(defalias 'hive-mcp-memory--parse-edn-string 'hive-mcp-memory---parse-edn-string)

(defalias 'hive-mcp-memory--edn-get 'hive-mcp-memory---edn-get)

(defalias 'hive-mcp-memory--read-project-config 'hive-mcp-memory---read-project-config)

(defalias 'hive-mcp-memory--get-stable-project-id 'hive-mcp-memory---get-stable-project-id)

(defalias 'hive-mcp-memory--cider-delegate 'hive-mcp-memory---cider-delegate)

(defalias 'hive-mcp-memory--build-clj-call 'hive-mcp-memory---build-clj-call)

(defalias 'hive-mcp-memory--delegate 'hive-mcp-memory---delegate)

(defalias 'hive-mcp-memory-project-id 'hive-mcp-memory---project-id)

(defalias 'hive-mcp-memory-project-id-hash 'hive-mcp-memory---project-id-hash)

(defalias 'hive-mcp-memory-project-get-root 'hive-mcp-memory---get-project-root)

(defalias 'hive-mcp-memory-project-get-name 'hive-mcp-memory---get-project-name)

(defvar hive-mcp-memory--storage-delegate nil
  "Function to call for storage operations.\nShould accept (op type &rest args) and delegate to MCP.\nIf nil, storage operations will error with instructions.")

(defun hive-mcp-memory---cider-delegate (&rest args)
  (let ((op (nth 0 args)) (args (nthcdr 1 args)))
    "Delegate memory operation OP to Clojure MCP handlers via CIDER.\nOP is one of: add, get, query, update, delete.\nARGS vary by operation:\n  - add: type content tags project-id duration\n  - get: id project-id\n  - query: type tags project-id limit duration scope-filter\n  - update: id updates project-id\n  - delete: id project-id\nReturns the result from Clojure or nil on failure."
  (unless (and (featurep 'cider) (cider-connected-p))
    (error "CIDER not connected. Memory operations require nREPL connection"))
  (condition-case err
    (let* ((clj-code (hive-mcp-memory---build-clj-call op args))
        (response (cider-nrepl-send-sync-request (list "op" "eval" "code" clj-code "ns" "hive-mcp.tools.memory")))
        (value (nrepl-dict-get response "value"))
        (err-msg (nrepl-dict-get response "err")))
    (when err-msg
    (message "[hive-mcp-memory] Error: %s" err-msg))
    (when value
    (car (read-from-string value))))
  (error (message "[hive-mcp-memory] CIDER delegate error: %s" (error-message-string err))
      nil))))

(defun hive-mcp-memory---build-clj-call (op args)
  "Build Clojure code to call MCP handler for OP with ARGS.\nMaps elisp operations to the Clojure consolidated memory tool commands."
  (pcase op
  ((quote add) (let* ((type (nth 0 args))
        (content (nth 1 args))
        (tags (nth 2 args))
        (project-id (nth 3 args))
        (duration (nth 4 args)))
    (format "(hive-mcp.tools.memory/handle-memory {:command \"add\" :type %S :content %S :tags %s :directory %s :duration %s})" (symbol-name type) (if (stringp content) content (prin1-to-string content)) (if tags (format "[%s]" (mapconcat (lambda (tag)
    (format "%S" tag)) tags " ")) "nil") (if project-id (format "\"%s\"" project-id) "nil") (if duration (format "\"%s\"" (symbol-name duration)) "nil"))))
  ((quote get) (let* ((id (nth 0 args))
        (project-id (nth 1 args)))
    (format "(hive-mcp.tools.memory/handle-memory {:command \"get\" :id %S :directory %s})" id (if project-id (format "\"%s\"" project-id) "nil"))))
  ((quote query) (let* ((type (nth 0 args))
        (tags (nth 1 args))
        (project-id (nth 2 args))
        (limit (nth 3 args))
        (duration (nth 4 args))
        (scope-filter (nth 5 args)))
    (format "(hive-mcp.tools.memory/handle-memory {:command \"query\" :type %S :tags %s :directory %s :limit %s :duration %s :scope %s})" (when type
    (symbol-name type)) (if tags (format "[%s]" (mapconcat (lambda (tag)
    (format "%S" tag)) tags " ")) "nil") (if project-id (format "\"%s\"" project-id) "nil") (or limit "20") (if duration (format "\"%s\"" duration) "nil") (if scope-filter (format "\"%s\"" scope-filter) "nil"))))
  ((quote search) (let* ((query (nth 0 args))
        (project-id (nth 1 args))
        (limit (nth 2 args)))
    (format "(hive-mcp.tools.memory/handle-memory {:command \"search\" :query %S :directory %s :limit %s})" query (if project-id (format "\"%s\"" project-id) "nil") (or limit "10"))))
  ((quote metadata) (let* ((type (nth 0 args))
        (tags (nth 1 args))
        (project-id (nth 2 args))
        (limit (nth 3 args)))
    (format "(hive-mcp.tools.memory/handle-memory {:command \"metadata\" :type %S :tags %s :directory %s :limit %s :verbosity \"metadata\"})" (when type
    (symbol-name type)) (if tags (format "[%s]" (mapconcat (lambda (tag)
    (format "%S" tag)) tags " ")) "nil") (if project-id (format "\"%s\"" project-id) "nil") (or limit "20"))))
  ((quote update) (let* ((id (nth 0 args))
        (updates (nth 1 args))
        (_project-id (nth 2 args)))
    (format "(hive-mcp.tools.memory/handle-memory {:command \"tags\" :id %S :tags %s})" id (if updates (format "[%s]" (mapconcat (lambda (tag)
    (format "%S" tag)) updates " ")) "nil"))))
  ((quote delete) (let* ((id (nth 0 args)))
    (format "(hive-mcp.tools.memory/handle-memory {:command \"expire\" :id %S})" id)))
  ((quote duration) (let* ((id (nth 0 args))
        (duration (nth 1 args)))
    (format "(hive-mcp.tools.memory/handle-memory {:command \"duration\" :id %S :duration %S})" id (symbol-name duration))))
  ((quote promote) (let* ((id (nth 0 args)))
    (format "(hive-mcp.tools.memory/handle-memory {:command \"promote\" :id %S})" id)))
  ((quote demote) (let* ((id (nth 0 args)))
    (format "(hive-mcp.tools.memory/handle-memory {:command \"demote\" :id %S})" id)))
  ((quote feedback) (let* ((id (nth 0 args))
        (rating (nth 1 args)))
    (format "(hive-mcp.tools.memory/handle-memory {:command \"feedback\" :id %S :feedback %S})" id rating)))
  ((quote log-access) (let* ((id (nth 0 args)))
    (format "(hive-mcp.tools.memory/handle-memory {:command \"log_access\" :id %S})" id)))
  ((quote helpfulness) (let* ((id (nth 0 args)))
    (format "(hive-mcp.tools.memory/handle-memory {:command \"helpfulness\" :id %S})" id)))
  ((quote cleanup) (let* ((project-id (nth 0 args)))
    (format "(hive-mcp.tools.memory/handle-memory {:command \"cleanup\" :directory %s})" (if project-id (format "\"%s\"" project-id) "nil"))))
  ((quote expiring) (let* ((days (nth 0 args))
        (project-id (nth 1 args)))
    (format "(hive-mcp.tools.memory/handle-memory {:command \"expiring\" :days %d :directory %s})" (or days 7) (if project-id (format "\"%s\"" project-id) "nil"))))
  ((quote migrate) (let* ((old-project-id (nth 0 args))
        (new-project-id (nth 1 args)))
    (format "(hive-mcp.tools.memory/handle-memory {:command \"migrate\" :old-project-id %S :new-project-id %S})" old-project-id new-project-id)))
  ('_ (error "Unknown memory operation: %s" op))))

(defun hive-mcp-memory-init-cider-delegate ()
  "Initialize the CIDER-based storage delegate.\nCall this after CIDER connects to enable memory operations."
  (interactive)
  (setq hive-mcp-memory--storage-delegate #'hive-mcp-memory---cider-delegate)
  (message "hive-mcp-memory: CIDER delegate initialized"))

(provide 'hive-mcp-memory)
;;; hive-mcp-memory.el ends here
