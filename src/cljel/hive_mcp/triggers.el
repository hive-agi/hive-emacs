;;; hive-mcp-triggers.el --- -*- lexical-binding: t; -*-
;; Generated by ClojureElisp

(require 'clojure-elisp-runtime)

;;; Code:



(require 'hive-mcp-memory)

(require 'hive-mcp-context)

(defvar hive-mcp-mode-map)

(defgroup hive-mcp-triggers nil
  "Trigger and automation settings for hive-mcp."
  :group 'hive-mcp
  :prefix "hive-mcp-trigger-")

(defcustom hive-mcp-keymap-prefix nil
  "Prefix key for hive-mcp commands.\nSet this in your init file before enabling `hive-mcp-mode'.\nExample: (setq hive-mcp-keymap-prefix (kbd \"C-c m\"))\nNote: Control-c <letter> is reserved for user bindings per Emacs conventions."
  :group 'hive-mcp-triggers
  :type '(choice (const :tag "None" nil) key-sequence))

(defcustom hive-mcp-after-save-hook-enabled nil
  "When non-nil, run hive-mcp hooks after saving files."
  :group 'hive-mcp-triggers
  :type 'boolean)

(defvar hive-mcp-trigger-registry (make-hash-table :test 'equal)
  "Registry of user-defined triggers.\nEach entry is NAME -> plist with :event :condition :action.")

(defun hive-mcp-triggers-register-trigger (name trigger-spec)
  "Register a trigger with NAME and TRIGGER-SPEC.\nTRIGGER-SPEC is a plist with :event, :condition, :action keys.\nEvents: after-save, compilation-finish, diagnostics-error, custom."
  (puthash name trigger-spec hive-mcp-trigger-registry))

(defun hive-mcp-triggers-unregister-trigger (name)
  "Remove trigger with NAME."
  (remhash name hive-mcp-trigger-registry))

(defun hive-mcp-triggers-list-triggers ()
  "Return list of registered triggers."
  (let* ((triggers nil))
    (maphash (lambda (k v)
    (push (list :name k :event (plist-get v :event) :description (plist-get v :description)) triggers)) hive-mcp-trigger-registry)
    (nreverse triggers)))

(defun hive-mcp-triggers-trigger-run (event &optional data)
  "Run all triggers matching EVENT with optional DATA."
  (maphash (lambda (_name spec)
    (when (eq (plist-get spec :event) event)
    (let* ((condition (plist-get spec :condition))
        (action (plist-get spec :action)))
    (when (or (null condition) (funcall condition data))
    (condition-case err
    (funcall action data)
  (error (message "MCP trigger error: %s" (error-message-string err)))))))) hive-mcp-trigger-registry))

(defvar hive-mcp-command-map (let* ((map (make-sparse-keymap)))
    (define-key map (kbd "m") #'hive-mcp-transient-menu)
    (define-key map (kbd "n") #'hive-mcp-add-note-interactive)
    (define-key map (kbd "s") #'hive-mcp-add-snippet-interactive)
    (define-key map (kbd "c") #'hive-mcp-add-convention-interactive)
    (define-key map (kbd "d") #'hive-mcp-add-decision-interactive)
    (define-key map (kbd "l") #'hive-mcp-show-memory)
    (define-key map (kbd "x") #'hive-mcp-show-context)
    (define-key map (kbd "w") #'hive-mcp-run-workflow-interactive)
    (define-key map (kbd "W") #'hive-mcp-define-workflow-interactive)
    (define-key map (kbd "h") #'hive-mcp-show-conversation-history)
    (define-key map (kbd "H") #'hive-mcp-clear-conversation)
    map)
  "Keymap for hive-mcp commands.")

(defun hive-mcp-triggers-setup-keybindings ()
  "Set up hive-mcp keybindings.\nOnly sets up keybindings if `hive-mcp-keymap-prefix' is configured.\nUsers should set this in their init file before enabling `hive-mcp-mode'.\nExample configuration:\n  (setq hive-mcp-keymap-prefix (kbd \"C-c m\"))\n  (hive-mcp-mode 1)"
  (when hive-mcp-keymap-prefix
    (define-key hive-mcp-mode-map hive-mcp-keymap-prefix hive-mcp-command-map)))

(defun hive-mcp-triggers-add-note-interactive ()
  "Interactively add a note to project memory."
  (interactive)
  (let* ((content (clel-read-string "Note: "))
        (tags-str (clel-read-string "Tags (comma-separated, optional): "))
        (tags (when (not (string-empty-p tags-str))
    (split-string tags-str "," t "\\s-*"))))
    (hive-mcp-memory-add-note content tags)
    (message "Note added to project memory")))

(defun hive-mcp-triggers-add-snippet-interactive ()
  "Save region or prompt for code as a snippet."
  (interactive)
  (let* ((code (if (use-region-p) (buffer-substring-no-properties (region-beginning) (region-end)) (clel-read-string "Code: ")))
        (name (clel-read-string "Snippet name: "))
        (language (hive-mcp-context-language))
        (tags-str (clel-read-string "Tags (comma-separated, optional): "))
        (tags (when (not (string-empty-p tags-str))
    (split-string tags-str "," t "\\s-*"))))
    (hive-mcp-memory-add-snippet name code language tags)
    (message "Snippet '%s' saved" name)))

(defun hive-mcp-triggers-add-convention-interactive ()
  "Interactively add a project convention."
  (interactive)
  (let* ((description (clel-read-string "Convention: "))
        (example (clel-read-string "Example (optional): ")))
    (hive-mcp-memory-add-convention description (unless (string-empty-p example)
    example))
    (message "Convention added")))

(defun hive-mcp-triggers-add-decision-interactive ()
  "Interactively record an architecture decision."
  (interactive)
  (let* ((title (clel-read-string "Decision title: "))
        (rationale (clel-read-string "Rationale: "))
        (alternatives (clel-read-string "Alternatives considered (optional): ")))
    (hive-mcp-memory-add-decision title rationale (unless (string-empty-p alternatives)
    alternatives))
    (message "Decision recorded")))

(defun hive-mcp-triggers-show-memory ()
  "Display project memory in a buffer."
  (interactive)
  (let* ((buf (get-buffer-create "*hive-mcp-memory*"))
        (context (hive-mcp-memory-get-project-context)))
    (with-current-buffer buf
    (erase-buffer)
    (insert "= Project Memory =\n")
    (insert (format "Project: %s\n\n" (or (plist-get context :project-root) "global")))
    (insert "== Notes ==\n")
    (dolist (note (plist-get context :notes))
    (insert (format "- %s [%s]\n" (plist-get note :content) (plist-get note :created))))
    (insert "\n")
    (insert "== Conventions ==\n")
    (dolist (conv (plist-get context :conventions))
    (let* ((c (plist-get conv :content)))
    (insert (format "- %s\n" (plist-get c :description)))
    (when-let-star (list ex (plist-get c :example)) (insert (format "  Example: %s\n" ex)))))
    (insert "\n")
    (insert "== Recent Decisions ==\n")
    (dolist (dec (plist-get context :recent-decisions))
    (let* ((d (plist-get dec :content)))
    (insert (format "- %s\n  %s\n" (plist-get d :title) (plist-get d :rationale)))))
    (insert "\n")
    (insert "== Snippets ==\n")
    (dolist (snip (plist-get context :snippets))
    (let* ((s (plist-get snip :content)))
    (insert (format "- %s [%s]\n" (plist-get s :name) (plist-get s :language)))))
    (goto-char (point-min)))
    (display-buffer buf)))

(defun hive-mcp-triggers-show-context ()
  "Display current context in a buffer (for debugging)."
  (interactive)
  (let* ((buf (get-buffer-create "*hive-mcp-context*"))
        (context (hive-mcp-context-full)))
    (with-current-buffer buf
    (erase-buffer)
    (insert "= Current Context =\n\n")
    (insert (pp-to-string context))
    (goto-char (point-min))
    (emacs-lisp-mode))
    (display-buffer buf)))

(defun hive-mcp-triggers-show-conversation-history ()
  "Display conversation history."
  (interactive)
  (let* ((buf (get-buffer-create "*hive-mcp-conversations*"))
        (history (hive-mcp-memory-query 'conversation nil nil 50)))
    (with-current-buffer buf
    (erase-buffer)
    (insert "= Conversation History =\n\n")
    (dolist (entry (reverse history))
    (let* ((c (plist-get entry :content)))
    (insert (format "[%s] %s:\n%s\n\n" (plist-get entry :created) (plist-get c :role) (plist-get c :content)))))
    (goto-char (point-min)))
    (display-buffer buf)))

(defun hive-mcp-triggers-clear-conversation ()
  "Clear conversation history for current project."
  (interactive)
  (when (yes-or-no-p "Clear conversation history? ")
    (let* ((pid (hive-mcp-memory--project-id)))
    (hive-mcp-memory--set-data pid "conversation" '())
    (message "Conversation history cleared"))))

(defun hive-mcp-triggers---after-save-handler ()
  "Handler for `after-save-hook'."
  (when hive-mcp-after-save-hook-enabled
    (hive-mcp-trigger-run 'after-save (list :file (buffer-file-name) :buffer (current-buffer) :mode major-mode))))

(defun hive-mcp-triggers---compilation-finish-handler (buffer status)
  "Handler for `compilation-finish-functions'.\nBUFFER is the compilation buffer, STATUS is the result string."
  (hive-mcp-trigger-run 'compilation-finish (list :buffer buffer :status status :success (string-match-p "finished" status))))

(defun hive-mcp-triggers-setup-hooks ()
  "Set up hive-mcp hooks."
  (add-hook 'after-save-hook #'hive-mcp-triggers--after-save-handler)
  (add-hook 'compilation-finish-functions #'hive-mcp-triggers--compilation-finish-handler))

(defun hive-mcp-triggers-run-workflow-interactive ()
  "Run a workflow interactively."
  (interactive)
  (if (fboundp 'hive-mcp-workflow-run-interactive) (call-interactively #'hive-mcp-workflow-run-interactive) (message "Workflows not loaded yet")))

(defun hive-mcp-triggers-define-workflow-interactive ()
  "Define a new workflow interactively."
  (interactive)
  (message "Use `hive-mcp-workflow-register' to define workflows programmatically"))

(defun hive-mcp-triggers-transient-menu ()
  "Open the main hive-mcp transient menu."
  (interactive)
  (if (fboundp 'hive-mcp-transient-main) (hive-mcp-transient-main) (message "Use C-c m <key> for quick access. Menu requires transient package.")))

(provide 'hive-mcp-triggers)

(provide 'hive-mcp-triggers)
;;; hive-mcp-triggers.el ends here
