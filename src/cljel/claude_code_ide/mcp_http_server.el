;;; claude-code-ide-mcp-http-server.el --- -*- lexical-binding: t; -*-
;; Generated by ClojureElisp

(require 'clojure-elisp-runtime)
(require 'json)
(require 'cl-lib)
(require 'url-parse)
(require 'claude-code-ide-debug)
(require 'claude-code-ide-mcp-server)

;;; Code:



(defvar claude-code-ide-mcp-server--current-session-id nil)

(unless (featurep 'web-server)
    (condition-case err
    (require 'web-server)
  (error (claude-code-ide-debug "Failed to load web-server package: %s" (error-message-string err)))))

(declare-function ws-process "web-server" (server))

(declare-function ws-start "web-server" (handlers port &optional log-buffer &rest network-args))

(declare-function ws-stop "web-server" (server))

(declare-function ws-send-404 "web-server" (proc &optional info))

(declare-function ws-headers "web-server" (request))

(declare-function ws-body "web-server" (request))

(declare-function ws-send "web-server" (proc msg))

(declare-function ws-response-header "web-server" (proc code &rest headers))

(defvar claude-code-ide-mcp-http-server--server nil)

(defun claude-code-ide-mcp-http-server---extract-session-id-from-path (headers)
  "Extract session ID from URL path in HEADERS.\nThe web-server package stores the URL path in headers with the\nHTTP method as the key (e.g., :POST -> \"/mcp/session-id\").\nReturns the session ID or nil if not found."
  (let* ((url (or (cdr (clel-assoc :POST headers)) (cdr (clel-assoc :GET headers))))
        (_ (when url
    (claude-code-ide-debug "MCP request URL: %s" url))))
    (when (and url (string-match "^/mcp/\\([^/?]+\\)" url))
    (match-string 1 url))))

(defun claude-code-ide-mcp-http-server-start (&optional port)
  "Start the MCP HTTP server on PORT.\nIf PORT is nil, a random available port is selected.\nReturns a cons cell of (server . port)."
  (unless (featurep 'web-server)
    (error "web-server package is not available"))
  (claude-code-ide-debug "Attempting to start MCP server on port %s" (or port "auto"))
  (condition-case err
    (let* ((selected-port (or port 0))
        (server (ws-start (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list :GET) (clojure-core-list '.) (clojure-core-list "^/mcp\\(/.*\\)?$")))) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'var) (clojure-core-list 'clojure.core/-handle-get))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list :POST) (clojure-core-list '.) (clojure-core-list "^/mcp\\(/.*\\)?$")))) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'var) (clojure-core-list 'clojure.core/-handle-post))))))))) selected-port nil :host "127.0.0.1")))
    (setq claude-code-ide-mcp-http-server--server server)
    (let* ((process (ws-process server))
        (actual-port (process-contact process :service)))
    (claude-code-ide-debug "MCP server started on port %d" actual-port)
    (set-process-sentinel process (lambda (proc event)
    (claude-code-ide-debug "MCP server process event: %s" event)
    (when (string-match-p "\\(exited\\|killed\\|terminated\\)" event)
    (claude-code-ide-debug "MCP server died unexpectedly"))))
    (cons server actual-port)))
  (error (claude-code-ide-debug "Failed to start web server: %s" (error-message-string err))
      (signal 'error (list (format "Failed to start web server: %s" (error-message-string err)))))))

(defun claude-code-ide-mcp-http-server-stop (server)
  "Stop the MCP HTTP server SERVER."
  (when server
    (ws-stop server)
    (setq claude-code-ide-mcp-http-server--server nil)))

(defun claude-code-ide-mcp-http-server---handle-get (request)
  "Handle GET request to /mcp endpoint for SSE fallback."
  (with-slots (process) request (ws-send-404 process)))

(defun claude-code-ide-mcp-http-server---handle-post (request)
  "Handle POST request to /mcp/* endpoints.\nExtracts session ID from the URL path and processes the request\nwith the appropriate session context."
  (claude-code-ide-debug "MCP server received POST request")
  (condition-case err
    (let* ((headers (ws-headers request))
        (body (ws-body request))
        (url-session-id (claude-code-ide-mcp-http-server--extract-session-id-from-path headers))
        (json-object (json-parse-string body :object-type 'alist))
        (method (alist-get 'method json-object))
        (params (alist-get 'params json-object))
        (id (alist-get 'id json-object)))
    (claude-code-ide-debug "MCP request - method: %s, id: %s, session-id: %s" method id url-session-id)
    (if (null id) (progn
  (claude-code-ide-debug "Received notification: %s" method)
  (claude-code-ide-mcp-http-server--send-empty-response request)) (let* ((claude-code-ide-mcp-server--current-session-id url-session-id)
        (result (claude-code-ide-mcp-http-server--dispatch method params)))
    (claude-code-ide-debug "MCP response result computed")
    (claude-code-ide-mcp-http-server--send-json-response request 200 (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/jsonrpc) (clojure-core-list '.) (clojure-core-list "2.0")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/id) (clojure-core-list '.) (clojure-core-list 'clojure.core/id)))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/result) (clojure-core-list '.) (clojure-core-list 'clojure.core/result)))))))
    (claude-code-ide-debug "MCP response sent"))))
  (json-parse-error (claude-code-ide-mcp-http-server--send-json-error request nil -32700 "Parse error"))
  (quit (claude-code-ide-debug "Request cancelled by user (C-<escape>)")
      (claude-code-ide-mcp-http-server--send-json-error request nil -32001 "Operation cancelled by user"))
  (error (claude-code-ide-debug "Error handling request: %s" (error-message-string err))
      (claude-code-ide-mcp-http-server--send-json-error request nil -32603 (format "Internal error: %s" (error-message-string err))))))

(defun claude-code-ide-mcp-http-server---dispatch (method params)
  "Dispatch MCP method calls.\nMETHOD is the JSON-RPC method name.\nPARAMS is the parameters alist."
  (pcase method
  ("initialize" (claude-code-ide-mcp-http-server--handle-initialize params))
  ("tools/list" (claude-code-ide-mcp-http-server--handle-tools-list params))
  ("tools/call" (claude-code-ide-mcp-http-server--handle-tools-call params))
  ('_ (signal 'json-rpc-error (list -32601 "Method not found")))))

(defun claude-code-ide-mcp-http-server---handle-initialize (_params)
  "Handle the initialize method."
  (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/protocolVersion) (clojure-core-list '.) (clojure-core-list "2024-11-05")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/capabilities) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/tools) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/listChanged) (clojure-core-list '.) (clojure-core-list :json-false)))))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/logging) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/make-hash-table) (clojure-core-list :test) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'quote) (clojure-core-list 'clojure.core/equal)))))))))))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/serverInfo) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/name) (clojure-core-list '.) (clojure-core-list "claude-code-ide-mcp-tools")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/version) (clojure-core-list '.) (clojure-core-list "0.1.0")))))))))))))

(defun claude-code-ide-mcp-http-server---handle-tools-list (_params)
  "Handle the tools/list method."
  (let* ((tools (mapcar (lambda (spec)
    (claude-code-ide-mcp-http-server--tool-to-mcp (claude-code-ide-mcp-server--normalize-tool-spec spec))) claude-code-ide-mcp-server-tools)))
    (claude-code-ide-debug "MCP server returning %d tools" (length tools))
    (dolist (tool tools)
    (claude-code-ide-debug "  Tool: %s" (alist-get 'name tool)))
    (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/tools) (clojure-core-list '.) (clojure-core-list 'clojure.core/tools))))))))

(defun claude-code-ide-mcp-http-server---handle-tools-call (params)
  "Handle the tools/call method with PARAMS."
  (let* ((tool-name (alist-get 'name params))
        (tool-args (alist-get 'arguments params))
        (tool-spec (cl-find-if (lambda (spec)
    (let* ((normalized (claude-code-ide-mcp-server--normalize-tool-spec spec)))
    (string= (or (plist-get normalized :name) (symbol-name (plist-get normalized :function))) tool-name))) claude-code-ide-mcp-server-tools)))
    (unless tool-spec
    (signal 'json-rpc-error (list -32602 (format "Unknown tool: %s" tool-name))))
    (let* ((normalized (claude-code-ide-mcp-server--normalize-tool-spec tool-spec))
        (tool-function (plist-get normalized :function))
        (arg-specs (plist-get normalized :args))
        (args (claude-code-ide-mcp-http-server--validate-args tool-args arg-specs)))
    (condition-case err
    (let* ((result (apply tool-function args)))
    (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/content) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/type) (clojure-core-list '.) (clojure-core-list "text")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/text) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/claude-code-ide-mcp-http-server--format-result) (clojure-core-list 'clojure.core/result)))))))))))))))))))
  (quit (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/content) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/type) (clojure-core-list '.) (clojure-core-list "text")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/text) (clojure-core-list '.) (clojure-core-list "Operation cancelled by user"))))))))))))))))
  (error (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/content) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/type) (clojure-core-list '.) (clojure-core-list "text")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/text) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/format) (clojure-core-list "Error: %s") (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/error-message-string) (clojure-core-list 'clojure.core/err))))))))))))))))))))))))))

(defun claude-code-ide-mcp-http-server---tool-to-mcp (tool-spec)
  "Convert TOOL-SPEC to MCP tool format.\nTOOL-SPEC should already be normalized."
  (let* ((name (or (plist-get tool-spec :name) (symbol-name (plist-get tool-spec :function))))
        (description (plist-get tool-spec :description))
        (args (plist-get tool-spec :args)))
    (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/name) (clojure-core-list '.) (clojure-core-list 'clojure.core/name)))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/description) (clojure-core-list '.) (clojure-core-list 'clojure.core/description)))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/inputSchema) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/type) (clojure-core-list '.) (clojure-core-list "object")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/properties) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/claude-code-ide-mcp-http-server--args-to-schema) (clojure-core-list 'clojure.core/args))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/required) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/claude-code-ide-mcp-http-server--required-args) (clojure-core-list 'clojure.core/args)))))))))))))))))

(defun claude-code-ide-mcp-http-server---args-to-schema (args)
  "Convert ARGS list to JSON Schema properties."
  (if args (let* ((schema '()))
    (dolist (arg args (nreverse schema))
    (let* ((name (plist-get arg :name))
        (type (plist-get arg :type))
        (desc (plist-get arg :description))
        (prop-schema (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/type) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'if) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/symbolp) (clojure-core-list 'clojure.core/type)))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/symbol-name) (clojure-core-list 'clojure.core/type)))) (clojure-core-list 'clojure.core/type)))))))))))
    (when desc
    (setq prop-schema (append prop-schema (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/description) (clojure-core-list '.) (clojure-core-list 'clojure.core/desc)))))))))
    (push (cons (intern name) prop-schema) schema)))) (make-hash-table :test 'equal)))

(defun claude-code-ide-mcp-http-server---required-args (args)
  "Extract required argument names from ARGS."
  (let* ((required '()))
    (dolist (arg args)
    (unless (plist-get arg :optional)
    (push (plist-get arg :name) required)))
    (vconcat (nreverse required))))

(defun claude-code-ide-mcp-http-server---validate-args (args arg-specs)
  "Validate and extract ARGS according to ARG-SPECS.\nReturns a list of arguments in the correct order."
  (let* ((result '()))
    (dolist (spec arg-specs (nreverse result))
    (let* ((name (plist-get spec :name))
        (optional (plist-get spec :optional))
        (value (alist-get (intern name) args)))
    (when (and (not optional) (not value))
    (signal 'json-rpc-error (list -32602 (format "Missing required argument: %s" name))))
    (push value result)))))

(defun claude-code-ide-mcp-http-server---format-result (result)
  "Format RESULT for display to Claude."
  (cond
  ((stringp result) result)
  ((listp result) (mapconcat (lambda (item)
    (format "%s" item)) result "\n"))
  (t (format "%s" result))))

(defun claude-code-ide-mcp-http-server---send-json-response (request status body)
  "Send JSON response to REQUEST with STATUS and BODY."
  (with-slots (process) request (let* ((headers (list (cons "Content-Type" "application/json") (cons "Access-Control-Allow-Origin" "*"))))
    (apply #'ws-response-header process status headers)
    (ws-send process (json-encode body))
    (signal 'error 'close-connection))))

(defun claude-code-ide-mcp-http-server---send-empty-response (request)
  "Send an empty HTTP 200 response for notifications."
  (with-slots (process) request (ws-response-header process 200 (cons "Content-Type" "text/plain") (cons "Content-Length" "0")) (signal 'error 'close-connection)))

(defun claude-code-ide-mcp-http-server---send-json-error (request id code message)
  "Send JSON-RPC error response."
  (claude-code-ide-mcp-http-server--send-json-response request 200 (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/jsonrpc) (clojure-core-list '.) (clojure-core-list "2.0")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/id) (clojure-core-list '.) (clojure-core-list 'clojure.core/id)))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/error) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/code) (clojure-core-list '.) (clojure-core-list 'clojure.core/code)))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/message) (clojure-core-list '.) (clojure-core-list 'clojure.core/message))))))))))))))

(provide 'claude-code-ide-mcp-http-server)
;;; claude-code-ide-mcp-http-server.el ends here
