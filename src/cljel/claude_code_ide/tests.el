;;; claude-code-ide-tests.el --- -*- lexical-binding: t; -*-
;; Generated by ClojureElisp

(require 'clojure-elisp-runtime)
(require 'cl-lib)

;;; Code:



(require 'ert)

(defvar claude-code-ide-debug nil
  "Mock debug flag for testing.")

(defvar claude-code-ide-log-with-context t
  "Mock log context flag for testing.")

(defun claude-code-ide-debug (&rest _args) "Mock debug function that does nothing." nil)

(defun claude-code-ide-clear-debug (nil) "Mock clear debug function." nil)

(defun claude-code-ide-log (format-string &rest args) "Mock logging function for tests." (apply #'message format-string args))

(defun claude-code-ide--get-session-context (nil) "Mock session context function." "")

(provide 'claude-code-ide-debug)

(condition-case nil
    (progn
  (add-to-list 'load-path (expand-file-name "~/.emacs.d/.cache/straight/build/websocket/"))
  (require 'websocket))
  (error (defun websocket-server (&rest _args) "Mock websocket-server function." '(:mock-server t))
      (defun websocket-server-close (_server) "Mock websocket-server-close function." nil)
      (defun websocket-send-text (_ws _text) "Mock websocket-send-text function." nil)
      (defun websocket-ready-state (_ws) "Mock websocket-ready-state function." 'open)
      (defun websocket-url (_ws) "Mock websocket-url function." "ws://localhost:12345")
      (defun websocket-frame-text (_frame) "Mock websocket-frame-text function." "{}")
      (defun websocket-frame-opcode (_frame) "Mock websocket-frame-opcode function." 'text)
      (defun websocket-send (_ws _frame) "Mock websocket-send function." nil)
      (defun websocket-server-filter (_proc _string) "Mock websocket-server-filter function." nil)
      (defvar websocket-frame)
      (cl-defstruct websocket-frame opcode payload)
      (provide 'websocket)))

(defvar vterm--process)

(defvar vterm-buffer-name)

(defvar vterm-shell)

(defvar vterm-environment)

(defun vterm (&optional buffer-name) "Mock vterm function for testing with optional BUFFER-NAME." (let* ((buffer (generate-new-buffer (or buffer-name vterm-buffer-name "*vterm*"))))
    (with-current-buffer buffer
    (setq vterm--process (make-process :name "mock-vterm" :buffer buffer :command '("true") :connection-type 'pty :sentinel (lambda (_ event)
    (when (string-match "finished" event)
    (setq vterm--process nil))))))
    buffer))

(defun vterm-send-string (_string) "Mock vterm-send-string function for testing." nil)

(defun vterm-send-return (nil) "Mock vterm-send-return function for testing." nil)

(defun vterm-send-key (_key &optional _shift _meta _ctrl) "Mock vterm-send-key function for testing." nil)

(provide 'vterm)

(unless (fboundp 'display-buffer-in-side-window)
    (defun display-buffer-in-side-window (buffer _alist) "Mock display-buffer-in-side-window for testing." (set-window-buffer (selected-window) buffer) (selected-window)))

(unless (featurep 'websocket)
    (defvar websocket--test-server nil
  "Mock server for testing.")
    (defvar websocket--test-client nil
  "Mock client for testing.")
    (defvar websocket--test-port 12345
  "Mock port for testing."))

(defvar flycheck-mode nil
  "Mock flycheck-mode variable.")

(defvar flycheck-current-errors nil
  "Mock list of flycheck errors.")

(cl-defstruct flycheck-error Mock flycheck error structure. buffer checker filename line column end-line end-column message level severity id)

(provide 'flycheck)

(define-error 'mcp-error "MCP Error" 'error)

(require 'claude-code-ide-mcp-handlers)

(require 'claude-code-ide)

(defmacro claude-code-ide-tests--with-mocked-cli (cli-path &rest body)
  "Execute BODY with claude CLI path set to CLI-PATH."
  (clel-seq (clel-concat (clojure-core-list 'clojure.core/let) (clojure-core-list (apply clojure-core-vector (clel-seq (clel-concat (clojure-core-list 'user/claude-code-ide-cli-path) (clojure-core-list 'user/cli-path) (clojure-core-list 'user/claude-code-ide--cli-available) (clojure-core-list 'nil))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/deref) (clojure-core-list 'user/body)))))))

(defun claude-code-ide-tests---with-temp-directory (test-body)
  "Execute TEST-BODY in a temporary directory context."
  (let* ((temp-dir (make-temp-file "claude-code-ide-test-" t)))
    (unwind-protect
    (let* ((default-directory temp-dir))
    (funcall test-body))
  (delete-directory temp-dir t))))

(defun claude-code-ide-tests---clear-processes ()
  "Clear the process hash table for testing."
  (clrhash claude-code-ide--processes)
  (when (boundp 'claude-code-ide-mcp--sessions)
    (clrhash claude-code-ide-mcp--sessions)))

(defun claude-code-ide-tests---wait-for-process (buffer)
  "Wait for the process in BUFFER to finish."
  (with-current-buffer buffer
    (let* ((max-wait 50))
    (while (and vterm--process (process-live-p vterm--process) (> max-wait 0))
    (sleep-for 0.1)
    (setq max-wait (1- max-wait))))))

(ert-deftest claude-code-ide-test-default-buffer-name (nil) "Test default buffer name generation for various path formats." (should (equal (claude-code-ide--default-buffer-name "/home/user/project") "*claude-code[project]*")) (should (equal (claude-code-ide--default-buffer-name "/home/user/my-app/") "*claude-code[my-app]*")) (should (equal (claude-code-ide--default-buffer-name "/") "*claude-code[]*")) (should (equal (claude-code-ide--default-buffer-name "/home/user/my project/") "*claude-code[my project]*")) (should (equal (claude-code-ide--default-buffer-name "/home/user/my-project@v1.0/") "*claude-code[my-project@v1.0]*")))

(ert-deftest claude-code-ide-test-get-working-directory (nil) "Test working directory detection." (claude-code-ide-tests--with-temp-directory (lambda (_unused)
    (let* ((expected (expand-file-name default-directory)))
    (should (equal (claude-code-ide--get-working-directory) expected))))))

(ert-deftest claude-code-ide-test-get-buffer-name (nil) "Test buffer name generation using custom function." (let* ((claude-code-ide-buffer-name-function (lambda (dir)
    (format "test-%s" (file-name-nondirectory dir)))))
    (claude-code-ide-tests--with-temp-directory (lambda (_unused)
    (should (string-match "^test-claude-code-ide-test-" (claude-code-ide--get-buffer-name)))))) (let* ((claude-code-ide-buffer-name-function (lambda (dir)
    (if dir (format "*custom[%s]*" (file-name-nondirectory dir)) "*custom[none]*"))))
    (should (equal (funcall claude-code-ide-buffer-name-function nil) "*custom[none]*"))))

(ert-deftest claude-code-ide-test-process-management (nil) "Test process storage and retrieval." (claude-code-ide-tests--clear-processes) (unwind-protect
    (claude-code-ide-tests--with-temp-directory (lambda (_unused)
    (let* ((dir (claude-code-ide--get-working-directory))
        (mock-process 'mock-process))
    (should (null (claude-code-ide--get-process dir)))
    (claude-code-ide--set-process mock-process dir)
    (should (eq (claude-code-ide--get-process dir) mock-process))
    (should (eq (claude-code-ide--get-process) mock-process)))))
  (claude-code-ide-tests--clear-processes)))

(ert-deftest claude-code-ide-test-cleanup-dead-processes (nil) "Test cleanup of dead processes." (claude-code-ide-tests--clear-processes) (unwind-protect
    (let* ((live-process (make-process :name "test-live" :command '("sleep" "10") :buffer nil))
        (dead-process-name "test-dead"))
    (puthash "/dir1" live-process claude-code-ide--processes)
    (puthash "/dir2" dead-process-name claude-code-ide--processes)
    (should (equal (hash-table-count claude-code-ide--processes) 2))
    (claude-code-ide--cleanup-dead-processes)
    (should (equal (hash-table-count claude-code-ide--processes) 1))
    (should (gethash "/dir1" claude-code-ide--processes))
    (should (null (gethash "/dir2" claude-code-ide--processes)))
    (delete-process live-process))
  (claude-code-ide-tests--clear-processes)))

(ert-deftest claude-code-ide-test-detect-cli (nil) "Test CLI detection mechanism." (let* ((claude-code-ide--cli-available nil))
    (let* ((claude-code-ide-cli-path "nonexistent-claude-cli"))
    (claude-code-ide--detect-cli)
    (should (null claude-code-ide--cli-available)))
    (let* ((claude-code-ide-cli-path "echo"))
    (claude-code-ide--detect-cli)
    (should claude-code-ide--cli-available))))

(ert-deftest claude-code-ide-test-ensure-cli (nil) "Test CLI availability checking." (let* ((claude-code-ide--cli-available nil)
        (claude-code-ide-cli-path "echo"))
    (should (null claude-code-ide--cli-available))
    (should (claude-code-ide--ensure-cli))
    (should claude-code-ide--cli-available)))

(ert-deftest claude-code-ide-test-run-without-cli (nil) "Test run command when CLI is not available." (let* ((claude-code-ide--cli-available nil)
        (claude-code-ide-cli-path "nonexistent-claude-cli"))
    (should-error (claude-code-ide) :type 'user-error)))

(ert-deftest claude-code-ide-test-run-without-vterm (nil) "Test run command when vterm is not available." (let* ((claude-code-ide--cli-available t)
        (claude-code-ide-cli-path "echo")
        (claude-code-ide-terminal-backend 'vterm)
        (orig-featurep (symbol-function 'featurep)))
    (cl-letf (((symbol-function 'featurep) (lambda (sym &rest _)
    (if (eq sym 'vterm) nil (funcall orig-featurep sym)))) ((symbol-function 'require) (lambda (feature &optional filename noerror)
    (unless (eq feature 'vterm)
    (require feature filename noerror))))) (should-error (claude-code-ide) :type 'user-error))))

(ert-deftest claude-code-ide-test-run-without-eat (nil) "Test run command when eat is not available." (let* ((claude-code-ide--cli-available t)
        (claude-code-ide-cli-path "echo")
        (claude-code-ide-terminal-backend 'eat)
        (orig-featurep (symbol-function 'featurep)))
    (cl-letf (((symbol-function 'featurep) (lambda (sym &rest _)
    (if (eq sym 'eat) nil (funcall orig-featurep sym)))) ((symbol-function 'require) (lambda (feature &optional filename noerror)
    (unless (eq feature 'eat)
    (require feature filename noerror))))) (should-error (claude-code-ide) :type 'user-error))))

(ert-deftest claude-code-ide-test-terminal-backend-selection (nil) "Test terminal backend selection and validation." (let* ((claude-code-ide-terminal-backend 'vterm))
    (should (eq claude-code-ide-terminal-backend 'vterm))) (let* ((claude-code-ide-terminal-backend 'eat))
    (should (eq claude-code-ide-terminal-backend 'eat))) (let* ((claude-code-ide-terminal-backend 'invalid-backend)
        (orig-featurep (symbol-function 'featurep)))
    (cl-letf (((symbol-function 'featurep) (lambda (sym)
    nil))) (should-error (claude-code-ide--terminal-ensure-backend) :type 'user-error))))

(provide 'claude-code-ide-tests)
;;; claude-code-ide-tests.el ends here
