;;; claude-code-ide-emacs-tools.el --- -*- lexical-binding: t; -*-
;; Generated by ClojureElisp

(require 'clojure-elisp-runtime)
(require 'claude-code-ide-mcp-server)
(require 'xref)
(require 'project)
(require 'cl-lib)
(require 'imenu)

;;; Code:



(declare-function treesit-node-at "treesit" (pos &optional parser-or-lang named))

(declare-function treesit-node-text "treesit" (node &optional no-property))

(declare-function treesit-node-field-name "treesit" (node))

(defun claude-code-ide-emacs-tools-mcp-xref-find-references (identifier file-path)
  "Find references to IDENTIFIER in the current session's project.\nFILE-PATH specifies which file's buffer context to use for the search.\nThis function uses the session context to operate in the correct project."
  (if (not file-path) (error "file_path parameter is required. Please specify the file where you want to search for %s" identifier) (claude-code-ide-mcp-server-with-session-context nil (let* ((target-buffer (or (find-buffer-visiting file-path) (find-file-noselect file-path)))
        (identifier-str (format "%s" identifier)))
    (with-current-buffer target-buffer
    (condition-case err
    (let* ((backend (xref-find-backend)))
    (if (not backend) (format "No xref backend available for %s" file-path) (let* ((xref-items (xref-backend-references backend identifier-str)))
    (if xref-items (mapcar (lambda (item)
    (let* ((location (xref-item-location item))
        (file (xref-location-group location))
        (marker (xref-location-marker location))
        (line (with-current-buffer (marker-buffer marker)
    (save-excursion
    (goto-char marker)
    (line-number-at-pos))))
        (summary (xref-item-summary item)))
    (format "%s:%d: %s" file line summary))) xref-items) (format "No references found for '%s'" identifier-str)))))
  (error (format "Error searching for '%s' in %s: %s" identifier-str file-path (error-message-string err)))))))))

(defun claude-code-ide-emacs-tools-mcp-xref-find-apropos (pattern file-path)
  "Find symbols matching PATTERN across the entire project.\nFILE-PATH specifies which file's buffer context to use for the search.\nThis function uses the session context to operate in the correct project."
  (if (not file-path) (error "file_path parameter is required. Please specify the file where you want to search for pattern %s" pattern) (claude-code-ide-mcp-server-with-session-context nil (let* ((target-buffer (or (find-buffer-visiting file-path) (find-file-noselect file-path)))
        (pattern-str (format "%s" pattern)))
    (with-current-buffer target-buffer
    (condition-case err
    (let* ((backend (xref-find-backend)))
    (cond
  ((not backend) (format "No xref backend available for %s" file-path))
  ((and (eq backend 'etags) (not (or (and (boundp 'tags-file-name) tags-file-name (file-exists-p tags-file-name)) (and (boundp 'tags-table-list) tags-table-list (cl-some #'file-exists-p tags-table-list))))) (format "No tags table available for %s" file-path))
  (t (let* ((xref-items (xref-backend-apropos backend pattern-str)))
    (if xref-items (mapcar (lambda (item)
    (let* ((location (xref-item-location item))
        (file (xref-location-group location))
        (marker (xref-location-marker location))
        (line (with-current-buffer (marker-buffer marker)
    (save-excursion
    (goto-char marker)
    (line-number-at-pos))))
        (summary (xref-item-summary item)))
    (format "%s:%d: %s" file line summary))) xref-items) (format "No symbols found matching pattern '%s'" pattern-str))))))
  (error (format "Error searching for pattern '%s' in %s: %s" pattern-str file-path (error-message-string err)))))))))

(defun claude-code-ide-emacs-tools-mcp-project-info ()
  "Get information about the current session's project.\nReturns project directory, active buffer, and file count."
  (let* ((context (claude-code-ide-mcp-server-get-session-context)))
    (if context (let* ((project-dir (plist-get context :project-dir))
        (buffer (plist-get context :buffer)))
    (format "Project: %s\nBuffer: %s\nFiles: %d" project-dir (if (and buffer (buffer-live-p buffer)) (buffer-name buffer) "No active buffer") (length (project-files (project-current nil project-dir))))) "No session context available")))

(defun claude-code-ide-emacs-tools-mcp-imenu-list-symbols (file-path)
  "List all symbols in FILE-PATH using imenu.\nReturns a list of symbols with their types and positions."
  (if (not file-path) (error "file_path parameter is required") (claude-code-ide-mcp-server-with-session-context nil (condition-case err
    (let* ((target-buffer (or (find-buffer-visiting file-path) (find-file-noselect file-path))))
    (with-current-buffer target-buffer
    (imenu--make-index-alist)
    (if imenu--index-alist (let* ((results '()))
    (dolist (item imenu--index-alist)
    (cond
  (((string-match-p "^\\*" (car item)) nil) ((markerp (cdr item)) (let* ((line (line-number-at-pos (marker-position (cdr item)))))
    (push (format "%s:%d: %s" file-path line (car item)) results))))
  (((numberp (cdr item)) (let* ((line (line-number-at-pos (cdr item))))
    (push (format "%s:%d: %s" file-path line (car item)) results))) ((listp (cdr item)) (let* ((category (car item)))
    (dolist (subitem (cdr item))
    (when (and (consp subitem) (or (markerp (cdr subitem)) (numberp (cdr subitem))))
    (let* ((line (line-number-at-pos (if (markerp (cdr subitem)) (marker-position (cdr subitem)) (cdr subitem)))))
    (push (format "%s:%d: [%s] %s" file-path line category (car subitem)) results)))))))))
    (if results (nreverse results) (format "No symbols found in %s" file-path))) (format "No imenu support or no symbols found in %s" file-path))))
  (error (format "Error listing symbols in %s: %s" file-path (error-message-string err)))))))

(defun claude-code-ide-emacs-tools-mcp-treesit--format-tree (node level max-depth)
  "Format NODE and its children as a tree string.\nLEVEL is the current indentation level.\nMAX-DEPTH is the maximum depth to traverse."
  (if (or (not node) (>= level max-depth)) "" (let* ((indent (make-string (* level 2) -p ;; Unknown node: {:op :unknown, :env {:ns claude-code-ide-emacs-tools, :locals #{max-depth node level}, :aliases {}, :refers {}, :defs {mcp-xref-find-references {:private? false}, mcp-xref-find-apropos {:private? false}, mcp-project-info {:private? false}, mcp-imenu-list-symbols {:private? false}, mcp-treesit--format-tree {:private? false}, mcp--line-column-to-point {:private? false}, mcp-treesit-info {:private? false}, setup {:private? false}}, :in-tail-position? false}, :line 172, :column 19, :form \s}))
        (type (treesit-node-type node))
        (named (if (treesit-node-check node 'named) " (named)" ""))
        (start (treesit-node-start node))
        (end (treesit-node-end node))
        (field-name (treesit-node-field-name node))
        (field-str (if field-name (format " [%s]" field-name) ""))
        (text (treesit-node-text node t))
        (text-preview (if (and (< (length text) 40) (not (string-match-p "\n" text))) (format " \"%s\"" text) ""))
        (result (format "%s%s%s%s (%d-%d)%s\n" indent type named field-str start end text-preview))
        (child-count (treesit-node-child-count node)))
    (cl-dotimes (i child-count)
    (when-let ((child (treesit-node-child node i)))
    (setq result (clel-concat result (claude-code-ide-emacs-tools-mcp-treesit--format-tree child (1+ level) max-depth)))))
    result)))

(defun claude-code-ide-emacs-tools-mcp--line-column-to-point (line column)
  "Convert LINE and COLUMN to point position in current buffer.\nLINE is 1-based, COLUMN is 0-based (Emacs convention)."
  (save-excursion
    (goto-char (point-min))
    (forward-line (1- line))
    (move-to-column column)
    (point)))

(defun claude-code-ide-emacs-tools-mcp-treesit-info (file-path &optional line column whole_file include_ancestors include_children)
  "Get tree-sitter parse tree information for FILE-PATH.\nOptional LINE and COLUMN specify the position (1-based line, 0-based column).\nIf WHOLE_FILE is non-nil, show the entire file's syntax tree.\nIf neither position is specified, defaults to current cursor position (point).\nIf INCLUDE_ANCESTORS is non-nil, include parent node hierarchy.\nIf INCLUDE_CHILDREN is non-nil, include child nodes."
  (if (not file-path) (error "file_path parameter is required") (claude-code-ide-mcp-server-with-session-context nil (condition-case err
    (if (not (treesit-available-p)) "Tree-sitter is not available in this Emacs build" (let* ((target-buffer (or (find-buffer-visiting file-path) (find-file-noselect file-path))))
    (with-current-buffer target-buffer
    (let* ((parsers (treesit-parser-list))
        (parser (car parsers)))
    (if (not parser) (format "No tree-sitter parser available for %s" file-path) (let* ((root-node (treesit-parser-root-node parser))
        (pos (cond
  ((whole_file nil) (line (claude-code-ide-emacs-tools-mcp--line-column-to-point line (or column 0))))))
        (node (if whole_file root-node (treesit-node-at pos parser)))
        (results '()))
    (if (not node) "No tree-sitter node found" (if whole_file (claude-code-ide-emacs-tools-mcp-treesit--format-tree root-node 0 20) (push (format "Node Type: %s" (treesit-node-type node)) results)))))))))
  (error (format "Error getting tree-sitter info for %s: %s" file-path (error-message-string err)))))))

(defun claude-code-ide-emacs-tools-setup ()
  "Set up Emacs MCP tools for Claude Code IDE."
  (interactive)
  (setq claude-code-ide-enable-mcp-server t)
  (claude-code-ide-mcp-server-make-tool :function #'claude-code-ide-emacs-tools-mcp-xref-find-references :name "claude-code-ide-mcp-xref-find-references" :description "Find where a function, variable, or class is used throughout your codebase. Perfect for understanding code dependencies and impact analysis" :args '((:name "identifier" :type string :description "The identifier to find references for") (:name "file_path" :type string :description "File path to use as context for the search")))
  (claude-code-ide-mcp-server-make-tool :function #'claude-code-ide-emacs-tools-mcp-xref-find-apropos :name "claude-code-ide-mcp-xref-find-apropos" :description "Search for functions, variables, or classes by name pattern across your project. Helps you discover code elements when you know part of the name" :args '((:name "pattern" :type string :description "The pattern to search for symbols") (:name "file_path" :type string :description "File path to use as context for the search")))
  (claude-code-ide-mcp-server-make-tool :function #'claude-code-ide-emacs-tools-mcp-project-info :name "claude-code-ide-mcp-project-info" :description "Get quick overview of your current project context including directory, active file, and project size" :args nil)
  (claude-code-ide-mcp-server-make-tool :function #'claude-code-ide-emacs-tools-mcp-imenu-list-symbols :name "claude-code-ide-mcp-imenu-list-symbols" :description "Navigate and explore a file's structure by listing all its functions, classes, and variables with their locations" :args '((:name "file_path" :type string :description "Path to the file to analyze for symbols")))
  (claude-code-ide-mcp-server-make-tool :function #'claude-code-ide-emacs-tools-mcp-treesit-info :name "claude-code-ide-mcp-treesit-info" :description "Get tree-sitter syntax tree information for a file, including node types, ranges, and hierarchical structure. Useful for understanding code structure and AST analysis" :args '((:name "file_path" :type string :description "Path to the file to analyze") (:name "line" :type number :description "Line number (1-based)" :optional t) (:name "column" :type number :description "Column number (0-based)" :optional t) (:name "whole_file" :type boolean :description "Show the entire file's syntax tree" :optional t) (:name "include_ancestors" :type boolean :description "Include parent node hierarchy" :optional t) (:name "include_children" :type boolean :description "Include child nodes" :optional t))))

(provide 'claude-code-ide-emacs-tools)
;;; claude-code-ide-emacs-tools.el ends here
