;;; claude-code-ide-mcp-handlers.el --- -*- lexical-binding: t; -*-
;; Generated by ClojureElisp

(require 'clojure-elisp-runtime)
(require 'cl-lib)
(require 'json)
(require 'ediff)
(require 'claude-code-ide-diagnostics)
(require 'claude-code-ide-debug)

;;; Code:



(declare-function claude-code-ide-mcp-complete-deferred "claude-code-ide-mcp" (session method result &optional unique-key))

(declare-function claude-code-ide-mcp--get-current-session "claude-code-ide-mcp" (nil))

(declare-function claude-code-ide-mcp--get-session-for-project "claude-code-ide-mcp" (project-dir))

(declare-function claude-code-ide-mcp--get-buffer-project "claude-code-ide-mcp" (nil))

(declare-function claude-code-ide-mcp-session-active-diffs "claude-code-ide-mcp" (session))

(declare-function claude-code-ide-mcp-session-original-tab "claude-code-ide-mcp" (session))

(declare-function claude-code-ide-mcp-session-project-dir "claude-code-ide-mcp" (session))

(declare-function claude-code-ide-mcp--setup-buffer-cache-hooks "claude-code-ide-mcp" (nil))

(declare-function claude-code-ide--get-buffer-name "claude-code-ide" (&optional directory))

(declare-function claude-code-ide--display-buffer-in-side-window "claude-code-ide" (buffer))

(defvar ediff-control-buffer nil)

(defvar ediff-window-setup-function nil)

(defvar ediff-split-window-function nil)

(defvar ediff-control-buffer-suffix nil)

(defvar claude-code-ide-mcp--sessions nil)

(defvar claude-code-ide-show-claude-window-in-ediff nil)

(defvar claude-code-ide-focus-claude-after-ediff nil)

(defvar claude-code-ide-switch-tab-on-ediff nil)

(defvar claude-code-ide-use-ide-diff nil)

(defvar claude-code-ide-mcp-tools nil)

(defvar claude-code-ide-mcp-tool-schemas nil)

(defvar claude-code-ide-mcp-tool-descriptions nil)

(defconst claude-code-ide-mcp-handlers-idle-timer-delay 0 "Delay in seconds for idle timer when deferring responses.")

(defun claude-code-ide-mcp-handlers---find-session-for-file (file-path)
  "Find the MCP session that owns FILE-PATH.\nReturns the session if found, nil otherwise."
  (let* ((expanded-file (expand-file-name file-path))
        (found-session nil))
    (catch 'found (maphash (lambda (project-dir session)
    (when (string-prefix-p (expand-file-name project-dir) expanded-file)
    (setq found-session session)
    (signal 'error 'found))) claude-code-ide-mcp--sessions))
    found-session))

(defun claude-code-ide-mcp-handlers---find-claude-side-window ()
  "Find the Claude Code side window in the current frame.\nReturns the window if found, nil otherwise."
  (let* ((claude-buffer-name (claude-code-ide--get-buffer-name)))
    (cl-find-if (lambda (window)
    (and (window-parameter window 'window-side) (equal (buffer-name (window-buffer window)) claude-buffer-name))) (window-list))))

(defun claude-code-ide-mcp-handlers---get-active-diffs (&optional session)
  "Get the active diffs hash table for the current session.\nIf SESSION is provided, use it instead of looking up the current session."
  (if session (claude-code-ide-mcp-session-active-diffs session) (if-let ((current-session (claude-code-ide-mcp--get-current-session)))
    (claude-code-ide-mcp-session-active-diffs current-session))))

(defun claude-code-ide-mcp-handlers---create-diff-buffers (old-file-path new-file-contents tab-name)
  "Create buffers for diff comparison.\nOLD-FILE-PATH is the path to the original file.\nNEW-FILE-CONTENTS is the new content to diff against.\nTAB-NAME is used for naming the new buffer.\nReturns a cons cell (buffer-A . buffer-B)."
  (let* ((file-exists (file-exists-p old-file-path))
        (buffer-A nil)
        (buffer-B nil))
    (if file-exists (setq buffer-A (find-file-noselect old-file-path)) (setq buffer-A (generate-new-buffer (format "*New file: %s*" (file-name-nondirectory old-file-path)))))
    (setq buffer-B (generate-new-buffer (format "*%s*" tab-name)))
    (with-current-buffer buffer-B
    (insert new-file-contents)
    (let* ((mode (assoc-default old-file-path auto-mode-alist 'string-match)))
    (when mode
    (condition-case err
    (funcall mode)
  (error (claude-code-ide-debug "Failed to activate %s for diff buffer: %s. Using fundamental-mode." mode (error-message-string err))
      (fundamental-mode))))))
    (cons buffer-A buffer-B)))

(defun claude-code-ide-mcp-handlers---setup-diff-hooks (tab-name session saved-winconf)
  "Set up ediff hooks for TAB-NAME with SESSION and SAVED-WINCONF.\nReturns a cons cell (before-setup-hook-fn . startup-hook-fn)."
  (let* ((captured-tab-name tab-name)
        (captured-session session)
        (captured-winconf saved-winconf)
        (before-setup-hook-fn nil)
        (startup-hook-fn nil))
    (setq before-setup-hook-fn (lambda (_unused)
    (remove-hook 'ediff-before-setup-hook before-setup-hook-fn)))
    (setq startup-hook-fn (lambda (_unused)
    (claude-code-ide-mcp-handlers--handle-ediff-startup captured-tab-name captured-session captured-winconf startup-hook-fn)))
    (cons before-setup-hook-fn startup-hook-fn)))

(defun claude-code-ide-mcp-handlers---handle-ediff-startup (tab-name session saved-winconf startup-hook-fn)
  "Handle ediff startup for TAB-NAME with SESSION and SAVED-WINCONF.\nSTARTUP-HOOK-FN is the hook function to remove after use."
  (when ediff-control-buffer
    (let* ((active-diffs (claude-code-ide-mcp-handlers--get-active-diffs session))
        (control-buffer ediff-control-buffer))
    (when-let ((diff-info (gethash tab-name active-diffs)))
    (setf (alist-get 'control-buffer diff-info) control-buffer)
    (puthash tab-name diff-info active-diffs)))
    (with-current-buffer ediff-control-buffer
    (setq-local ediff-quit-hook (list (lambda (_unused)
    (let* ((active-diffs (claude-code-ide-mcp-handlers--get-active-diffs session))
        (diff-info (gethash tab-name active-diffs))
        (quit-from-claude (alist-get 'quit-from-claude diff-info)))
    (unless quit-from-claude
    (claude-code-ide-mcp-handlers--handle-ediff-quit tab-name session)))
    (when saved-winconf
    (condition-case nil
    (set-window-configuration saved-winconf)
  (error nil)))))))
    (ignore-errors (ediff-next-difference))
    (let* ((original-window (selected-window))
        (claude-window nil))
    (when claude-code-ide-show-claude-window-in-ediff
    (when-let-star (list project-dir (claude-code-ide-mcp-session-project-dir session) claude-buffer-name (claude-code-ide--get-buffer-name project-dir) claude-buffer (get-buffer claude-buffer-name)) (when (buffer-live-p claude-buffer)
    (setq claude-window (claude-code-ide--display-buffer-in-side-window claude-buffer)))))
    (cond
  (((and claude-code-ide-focus-claude-after-ediff claude-window) (select-window claude-window)) (t (select-window original-window)))))
    (remove-hook 'ediff-startup-hook startup-hook-fn)))

(defun claude-code-ide-mcp-handlers-handle-open-file (arguments)
  "Open a file with optional text selection.\nARGUMENTS should contain:\n- `path': File path to open\n- `startLine' (optional): Start line for selection\n- `endLine' (optional): End line for selection\n- `startText' (optional): Start text pattern for selection\n- `endText' (optional): End text pattern for selection"
  (let* ((path (alist-get 'path arguments))
        (start-line (alist-get 'startLine arguments))
        (end-line (alist-get 'endLine arguments))
        (start-text (alist-get 'startText arguments))
        (end-text (alist-get 'endText arguments)))
    (unless path
    (signal 'mcp-error '("Missing required parameter: path")))
    (condition-case err
    (progn
  (find-file path)
  (with-current-buffer (current-buffer)
    (claude-code-ide-mcp--setup-buffer-cache-hooks))
  (cond
  (((and start-text end-text) (goto-char (point-min)) (if (search-forward start-text nil t) (let* ((start-pos (match-beginning 0)))
    (if (search-forward end-text nil t) (let* ((end-pos (match-end 0)))
    (goto-char start-pos)
    (push-mark end-pos t t)
    (activate-mark)) (goto-char start-pos))) (when start-line
    (goto-char (point-min))
    (forward-line (1- start-line))
    (when end-line
    (push-mark (point) t t)
    (forward-line (- end-line start-line))
    (end-of-line)
    (activate-mark))))) (start-text (goto-char (point-min)) (when (search-forward start-text nil t)
    (goto-char (match-beginning 0))))))
  (list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/type) (clojure-core-list '.) (clojure-core-list "text")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/text) (clojure-core-list '.) (clojure-core-list "FILE_OPENED"))))))))
  (error (signal 'mcp-error (list (format "Failed to open file: %s" (error-message-string err))))))))

(defun claude-code-ide-mcp-handlers-handle-get-current-selection (_arguments)
  "Get the currently selected text and its context."
  (let* ((file-path (or (buffer-file-name) ""))
        (file-url (when (buffer-file-name)
    (clel-concat "file://" (buffer-file-name)))))
    (if (use-region-p) (let* ((start (region-beginning))
        (end (region-end))
        (text (buffer-substring-no-properties start end))
        (start-line (line-number-at-pos start))
        (end-line (line-number-at-pos end))
        (start-col (save-excursion
    (goto-char start)
    (1+ (current-column))))
        (end-col (save-excursion
    (goto-char end)
    (1+ (current-column)))))
    (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/text) (clojure-core-list '.) (clojure-core-list 'clojure.core/text)))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/filePath) (clojure-core-list '.) (clojure-core-list 'clojure.core/file-path)))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/deref) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/when) (clojure-core-list 'clojure.core/file-url) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/seq) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/concat) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/list) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/seq) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/concat) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/list) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'quote) (clojure-core-list 'clojure.core/fileUrl))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/list) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'quote) (clojure-core-list '.))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/list) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'quote) (clojure-core-list 'clojure.core/file-url)))))))))))))))))))))))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/selection) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/start) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/line) (clojure-core-list '.) (clojure-core-list 'clojure.core/start-line)))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/character) (clojure-core-list '.) (clojure-core-list 'clojure.core/start-col)))))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/end) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/line) (clojure-core-list '.) (clojure-core-list 'clojure.core/end-line)))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/character) (clojure-core-list '.) (clojure-core-list 'clojure.core/end-col)))))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/isEmpty) (clojure-core-list '.) (clojure-core-list :json-false))))))))))))) (let* ((cursor-line (line-number-at-pos))
        (cursor-col (1+ (current-column))))
    (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/text) (clojure-core-list '.) (clojure-core-list "")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/filePath) (clojure-core-list '.) (clojure-core-list 'clojure.core/file-path)))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/deref) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/when) (clojure-core-list 'clojure.core/file-url) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/seq) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/concat) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/list) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/seq) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/concat) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/list) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'quote) (clojure-core-list 'clojure.core/fileUrl))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/list) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'quote) (clojure-core-list '.))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/list) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'quote) (clojure-core-list 'clojure.core/file-url)))))))))))))))))))))))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/selection) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/start) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/line) (clojure-core-list '.) (clojure-core-list 'clojure.core/cursor-line)))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/character) (clojure-core-list '.) (clojure-core-list 'clojure.core/cursor-col)))))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/end) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/line) (clojure-core-list '.) (clojure-core-list 'clojure.core/cursor-line)))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/character) (clojure-core-list '.) (clojure-core-list 'clojure.core/cursor-col)))))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/isEmpty) (clojure-core-list '.) (clojure-core-list 'clojure.core/t))))))))))))))))

(defun claude-code-ide-mcp-handlers-handle-get-open-editors (_arguments)
  "Get list of all open editors/buffers with file paths."
  (let* ((editors '())
        (project-dir (claude-code-ide-mcp--get-buffer-project)))
    (dolist (buffer (buffer-list))
    (when-let ((file (buffer-file-name buffer)))
    (when (or (not project-dir) (string-prefix-p (expand-file-name project-dir) (expand-file-name file)))
    (push (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/path) (clojure-core-list '.) (clojure-core-list 'clojure.core/file)))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/name) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/buffer-name) (clojure-core-list 'clojure.core/buffer))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/active) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/eq) (clojure-core-list 'clojure.core/buffer) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/current-buffer)))))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/isDirty) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'if) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/buffer-modified-p) (clojure-core-list 'clojure.core/buffer)))) (clojure-core-list 'clojure.core/t) (clojure-core-list :json-false))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/fileUrl) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/concat) (clojure-core-list "file://") (clojure-core-list 'clojure.core/file))))))))) editors))))
    (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/editors) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/vconcat) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/nreverse) (clojure-core-list 'clojure.core/editors))))))))))))))

(defun claude-code-ide-mcp-handlers-handle-get-workspace-folders (_arguments)
  "Get the current workspace folders (project roots)."
  (let* ((project-dir (or (claude-code-ide-mcp--get-buffer-project) default-directory)))
    (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/folders) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/vconcat) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/list) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/expand-file-name) (clojure-core-list 'clojure.core/project-dir)))))))))))))))))

(defun claude-code-ide-mcp-handlers-handle-get-diagnostics (arguments &optional session)
  "Get diagnostics (errors/warnings) for the current workspace.\nARGUMENTS may contain an optional `uri' parameter.\nOptional SESSION contains the MCP session context."
  (claude-code-ide-diagnostics-handler arguments session))

(defun claude-code-ide-mcp-handlers-handle-save-document (arguments)
  "Save a document.\nARGUMENTS should contain `path' of the file to save."
  (let* ((path (alist-get 'path arguments)))
    (unless path
    (signal 'mcp-error '("Missing required parameter: path")))
    (condition-case err
    (let* ((buffer (find-buffer-visiting path)))
    (if buffer (with-current-buffer buffer
    (save-buffer)
    (list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/type) (clojure-core-list '.) (clojure-core-list "text")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/text) (clojure-core-list '.) (clojure-core-list "DOCUMENT_SAVED")))))))) (signal 'mcp-error (list (format "No buffer visiting %s" path)))))
  (error (signal 'mcp-error (list (format "Failed to save: %s" (error-message-string err))))))))

(defun claude-code-ide-mcp-handlers-handle-close-tab (arguments)
  "Close a tab/buffer.\nARGUMENTS should contain `path' or `tab_name' of the file to close."
  (let* ((path (alist-get 'path arguments))
        (tab-name (alist-get 'tab_name arguments)))
    (cond
  ((path (let* ((buffer (find-buffer-visiting path)))
    (if buffer (progn
  (kill-buffer buffer)
  (list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/type) (clojure-core-list '.) (clojure-core-list "text")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/text) (clojure-core-list '.) (clojure-core-list "TAB_CLOSED")))))))) (signal 'mcp-error (list (format "No buffer visiting %s" path)))))) (tab-name (let* ((found-session nil)
        (found-diff-info nil))
    (catch 'found (maphash (lambda (_proj-dir session)
    (let* ((session-diffs (claude-code-ide-mcp-session-active-diffs session))
        (diff-info (gethash tab-name session-diffs)))
    (when diff-info
    (setq found-session session found-diff-info diff-info)
    (signal 'error 'found)))) claude-code-ide-mcp--sessions))
    (if found-diff-info (progn
  (when-let ((control-buf (alist-get 'control-buffer found-diff-info)))
    (when (buffer-live-p control-buf)
    (setf (alist-get 'quit-from-claude found-diff-info) t)
    (with-current-buffer control-buf
    (when (and (boundp 'ediff-error-buffer) ediff-error-buffer)
    (setf (alist-get 'error-buffer found-diff-info) ediff-error-buffer))
    (when (and (boundp 'ediff-diff-buffer) ediff-diff-buffer)
    (setf (alist-get 'diff-buffer found-diff-info) ediff-diff-buffer))
    (when (and (boundp 'ediff-fine-diff-buffer) ediff-fine-diff-buffer)
    (setf (alist-get 'fine-diff-buffer found-diff-info) ediff-fine-diff-buffer))
    (when (and (boundp 'ediff-custom-diff-buffer) ediff-custom-diff-buffer)
    (setf (alist-get 'custom-diff-buffer found-diff-info) ediff-custom-diff-buffer)))
    (puthash tab-name found-diff-info (claude-code-ide-mcp-session-active-diffs found-session))
    (condition-case err
    (if (fboundp 'ediff-really-quit) (with-current-buffer control-buf
    (ediff-really-quit nil)) (kill-buffer control-buf))
  (error (claude-code-ide-debug "Error quitting ediff: %s. Killing control buffer directly." (error-message-string err))
      (when (buffer-live-p control-buf)
    (kill-buffer control-buf))))))
  (claude-code-ide-mcp-handlers--cleanup-diff tab-name found-session)
  (list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/type) (clojure-core-list '.) (clojure-core-list "text")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/text) (clojure-core-list '.) (clojure-core-list "TAB_CLOSED")))))))) (let* ((buffer (get-buffer tab-name)))
    (if buffer (progn
  (kill-buffer buffer)
  (list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/type) (clojure-core-list '.) (clojure-core-list "text")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/text) (clojure-core-list '.) (clojure-core-list "TAB_CLOSED")))))))) (signal 'mcp-error (list (format "No buffer named %s" tab-name))))))))))))

(defun claude-code-ide-mcp-handlers-handle-open-diff (arguments)
  "Open a diff view using ediff.\nARGUMENTS should contain:\n- `old_file_path': Original file path\n- `new_file_path': New file path (usually same as old)\n- `new_file_contents': New content to diff against\n- `tab_name': Name for the diff tab"
  (let* ((old-file-path (alist-get 'old_file_path arguments))
        (new-file-path (alist-get 'new_file_path arguments))
        (new-file-contents (alist-get 'new_file_contents arguments))
        (tab-name (alist-get 'tab_name arguments))
        (session nil))
    (unless (and old-file-path new-file-path new-file-contents tab-name)
    (signal 'mcp-error '("Missing required parameters for openDiff")))
    (setq session (or (claude-code-ide-mcp-handlers--find-session-for-file old-file-path) (claude-code-ide-mcp--get-current-session)))
    (unless session
    (signal 'mcp-error '("No active MCP session found")))
    (let* ((active-diffs (claude-code-ide-mcp-handlers--get-active-diffs session)))
    (when-let ((existing-diff (gethash tab-name active-diffs)))
    (claude-code-ide-mcp-handlers--cleanup-diff tab-name session)))
    (when (and claude-code-ide-switch-tab-on-ediff (claude-code-ide-mcp-session-original-tab session))
    (let* ((original-tab (claude-code-ide-mcp-session-original-tab session)))
    (when (and (fboundp 'tab-bar-mode) tab-bar-mode (fboundp 'tab-bar--current-tab) (fboundp 'tab-bar-select-tab-by-name))
    (let* ((current-tab (tab-bar--current-tab)))
    (when (and original-tab current-tab (not (equal (alist-get 'name original-tab) (alist-get 'name current-tab))))
    (tab-bar-select-tab-by-name (alist-get 'name original-tab)))))))
    (let* ((saved-winconf (current-window-configuration))
        (buffers (claude-code-ide-mcp-handlers--create-diff-buffers old-file-path new-file-contents tab-name))
        (buffer-A (car buffers))
        (buffer-B (cdr buffers))
        (file-exists (file-exists-p old-file-path)))
    (let* ((active-diffs (claude-code-ide-mcp-handlers--get-active-diffs session)))
    (puthash tab-name (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/buffer-A) (clojure-core-list '.) (clojure-core-list 'clojure.core/buffer-A)))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/buffer-B) (clojure-core-list '.) (clojure-core-list 'clojure.core/buffer-B)))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/old-file-path) (clojure-core-list '.) (clojure-core-list 'clojure.core/old-file-path)))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/new-file-path) (clojure-core-list '.) (clojure-core-list 'clojure.core/new-file-path)))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/file-exists) (clojure-core-list '.) (clojure-core-list 'clojure.core/file-exists)))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/saved-winconf) (clojure-core-list '.) (clojure-core-list 'clojure.core/saved-winconf)))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/session) (clojure-core-list '.) (clojure-core-list 'clojure.core/session)))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/created-at) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/current-time))))))))) active-diffs))
    (let* ((hooks (claude-code-ide-mcp-handlers--setup-diff-hooks tab-name session saved-winconf))
        (before-setup-hook-fn (car hooks))
        (startup-hook-fn (cdr hooks)))
    (add-hook 'ediff-before-setup-hook before-setup-hook-fn)
    (add-hook 'ediff-startup-hook startup-hook-fn)
    (condition-case err
    (progn
  (dolist (window (window-list))
    (when (window-parameter window 'window-side)
    (delete-window window)))
  (let* ((old-setup-fn ediff-window-setup-function)
        (old-split-fn ediff-split-window-function)
        (ediff-control-buffer-suffix (format "<%s>" tab-name)))
    (unwind-protect
    (progn
  (setq ediff-window-setup-function 'ediff-setup-windows-plain ediff-split-window-function 'split-window-horizontally)
  (ediff-buffers buffer-A buffer-B))
  (setq ediff-window-setup-function old-setup-fn ediff-split-window-function old-split-fn))))
  (error (when buffer-B
    (kill-buffer buffer-B))
      (let* ((active-diffs (claude-code-ide-mcp-handlers--get-active-diffs session)))
    (remhash tab-name active-diffs))
      (remove-hook 'ediff-before-setup-hook before-setup-hook-fn)
      (remove-hook 'ediff-startup-hook startup-hook-fn)
      (signal (car err) (cdr err))))
    (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/deferred) (clojure-core-list '.) (clojure-core-list 'clojure.core/t)))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/unique-key) (clojure-core-list '.) (clojure-core-list 'clojure.core/tab-name)))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/session) (clojure-core-list '.) (clojure-core-list 'clojure.core/session))))))))))

(defun claude-code-ide-mcp-handlers---handle-ediff-quit (tab-name &optional session)
  "Handle ediff quit for TAB-NAME.\nPrompts user to accept/reject changes and sends appropriate MCP response.\nSESSION is the MCP session to use."
  (let* ((temp-session session)
        (active-diffs (claude-code-ide-mcp-handlers--get-active-diffs temp-session))
        (diff-info (gethash tab-name active-diffs)))
    (if (not diff-info) nil (unless temp-session
    (setq temp-session (alist-get 'session diff-info))))))

(defun claude-code-ide-mcp-handlers---cleanup-diff (tab-name &optional session)
  "Clean up diff session for TAB-NAME.\nSESSION is the MCP session to use - if not provided, tries to determine it."
  (let* ((active-diffs (claude-code-ide-mcp-handlers--get-active-diffs session)))
    (when-let ((diff-info (gethash tab-name active-diffs)))
    (unless session
    (setq session (alist-get 'session diff-info)))
    (let* ((buffer-A (alist-get 'buffer-A diff-info))
        (buffer-B (alist-get 'buffer-B diff-info))
        (control-buf (alist-get 'control-buffer diff-info))
        (file-exists (alist-get 'file-exists diff-info))
        (error-buffer (alist-get 'error-buffer diff-info))
        (diff-buffer (alist-get 'diff-buffer diff-info))
        (fine-diff-buffer (alist-get 'fine-diff-buffer diff-info))
        (custom-diff-buffer (alist-get 'custom-diff-buffer diff-info)))
    (when (and control-buf (buffer-live-p control-buf))
    (with-current-buffer control-buf
    (claude-code-ide-debug "Capturing ediff buffers from control buffer")
    (when (and (boundp 'ediff-error-buffer) ediff-error-buffer (not error-buffer))
    (setq error-buffer ediff-error-buffer))
    (when (and (boundp 'ediff-diff-buffer) ediff-diff-buffer (not diff-buffer))
    (setq diff-buffer ediff-diff-buffer))
    (when (and (boundp 'ediff-fine-diff-buffer) ediff-fine-diff-buffer (not fine-diff-buffer))
    (setq fine-diff-buffer ediff-fine-diff-buffer))
    (when (and (boundp 'ediff-custom-diff-buffer) ediff-custom-diff-buffer (not custom-diff-buffer))
    (setq custom-diff-buffer ediff-custom-diff-buffer))
    (setq ediff-quit-hook nil))
    (kill-buffer control-buf))
    (dolist (buf (list error-buffer diff-buffer fine-diff-buffer custom-diff-buffer))
    (when (and buf (buffer-live-p buf))
    (claude-code-ide-debug "Killing ediff auxiliary buffer: %s" (buffer-name buf))
    (kill-buffer buf)))
    (when (and buffer-B (buffer-live-p buffer-B))
    (kill-buffer buffer-B))
    (when (and buffer-A (buffer-live-p buffer-A) (not file-exists))
    (kill-buffer buffer-A))
    (remhash tab-name active-diffs)))))

(defun claude-code-ide-mcp-handlers-handle-close-all-diff-tabs (_arguments)
  "Close all diff tabs/buffers for the current session only."
  (let* ((closed-count 0)
        (current-session (claude-code-ide-mcp--get-current-session)))
    (if current-session (let* ((session-diffs (claude-code-ide-mcp-session-active-diffs current-session)))
    (maphash (lambda (tab-name _diff-info)
    (claude-code-ide-mcp-handlers--cleanup-diff tab-name current-session)
    (setq closed-count (1+ closed-count))) session-diffs)) (when-let ((project-dir (claude-code-ide-mcp--get-buffer-project)))
    (when-let ((session (claude-code-ide-mcp--get-session-for-project project-dir)))
    (let* ((session-diffs (claude-code-ide-mcp-session-active-diffs session)))
    (maphash (lambda (tab-name _diff-info)
    (claude-code-ide-mcp-handlers--cleanup-diff tab-name session)
    (setq closed-count (1+ closed-count))) session-diffs)))))
    (list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/type) (clojure-core-list '.) (clojure-core-list "text")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/text) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/format) (clojure-core-list "CLOSED_%d_DIFF_TABS") (clojure-core-list 'clojure.core/closed-count))))))))))))

(defun claude-code-ide-mcp-handlers-handle-check-document-dirty (arguments)
  "Check if document is dirty.\nARGUMENTS should contain `filePath`."
  (let* ((path (alist-get 'filePath arguments)))
    (unless path
    (signal 'mcp-error '("Missing required parameter: filePath")))
    (let* ((buffer (find-buffer-visiting path)))
    (if buffer (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/isDirty) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'if) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/buffer-modified-p) (clojure-core-list 'clojure.core/buffer)))) (clojure-core-list 'clojure.core/t) (clojure-core-list :json-false))))))))) (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/isDirty) (clojure-core-list '.) (clojure-core-list :json-false))))))))))

(defun claude-code-ide-mcp-handlers---build-tool-list ()
  "Build the tool list, conditionally including ediff tools."
  (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list "openFile") (clojure-core-list '.) (clojure-core-list 'clojure.core/claude-code-ide-mcp-handlers-handle-open-file)))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list "getCurrentSelection") (clojure-core-list '.) (clojure-core-list 'clojure.core/claude-code-ide-mcp-handlers-handle-get-current-selection)))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list "getOpenEditors") (clojure-core-list '.) (clojure-core-list 'clojure.core/claude-code-ide-mcp-handlers-handle-get-open-editors)))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list "getWorkspaceFolders") (clojure-core-list '.) (clojure-core-list 'clojure.core/claude-code-ide-mcp-handlers-handle-get-workspace-folders)))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list "getDiagnostics") (clojure-core-list '.) (clojure-core-list 'clojure.core/claude-code-ide-mcp-handlers-handle-get-diagnostics)))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list "saveDocument") (clojure-core-list '.) (clojure-core-list 'clojure.core/claude-code-ide-mcp-handlers-handle-save-document)))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list "close_tab") (clojure-core-list '.) (clojure-core-list 'clojure.core/claude-code-ide-mcp-handlers-handle-close-tab)))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/deref) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/when) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/bound-and-true-p) (clojure-core-list 'clojure.core/claude-code-ide-use-ide-diff)))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'quote) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list "openDiff") (clojure-core-list '.) (clojure-core-list 'clojure.core/claude-code-ide-mcp-handlers-handle-open-diff)))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list "closeAllDiffTabs") (clojure-core-list '.) (clojure-core-list 'clojure.core/claude-code-ide-mcp-handlers-handle-close-all-diff-tabs)))))))))))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list "checkDocumentDirty") (clojure-core-list '.) (clojure-core-list 'clojure.core/claude-code-ide-mcp-handlers-handle-check-document-dirty)))))))

(setq claude-code-ide-mcp-tools (claude-code-ide-mcp-handlers--build-tool-list))

(defun claude-code-ide-mcp-handlers---build-tool-schemas ()
  "Build the tool schemas, conditionally including ediff tools."
  (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list "openFile") (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/type) (clojure-core-list '.) (clojure-core-list "object")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/properties) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/path) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/type) (clojure-core-list '.) (clojure-core-list "string")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/description) (clojure-core-list '.) (clojure-core-list "Path to the file to open")))))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/startLine) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/type) (clojure-core-list '.) (clojure-core-list "integer")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/description) (clojure-core-list '.) (clojure-core-list "Start line for selection")))))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/endLine) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/type) (clojure-core-list '.) (clojure-core-list "integer")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/description) (clojure-core-list '.) (clojure-core-list "End line for selection")))))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/startText) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/type) (clojure-core-list '.) (clojure-core-list "string")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/description) (clojure-core-list '.) (clojure-core-list "Start text pattern for selection (takes precedence over line numbers)")))))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/endText) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/type) (clojure-core-list '.) (clojure-core-list "string")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/description) (clojure-core-list '.) (clojure-core-list "End text pattern for selection")))))))))))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/required) (clojure-core-list '.) (clojure-core-list (apply clojure-core-vector (clel-seq (clel-concat (clojure-core-list "path")))))))))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list "getCurrentSelection") (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/type) (clojure-core-list '.) (clojure-core-list "object")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/properties) (clojure-core-list '.) (clojure-core-list :json-empty)))))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list "getOpenEditors") (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/type) (clojure-core-list '.) (clojure-core-list "object")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/properties) (clojure-core-list '.) (clojure-core-list :json-empty)))))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list "getWorkspaceFolders") (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/type) (clojure-core-list '.) (clojure-core-list "object")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/properties) (clojure-core-list '.) (clojure-core-list :json-empty)))))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list "getDiagnostics") (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/type) (clojure-core-list '.) (clojure-core-list "object")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/properties) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/uri) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/type) (clojure-core-list '.) (clojure-core-list "string")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/description) (clojure-core-list '.) (clojure-core-list "Optional file URI to get diagnostics for. If not provided, gets diagnostics for all files.")))))))))))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/required) (clojure-core-list '.) (clojure-core-list (apply clojure-core-vector (clel-seq (clel-concat))))))))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list "saveDocument") (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/type) (clojure-core-list '.) (clojure-core-list "object")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/properties) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/path) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/type) (clojure-core-list '.) (clojure-core-list "string")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/description) (clojure-core-list '.) (clojure-core-list "Path to the file to save")))))))))))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/required) (clojure-core-list '.) (clojure-core-list (apply clojure-core-vector (clel-seq (clel-concat (clojure-core-list "path")))))))))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list "close_tab") (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/type) (clojure-core-list '.) (clojure-core-list "object")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/properties) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/path) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/type) (clojure-core-list '.) (clojure-core-list "string")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/description) (clojure-core-list '.) (clojure-core-list "Path to the file to close")))))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/tab_name) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/type) (clojure-core-list '.) (clojure-core-list "string")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/description) (clojure-core-list '.) (clojure-core-list "Name of the tab to close")))))))))))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/required) (clojure-core-list '.) (clojure-core-list (apply clojure-core-vector (clel-seq (clel-concat))))))))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/deref) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/when) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/bound-and-true-p) (clojure-core-list 'clojure.core/claude-code-ide-use-ide-diff)))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'quote) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list "openDiff") (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/type) (clojure-core-list '.) (clojure-core-list "object")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/properties) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/old_file_path) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/type) (clojure-core-list '.) (clojure-core-list "string")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/description) (clojure-core-list '.) (clojure-core-list "Path to the original file")))))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/new_file_path) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/type) (clojure-core-list '.) (clojure-core-list "string")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/description) (clojure-core-list '.) (clojure-core-list "Path to the new file (usually same as old)")))))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/new_file_contents) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/type) (clojure-core-list '.) (clojure-core-list "string")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/description) (clojure-core-list '.) (clojure-core-list "New content to diff against")))))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/tab_name) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/type) (clojure-core-list '.) (clojure-core-list "string")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/description) (clojure-core-list '.) (clojure-core-list "Name for the diff tab")))))))))))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/required) (clojure-core-list '.) (clojure-core-list (apply clojure-core-vector (clel-seq (clel-concat (clojure-core-list "old_file_path") (clojure-core-list "new_file_path") (clojure-core-list "new_file_contents") (clojure-core-list "tab_name")))))))))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list "closeAllDiffTabs") (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/type) (clojure-core-list '.) (clojure-core-list "object")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/properties) (clojure-core-list '.) (clojure-core-list :json-empty)))))))))))))))))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list "checkDocumentDirty") (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/type) (clojure-core-list '.) (clojure-core-list "object")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/properties) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/filePath) (clojure-core-list '.) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/type) (clojure-core-list '.) (clojure-core-list "string")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/description) (clojure-core-list '.) (clojure-core-list "Path to the file to check")))))))))))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/required) (clojure-core-list '.) (clojure-core-list (apply clojure-core-vector (clel-seq (clel-concat (clojure-core-list "filePath")))))))))))))))))

(setq claude-code-ide-mcp-tool-schemas (claude-code-ide-mcp-handlers--build-tool-schemas))

(defun claude-code-ide-mcp-handlers---build-tool-descriptions ()
  "Build the tool descriptions, conditionally including ediff tools."
  (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list "openFile") (clojure-core-list '.) (clojure-core-list "Open a file in the editor and optionally select a range of text")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list "getCurrentSelection") (clojure-core-list '.) (clojure-core-list "Get the currently selected text and its location")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list "getOpenEditors") (clojure-core-list '.) (clojure-core-list "Get the list of currently open editors/buffers")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list "getWorkspaceFolders") (clojure-core-list '.) (clojure-core-list "Get the current workspace/project folders")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list "getDiagnostics") (clojure-core-list '.) (clojure-core-list "Get language diagnostics from Emacs")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list "saveDocument") (clojure-core-list '.) (clojure-core-list "Save a document to disk")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list "close_tab") (clojure-core-list '.) (clojure-core-list "Close a tab/buffer")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/deref) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/when) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'clojure.core/bound-and-true-p) (clojure-core-list 'clojure.core/claude-code-ide-use-ide-diff)))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list 'quote) (clojure-core-list (clel-seq (clel-concat (clojure-core-list (clel-seq (clel-concat (clojure-core-list "openDiff") (clojure-core-list '.) (clojure-core-list "Open a diff view comparing old and new file contents")))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list "closeAllDiffTabs") (clojure-core-list '.) (clojure-core-list "Close all open diff tabs in the current session")))))))))))))))) (clojure-core-list (clel-seq (clel-concat (clojure-core-list "checkDocumentDirty") (clojure-core-list '.) (clojure-core-list "Check if a document has unsaved changes")))))))

(setq claude-code-ide-mcp-tool-descriptions (claude-code-ide-mcp-handlers--build-tool-descriptions))

(provide 'claude-code-ide-mcp-handlers)
;;; claude-code-ide-mcp-handlers.el ends here
